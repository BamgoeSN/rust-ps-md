<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Snippets for Competitive Programming</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">How to use</a></li><li class="chapter-item expanded affix "><li class="part-title">Algebra</li><li class="chapter-item expanded "><a href="algebra/gcd.html"><strong aria-hidden="true">1.</strong> GCD, LCM</a></li><li class="chapter-item expanded "><a href="algebra/extgcd.html"><strong aria-hidden="true">2.</strong> Extended Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="algebra/crt.html"><strong aria-hidden="true">3.</strong> Chinese Remainder Theorem</a></li><li class="chapter-item expanded "><a href="algebra/millerrabin.html"><strong aria-hidden="true">4.</strong> Primality Test</a></li><li class="chapter-item expanded "><a href="algebra/pollardrho.html"><strong aria-hidden="true">5.</strong> Prime Factorization</a></li><li class="chapter-item expanded affix "><li class="part-title">Numerical Algorithms</li><li class="chapter-item expanded "><a href="numerical/isqrt.html"><strong aria-hidden="true">6.</strong> Integer Square Root</a></li><li class="chapter-item expanded "><a href="numerical/linrec/intro.html"><strong aria-hidden="true">7.</strong> Linear Recurrence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="numerical/linrec/berlekamp.html"><strong aria-hidden="true">7.1.</strong> Berlekamp-Massey</a></li><li class="chapter-item expanded "><a href="numerical/linrec/kitamasa.html"><strong aria-hidden="true">7.2.</strong> Kitamasa</a></li><li class="chapter-item expanded "><a href="numerical/linrec/bostanmori.html"><strong aria-hidden="true">7.3.</strong> Bostan-Mori</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Data Structures</li><li class="chapter-item expanded "><a href="datastructure/bitarray.html"><strong aria-hidden="true">8.</strong> Bit Array</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/intro.html"><strong aria-hidden="true">9.</strong> Segment Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datastructure/segtree/segtree.html"><strong aria-hidden="true">9.1.</strong> Segment Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/fenwick.html"><strong aria-hidden="true">9.2.</strong> Fenwick Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/lazyseg.html"><strong aria-hidden="true">9.3.</strong> Lazy Segment Tree</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Graphs</li><li class="chapter-item expanded "><a href="graphs/adjlist.html"><strong aria-hidden="true">10.</strong> Adjacency List Graph Representation</a></li><li class="chapter-item expanded "><a href="graphs/dsu.html"><strong aria-hidden="true">11.</strong> Disjoint Set Union</a></li><li class="chapter-item expanded "><a href="graphs/scc.html"><strong aria-hidden="true">12.</strong> Strongly Connected Components</a></li><li class="chapter-item expanded "><a href="graphs/2sat.html"><strong aria-hidden="true">13.</strong> 2-SAT</a></li><li class="chapter-item expanded affix "><li class="part-title">Geometry</li><li class="chapter-item expanded "><a href="geometry/convexhull.html"><strong aria-hidden="true">14.</strong> Convex Hull</a></li><li class="chapter-item expanded affix "><li class="part-title">Unclassified</li><li class="chapter-item expanded "><a href="unclass/valcomp.html"><strong aria-hidden="true">15.</strong> Value Compression</a></li><li class="chapter-item expanded "><a href="unclass/lis.html"><strong aria-hidden="true">16.</strong> Longest Increasing Subsequence</a></li><li class="chapter-item expanded affix "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="misc/psbase.html"><strong aria-hidden="true">17.</strong> Base Template</a></li><li class="chapter-item expanded "><a href="misc/zero_one_trait.html"><strong aria-hidden="true">18.</strong> Zero/One Trait</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Snippets for Competitive Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BamgoeSN/rust-ps-md" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="how-to-use"><a class="header" href="#how-to-use">How to use</a></h1>
<p>For any algorithm included here, simply copy its snippet and paste into your code, then it's done!</p>
<p>Some snippets might require other snippets from another section. For such snippets, every required section will be linked on it, so that you can get the snippet right away. You simply copy all those and paste to your code before you paste the original snippet you were going to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcd"><a class="header" href="#gcd">GCD</a></h1>
<p>Returns the greatest common divisor of a and b.</p>
<pre><code class="language-rust noplayground">fn gcd(mut a: i64, mut b: i64) -&gt; i64 {
    while b != 0 {
        let t = b;
        b = a % b;
        a = t;
    }
    a
}
</code></pre>
<h1 id="lcm"><a class="header" href="#lcm">LCM</a></h1>
<p>Returns the least common multiplier of a and b.</p>
<p>Required snippets: <a href="algebra/gcd.html#gcd">GCD</a></p>
<pre><code class="language-rust noplayground">fn lcm(a: i64, b: i64) -&gt; i64 {
    a / gcd(a, b) * b
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extended-euclid-algorithm"><a class="header" href="#extended-euclid-algorithm">Extended Euclid Algorithm</a></h1>
<p>Returns \(r, s, t\) such that \(r = \gcd(a, b)\) and \(as+bt=r\).</p>
<pre><code class="language-rust noplayground">fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut r, mut old_r) = (b, a);
    while r != 0 {
        let q = old_r / r;

        let new_r = old_r - q * r;
        old_r = r;
        r = new_r;

        let new_s = old_s - q * s;
        old_s = s;
        s = new_s;
    }

    (
        old_r,
        old_s,
        if b != 0 { (old_r - old_s * a) / b } else { 0 },
    )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chinese-remainder-theorem"><a class="header" href="#chinese-remainder-theorem">Chinese Remainder Theorem</a></h1>
<p>Reference: PyRival <a href="https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py">https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py</a></p>
<p>Returns \(x\) such that \(x = r_i \mod m_i\) for all \(i\). </p>
<p>Required snippets: <a href="algebra/gcd.html#gcd">GCD</a>, <a href="algebra/extgcd.html#extended-euclid-algorithm">Extended Euclidean Algorithm</a></p>
<pre><code class="language-rust noplayground">// Chinese remainder theorem
//
// Reference: PyRival &lt;https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py&gt;

#[inline(always)]
fn safe_mod(mut x: i64, m: i64) -&gt; i64 {
    x %= m;
    if x &lt; 0 {
        x + m
    } else {
        x
    }
}

/// Returns the greatest common divisor of a and b
fn gcd(mut a: i64, mut b: i64) -&gt; i64 {
    while b != 0 {
        let t = b;
        b = a % b;
        a = t;
    }
    a
}

/// Returns gcd(a, b), s, r s.t. a*s + b*r = gcd(a, b)
fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut r, mut old_r) = (b, a);
    while r != 0 {
        let q = old_r / r;

        let new_r = old_r - q * r;
        old_r = r;
        r = new_r;

        let new_s = old_s - q * s;
        old_s = s;
        s = new_s;
    }

    (
        old_r,
        old_s,
        if b != 0 { (old_r - old_s * a) / b } else { 0 },
    )
}

/// Returns $x$ s.t. $x=r_i (mod m_i)$ for all $i$
fn crt(r: &amp;[i64], m: &amp;[i64]) -&gt; Option&lt;i64&gt; {
    let (mut x, mut m_prod) = (0, 1);
    for (bi, mi) in r.iter().zip(m.iter()) {
        let (g, s, _) = ext_gcd(m_prod, *mi);
        if safe_mod((bi - x) % mi, g) != 0 {
            return None;
        }
        x += m_prod * (s * safe_mod(bi - x, *mi) / g);
        m_prod = (m_prod * mi) / gcd(m_prod, *mi);
    }
    Some(safe_mod(x, m_prod))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miller-rabin-primality-test"><a class="header" href="#miller-rabin-primality-test">Miller-Rabin Primality Test</a></h1>
<p>Deterministic Miller-Rabin primality test determines whether a certain unsigned integer is a prime or not within \(O(\log{n})\) time. This test only works for integers under \(2^{64}\).</p>
<p>Required snippets: <a href="algebra/../misc/zero_one_trait.html#zeroone-trait">ZeroOne</a></p>
<pre><code class="language-rust noplayground">use std::ops::{BitAnd, Mul, Rem, RemAssign, ShrAssign};

trait Cast&lt;T&gt; {
    fn cast_to(self) -&gt; T;
}

macro_rules! impl_primitive_cast {
    ($t:ty, $u:ty) =&gt; {
        impl Cast&lt;$t&gt; for $u {
            #[inline(always)]
            fn cast_to(self) -&gt; $t {
                self as $t
            }
        }
    };
}

#[inline(always)]
fn rem_mul&lt;T, U&gt;(x: T, y: T, m: T) -&gt; T
where
    T: Copy + Cast&lt;U&gt;,
    U: Copy + Mul&lt;Output = U&gt; + Rem&lt;Output = U&gt; + Cast&lt;T&gt;,
{
    let (x, y, m): (U, U, U) = (x.cast_to(), y.cast_to(), m.cast_to());
    ((x * y) % m).cast_to()
}

#[inline]
fn rem_pow&lt;T, U&gt;(mut base: T, mut exp: T, m: T) -&gt; T
where
    T: Copy + ZeroOne + Eq + RemAssign + BitAnd&lt;Output = T&gt; + ShrAssign + Cast&lt;U&gt;,
    U: Copy + Mul&lt;Output = U&gt; + Rem&lt;Output = U&gt; + Cast&lt;T&gt;,
{
    exp %= m;
    let mut r = T::one();
    while exp != T::zero() {
        if exp &amp; T::one() != T::zero() {
            r = rem_mul::&lt;T, U&gt;(r, base, m);
        }
        exp &gt;&gt;= T::one();
        base = rem_mul::&lt;T, U&gt;(base, base, m);
    }
    r
}

trait Miller {
    fn naive_primality(self) -&gt; bool;
    fn miller_rabin(self, a: Self) -&gt; bool;
    fn miller_primality(self) -&gt; bool;
    fn is_prime(self) -&gt; bool;
}

macro_rules! miller_rabin_impl {
    ($t:ty, $u:ty, $limit:expr,  $($x:expr),*) =&gt; {
        impl_primitive_cast!($t, $u);
        impl_primitive_cast!($u, $t);

        impl Miller for $t {
            #[inline]
            fn naive_primality(self) -&gt; bool {
                let mut i: $t = 2;
                while i * i &lt;= self {
                    if self % i == 0 {
                        return false;
                    }
                    i += 1;
                }
                true
            }

            fn miller_rabin(self, a: $t) -&gt; bool {
                let d = self - 1;
                let mut p = d;
                while p&amp;1==0 {
                    p&gt;&gt;=1;
                }
                let mut t = rem_pow::&lt;$t, $u&gt;(a, p, self);
                let at_last = t == d || t == 1;

                while p!=d {
                    p &lt;&lt;= 1;
                    t = rem_mul::&lt;$t, $u&gt;(t, t, self);
                    if t == self-1 {return true;}
                }

                at_last
            }

            fn miller_primality(self) -&gt; bool {
                $(
                    if !self.miller_rabin($x) {
                        return false;
                    }
                )*
                true
            }

            fn is_prime(self) -&gt; bool {
                if self &lt;= 1 {
                    false
                } else if self &lt;= ($limit) {
                    Self::naive_primality(self)
                } else {
                    Self::miller_primality(self)
                }
            }
        }
    };
}

miller_rabin_impl!(u8, u16, 254, 2);
miller_rabin_impl!(u16, u32, 2000, 2, 3);
miller_rabin_impl!(u32, u64, 10000, 2, 7, 61);
miller_rabin_impl!(u64, u128, 1000000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-rust noplayground">assert!(3284729387909u64.is_prime());
assert!(!3284729387911u64.is_prime()); // 53×61976026187
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pollard-rho-algorithm"><a class="header" href="#pollard-rho-algorithm">Pollard Rho Algorithm</a></h1>
<p>Pollard rho algorithm is a randomized algorithm which factorizes a number in an average of \(O(n^{1/4})\) time.</p>
<pre><code class="language-rust noplayground">struct RNG {
    val: u64,
}

impl RNG {
    /// Returns a new RNG instance starting with a given seed.
    fn new(seed: u64) -&gt; Self {
        Self { val: seed }
    }

    /// Returns a random u64 number.
    fn next(&amp;mut self) -&gt; u64 {
        let mut x = self.val;
        x ^= x &lt;&lt; 13;
        x ^= x &gt;&gt; 7;
        x ^= x &lt;&lt; 17;
        self.val = x;
        x
    }

    /// Returns a random f64 number within [0, 1].
    fn next_f64(&amp;mut self) -&gt; f64 {
        (self.next() as f64) / (u64::MAX as f64)
    }

    /// Returns a random u64 number within [l, r).
    fn range_u64(&amp;mut self, l: u64, r: u64) -&gt; u64 {
        l + self.next() % (r - l)
    }

    /// Returns a random i64 number within [l, r).
    fn range_i64(&amp;mut self, l: i64, r: i64) -&gt; i64 {
        l + (self.next() / 2) as i64 % (r - l)
    }

    /// Returns a random f64 number within [l, r].
    fn range_f64(&amp;mut self, l: f64, r: f64) -&gt; f64 {
        l + self.next_f64() * (r - l)
    }
}

trait Miller {
    fn rem_mul(x: Self, y: Self, m: Self) -&gt; Self;
    fn rem_pow(base: Self, exp: Self, m: Self) -&gt; Self;
    fn naive_primality(self) -&gt; bool;
    fn miller_rabin(self, a: Self) -&gt; bool;
    fn miller_primality(self) -&gt; bool;
    fn is_prime(self) -&gt; bool;
}

macro_rules! miller_rabin_impl {
    ($t:ty, $u:ty, $limit:expr,  $($x:expr),*) =&gt; {
        impl Miller for $t {
            #[inline]
            fn rem_mul(x: $t, y: $t, m: $t) -&gt; $t {
                ((x as $u * y as $u) % m as $u) as $t
            }
            fn rem_pow(mut base: $t, mut exp: $t, m: $t) -&gt; $t {
                exp %= m;
                let mut r: $t = 1;
                while exp != 0 {
                    if exp &amp; 1 != 0 {
                        r = Self::rem_mul(r, base, m);
                    }
                    exp &gt;&gt;= 1;
                    base = Self::rem_mul(base, base, m);
                }
                r
            }
            fn naive_primality(self) -&gt; bool {
                let mut i: $t = 2;
                while i * i &lt;= self {
                    if self % i == 0 {
                        return false;
                    }
                    i += 1;
                }
                true
            }
            fn miller_rabin(self, a: $t) -&gt; bool {
                let d = self - 1;
                let mut p = d;
                while p&amp;1==0 {
                    p&gt;&gt;=1;
                }
                let mut t = Self::rem_pow(a, p, self);
                let at_last = t == d || t == 1;

                while p!=d {
                    p &lt;&lt;= 1;
                    t = Self::rem_mul(t, t, self);
                    if t == self-1 {return true;}
                }

                at_last
            }
            fn miller_primality(self) -&gt; bool {
                $(
                    if !self.miller_rabin($x) {
                        return false;
                    }
                )*
                true
            }
            fn is_prime(self) -&gt; bool {
                if self &lt;= 1 {
                    false
                } else if self &lt;= ($limit) {
                    Self::naive_primality(self)
                } else {
                    Self::miller_primality(self)
                }
            }
        }
    };
}

miller_rabin_impl!(u8, u16, 254, 2);
miller_rabin_impl!(u16, u32, 2000, 2, 3);
miller_rabin_impl!(u32, u64, 10000, 2, 7, 61);
miller_rabin_impl!(u64, u128, 1000000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);

fn gcd(mut a: u64, mut b: u64) -&gt; u64 {
    while b != 0 {
        let t = b;
        b = a % b;
        a = t;
    }
    a
}

#[inline]
fn rem_add(a: u64, b: u64, m: u64) -&gt; u64 {
    ((a as u128 + b as u128) % m as u128) as u64
}

#[inline]
fn abs_diff(a: u64, b: u64) -&gt; u64 {
    if a &gt; b {
        a - b
    } else {
        b - a
    }
}

fn factorize(mut n: u64, rng: &amp;mut RNG) -&gt; Vec&lt;u64&gt; {
    if n &lt;= 1 {
        return Vec::new();
    }
    let mut arr: Vec&lt;u64&gt; = Vec::new();
    while n &amp; 1 == 0 {
        n &gt;&gt;= 1;
        arr.push(2);
    }
    rho(n, &amp;mut arr, rng);
    arr
}

fn rho(n: u64, arr: &amp;mut Vec&lt;u64&gt;, rng: &amp;mut RNG) {
    if n &lt;= 1 {
        return;
    } else if n.is_prime() {
        arr.push(n);
        return;
    }

    let mut i = 0u64;
    let mut x = rng.next() % n;
    let mut y = x;
    let mut k = 2u64;
    let mut d;
    let mut reset_limit = 500000;

    loop {
        i += 1;
        x = rem_add(Miller::rem_mul(x, x, n), n - 1, n);
        d = gcd(abs_diff(y, x), n);
        if d == n || i &gt;= reset_limit {
            // Reset
            reset_limit = reset_limit * 3 / 2;
            i = 0;
            x = rng.next();
            y = x;
        }
        if d != 1 {
            break;
        }
        if i == k {
            y = x;
            k &lt;&lt;= 1;
        }
    }

    if d != n {
        rho(d, arr, rng);
        rho(n / d, arr, rng);
        return;
    }

    i = 3;
    while i * i &lt;= n {
        if n % i == 0 {
            rho(i, arr, rng);
            rho(d / i, arr, rng);
            return;
        }
        i += 2;
    }
}
</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-rust noplayground">let mut rng = RNG::new(12345);
let a = 3284729387911u64;
let mut factors = factorize(a, &amp;mut rng);
factors.sort();
assert_eq!(factors, [53, 61976026187]);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-square-root"><a class="header" href="#integer-square-root">Integer Square Root</a></h1>
<pre><code class="language-rust noplayground">fn isqrt(s: u64) -&gt; u64 {
    let mut x0 = s &gt;&gt; 1;
    if x0 != 0 {
        let mut x1 = (x0 + s / x0) &gt;&gt; 1;
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) &gt;&gt; 1
        }
        x0
    } else {
        s
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-recurrence"><a class="header" href="#linear-recurrence">Linear Recurrence</a></h1>
<p>Algorithms related to linear recurrences</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="berlekamp-massey"><a class="header" href="#berlekamp-massey">Berlekamp-Massey</a></h1>
<pre><code class="language-rust noplayground">fn rem_pow(mut base: i64, mut exp: i64, m: i64) -&gt; i64 {
    let mut result = 1;
    while exp != 0 {
        if exp &amp; 1 != 0 {
            result = (result * base) % m;
        }
        exp &gt;&gt;= 1;
        base = (base * base) % m;
    }
    result
}

/// Finds rec[n] which satisfies
/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rev[d-1]vals[d-1]
/// with minimum n.
pub fn berlekamp_massey(vals: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let m = m as i64;
    let mut cur: Vec&lt;i64&gt; = Vec::new();
    let (mut lf, mut ld) = (0, 0);
    let mut ls: Vec&lt;i64&gt; = Vec::new();
    for i in 0..vals.len() {
        let mut t = 0;
        for (j, v) in cur.iter().enumerate() {
            t = (t + vals[i - j - 1] as i64 * v) % m;
        }

        if (t - vals[i] as i64) % m == 0 {
            continue;
        }

        if cur.len() == 0 {
            cur = vec![0; i + 1];
            lf = i;
            ld = (t - vals[i] as i64) % m;
            continue;
        }

        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;
        let mut c: Vec&lt;i64&gt; = vec![0; i - lf + ls.len()];
        c[i - lf - 1] = k as i64;
        for (p, j) in ls.iter().enumerate() {
            c[i - lf + p] = -j * k % m;
        }

        if c.len() &lt; cur.len() {
            c.extend((0..(cur.len() - c.len())).map(|_| 0));
        }

        for j in 0..cur.len() {
            c[j] = (c[j] + cur[j]) % m;
        }

        if i - lf + ls.len() &gt;= cur.len() {
            ls = cur;
            lf = i;
            ld = (t - vals[i] as i64) % m;
        }

        cur = c;
    }

    for i in 0..cur.len() {
        cur[i] = (cur[i] % m + m) % m;
    }

    cur.into_iter().rev().map(|x| x as u64).collect()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kitamasa"><a class="header" href="#kitamasa">Kitamasa</a></h1>
<pre><code class="language-rust noplayground">fn poly_mul(v: &amp;[u64], w: &amp;[u64], rec: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut t = vec![0; 2 * v.len()];

    for j in 0..v.len() {
        for k in 0..w.len() {
            t[j + k] += v[j] * w[k] % m;
            if t[j + k] &gt;= m {
                t[j + k] -= m;
            }
        }
    }

    for j in (v.len()..2 * v.len()).rev() {
        for k in 1..=v.len() {
            t[j - k] += t[j] * rec[k - 1] % m;
            if t[j - k] &gt;= m {
                t[j - k] -= m;
            }
        }
    }

    t[..v.len()].iter().map(|x| *x).collect()
}

/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under modulo m where d=rec.len()=arr.len()
fn kitamasa(rec: &amp;[u64], vals: &amp;[u64], mut n: u64, m: u64) -&gt; u64 {
    let recurr: Vec&lt;_&gt; = rec.iter().rev().copied().collect();
    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);
    s[0] = 1;
    if recurr.len() != 1 {
        t[1] = 1;
    } else {
        t[0] = recurr[0];
    }

    while n != 0 {
        if n &amp; 1 != 0 {
            s = poly_mul(&amp;s, &amp;t, &amp;recurr, m);
        }
        t = poly_mul(&amp;t, &amp;t, &amp;recurr, m);
        n &gt;&gt;= 1;
    }

    let mut ret = 0u64;
    for i in 0..recurr.len() {
        ret += s[i] * vals[i] % m;
        if ret &gt;= m {
            ret -= m;
        }
    }
    ret
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bostan-mori"><a class="header" href="#bostan-mori">Bostan-Mori</a></h1>
<p>Reference - <a href="https://hal.inria.fr/hal-02917827v2/document">Alin Bostan, Ryuhei Mori. A Simple and Fast Algorithm for Computing the N-th Term of a Linearly Recurrent Sequence. SOSA’21 (SIAM Symposium on Simplicity in Algorithms), Jan 2021, Alexandria, United States. ffhal-02917827v2f</a></p>
<h2 id="calculating-one-value-of-the-sequence"><a class="header" href="#calculating-one-value-of-the-sequence">Calculating one value of the sequence</a></h2>
<h3 id="naive-multiplication-under-prime-modulo"><a class="header" href="#naive-multiplication-under-prime-modulo">Naive multiplication, under prime modulo</a></h3>
<pre><code class="language-rust noplayground">/// Returns g, s, t s.t. g=gcd(a,b) and as+bt=r
#[inline(always)]
fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut r, mut old_r) = (b, a);
    while r != 0 {
        let q = old_r / r;

        let new_r = old_r - q * r;
        old_r = r;
        r = new_r;

        let new_s = old_s - q * s;
        old_s = s;
        s = new_s;
    }

    (
        old_r,
        old_s,
        if b != 0 { (old_r - old_s * a) / b } else { 0 },
    )
}

fn mod_inv(a: u64, m: u64) -&gt; u64 {
    let (_, mut x, _) = ext_gcd((a % m) as i64, m as i64);
    if x &lt; 0 {
        x += m as i64;
    }
    x as u64 % m
}

/// f = f[0] + f[1]x + f[2]x2 + ...
#[inline(always)]
fn poly_mul(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; f.len() + g.len() - 1];
    for (i, &amp;u) in f.iter().enumerate() {
        // u*x**i
        for (j, &amp;v) in g.iter().enumerate() {
            // v*x**j
            h[i + j] += u * v;
            h[i + j] %= m;
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

#[inline(always)]
fn poly_mul_even_order(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; (f.len() + g.len()) / 2 + 2];
    for (i, &amp;u) in f.iter().enumerate() {
        if i &amp; 1 == 0 {
            for (j, &amp;v) in g.iter().enumerate().step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        } else {
            for (j, &amp;v) in g.iter().enumerate().skip(1).step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

#[inline(always)]
fn poly_mul_odd_order(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; (f.len() + g.len()) / 2 + 2];
    for (i, &amp;u) in f.iter().enumerate() {
        if i &amp; 1 != 0 {
            for (j, &amp;v) in g.iter().enumerate().step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        } else {
            for (j, &amp;v) in g.iter().enumerate().skip(1).step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

/// f(x) -&gt; f(-x)
#[inline(always)]
fn get_neg_x(f: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    f.iter()
        .enumerate()
        .map(|(i, &amp;v)| if i &amp; 1 == 0 { v } else { m - v })
        .collect()
}

/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under modulo m where d=rec.len()=arr.len()
fn bostan_mori(rec: &amp;[u64], vals: &amp;[u64], n: u64, m: u64) -&gt; u64 {
    if vals.len() as u64 &gt; n {
        return vals[n as usize];
    }
    let d = rec.len();

    let mut q: Vec&lt;u64&gt; = Vec::with_capacity(d + 1);
    q.push(1);
    q.extend(rec.iter().map(|&amp;v| m - v).rev());

    let mut p = poly_mul(vals, &amp;q, m);
    p.truncate(d);

    let mut n = n;
    while n &gt;= 1 {
        let mq = get_neg_x(&amp;q, m);
        if n &amp; 1 == 0 {
            p = poly_mul_even_order(&amp;p, &amp;mq, m);
        } else {
            p = poly_mul_odd_order(&amp;p, &amp;mq, m);
        }
        q = poly_mul_even_order(&amp;q, &amp;mq, m);
        n &gt;&gt;= 1;
    }
    p[0] * mod_inv(q[0], m) // Requires GCD(q[0], m) = 1, it's safe to have m as a prime
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-array"><a class="header" href="#bit-array">Bit Array</a></h1>
<pre><code class="language-rust noplayground">struct BitArray {
    bytes: Vec&lt;u8&gt;,
}

impl BitArray {
    #[inline(always)]
    fn new(size: usize) -&gt; Self {
        Self {
            bytes: vec![0; (size &gt;&gt; 3) + 1],
        }
    }

    #[inline(always)]
    fn get(&amp;self, idx: usize) -&gt; bool {
        (self.bytes[idx &gt;&gt; 3] &gt;&gt; (idx &amp; 0b111)) &amp; 1 == 1
    }

    #[inline(always)]
    fn set_true(&amp;mut self, idx: usize) {
        self.bytes[idx &gt;&gt; 3] |= 1 &lt;&lt; (idx &amp; 0b111);
    }

    #[inline(always)]
    fn set_false(&amp;mut self, idx: usize) {
        self.bytes[idx &gt;&gt; 3] &amp;= !(1 &lt;&lt; (idx &amp; 0b111));
    }

    #[inline(always)]
    fn set(&amp;mut self, idx: usize, to: bool) {
        if to {
            self.set_true(idx);
        } else {
            self.set_false(idx);
        }
    }

    #[inline(always)]
    fn toggle(&amp;mut self, idx: usize) {
        self.bytes[idx &gt;&gt; 3] ^= 1 &lt;&lt; (idx &amp; 0b111);
    }

    #[inline(always)]
    fn fill(&amp;mut self, with: u8) {
        for v in self.bytes.iter_mut() {
            *v = with;
        }
    }

    #[inline(always)]
    fn fill_range(&amp;mut self, chunk_start: usize, chunk_end: usize, with: u8) {
        for v in self.bytes[chunk_start..chunk_end].iter_mut() {
            *v = with;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-trees"><a class="header" href="#segment-trees">Segment Trees</a></h1>
<p>Segment trees are a category of data structures which can handle range queries efficiently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A segment tree is a data structure for monoids \( (S, \cdot : S \times S \rightarrow S, e \in S) \). A monoid is an algebraic structure which follows the following conditions:</p>
<ul>
<li>\(\cdot\) is associative. That is, \( (a \cdot b) \cdot c = a \cdot (b \cdot c) \) for all \( a, b, c \in S \).</li>
<li>There is the identity element \(e\) such that \( a \cdot e = e \cdot a = a \) for all \( a \in S \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(S\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Update an element</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<pre><code class="language-rust noplayground">use std::ops::Index;

fn ceil_pow2(n: usize) -&gt; usize {
    let mut x: usize = 0;
    while (1 &lt;&lt; x) &lt; n {
        x += 1;
    }
    x
}

/// Represents each element of a segment tree, which should be a monoid $(S, \cdot)$.
trait Monoid {
    fn opr(&amp;self, other: &amp;Self) -&gt; Self;
    fn e() -&gt; Self;
}

/// Segment tree.
struct SegTree&lt;S: Monoid&gt; {
    n: usize,
    size: usize,
    log: usize,
    data: Vec&lt;S&gt;,
}

impl&lt;S: Monoid + Clone&gt; SegTree&lt;S&gt; {
    fn update(&amp;mut self, k: usize) {
        self.data[k] = self.data[k &lt;&lt; 1].opr(&amp;self.data[(k &lt;&lt; 1) + 1])
    }

    /// Initializes a segment tree from an array.
    fn new(arr: &amp;Vec&lt;S&gt;) -&gt; Self {
        let log = ceil_pow2(arr.len());
        let mut st: Self = SegTree {
            n: arr.len(),
            log,
            size: 1 &lt;&lt; log,
            data: vec![S::e(); 1 &lt;&lt; (log + 1)],
        };
        for (i, v) in arr.into_iter().enumerate() {
            st.data[st.size + i] = (*v).clone();
        }
        for i in (1..st.size).rev() {
            st.update(i);
        }
        st
    }

    /// Sets a value at index `i` to a value `v`.
    fn set(&amp;mut self, i: usize, v: &amp;S) {
        let i = i + self.size;
        self.data[i] = v.clone();
        for j in 1..=self.log {
            self.update(i &gt;&gt; j);
        }
    }

    /// Gets a reference of a value at index `i`.
    fn get(&amp;self, i: usize) -&gt; &amp;S {
        &amp;self[i]
    }

    /// Returns $A_l \cdot A_{l+1} \cdot \cdots \cdot A_{r-1}$. If $l=r$, then returns $e$.
    fn prod(&amp;self, l: usize, r: usize) -&gt; S {
        let (mut sml, mut smr) = (S::e(), S::e());
        let (mut l, mut r) = (l + self.size, r + self.size);

        while l &lt; r {
            if l &amp; 1 == 1 {
                sml = sml.opr(&amp;self.data[l]);
                l += 1;
            }
            if r &amp; 1 == 1 {
                r -= 1;
                smr = self.data[r].opr(&amp;smr);
            }
            l &gt;&gt;= 1;
            r &gt;&gt;= 1;
        }
        sml.opr(&amp;smr)
    }

    /// Returns $A_0 \cdot A_1 \cdot \cdots A_{n-1}$.
    fn all_prod(&amp;self) -&gt; S {
        self.data[1].clone()
    }

    fn max_right&lt;C: Fn(&amp;S) -&gt; bool&gt;(&amp;self, l: usize, f: C) -&gt; usize {
        if l == self.n {
            return self.n;
        }

        let mut l = l + self.size;
        let mut sm = S::e();

        loop {
            while l &amp; 1 == 0 {
                l &gt;&gt;= 1;
            }
            if !f(&amp;sm.opr(&amp;self.data[l])) {
                while l &lt; self.size {
                    l &lt;&lt;= 1;
                    if f(&amp;sm.opr(&amp;self.data[l])) {
                        sm = sm.opr(&amp;self.data[l]);
                        l += 1;
                    }
                }
                return l - self.size;
            }
            sm = sm.opr(&amp;self.data[l]);
            l += 1;
            if l &amp; ((!l) + 1) == l {
                break;
            }
        }
        self.n
    }
    
    fn min_left&lt;C: Fn(&amp;S) -&gt; bool&gt;(&amp;self, r: usize, f: C) -&gt; usize {
        if r == 0 {
            return 0;
        }

        let mut r = r + self.size;
        let mut sm = S::e();

        loop {
            r -= 1;
            while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                r &gt;&gt;= 1;
            }
            if !f(&amp;self.data[r].opr(&amp;sm)) {
                while r &lt; self.size {
                    r = (r &lt;&lt; 1) + 1;
                    if f(&amp;self.data[r].opr(&amp;sm)) {
                        sm = self.data[r].opr(&amp;sm);
                        r -= 1;
                    }
                }
                return r + 1 - self.size;
            }
            sm = self.data[r].opr(&amp;sm);

            if r &amp; ((!r) + 1) == r {
                break;
            }
        }
        0
    }
}

impl&lt;T: Monoid + Clone&gt; Index&lt;usize&gt; for SegTree&lt;T&gt; {
    type Output = T;

    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self.data[index + self.size]
    }
}
</code></pre>
<h2 id="using-max_right-and-min_left"><a class="header" href="#using-max_right-and-min_left">Using max_right and min_left</a></h2>
<h3 id="max_right"><a class="header" href="#max_right">max_right</a></h3>
<p>Given an index \(l\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(r=l\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(r=n\) or \( f \left( A_l \cdot A_{l+1} \cdots A_r \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the maximum \(r\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq l \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(r\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<h3 id="min_left"><a class="header" href="#min_left">min_left</a></h3>
<p>Given an index \(r\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(l=r\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(l=0\) or \( f \left( A_{l-1} \cdot A_l \cdots A_{r-1} \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the minimum \(l\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq r \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(l\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fenwick-tree"><a class="header" href="#fenwick-tree">Fenwick Tree</a></h1>
<p>Given an integer array \(A\) of length \(n\), a Fenwick tree processes the following queries in \(O(\log{n})\) time:</p>
<ul>
<li>Add a certain amount to an element</li>
<li>Calculate the sum of the elements of an interval</li>
</ul>
<p>A Fenwick tree uses half the memory of a segment tree, but the performance in terms of time is just about the same.</p>
<p>Required snippets: <a href="datastructure/segtree/../../misc/zero_one_trait.html#zero">Zero Trait</a></p>
<pre><code class="language-rust noplayground">struct Fenwick&lt;T: Zero + AddAssign + Sub&lt;Output = T&gt;&gt; {
    n: usize,
    data: Vec&lt;T&gt;,
}

impl&lt;T: Zero + AddAssign + Sub&lt;Output = T&gt;&gt; Fenwick&lt;T&gt; {
    fn new(n: usize) -&gt; Self {
        Self {
            n,
            data: vec![T::zero(); n],
        }
    }

    fn add(&amp;mut self, idx: usize, val: T) {
        let mut idx = idx + 1;
        while idx &lt;= self.n {
            self.data[idx - 1] += val;
            idx += idx &amp; (!idx + 1);
        }
    }

    fn sum(&amp;self, l: usize, r: usize) -&gt; T {
        self.inner_sum(r) - self.inner_sum(l)
    }

    fn inner_sum(&amp;self, mut r: usize) -&gt; T {
        let mut s: T = T::zero();
        while r &gt; 0 {
            s += self.data[r - 1];
            r -= r &amp; (!r + 1);
        }
        s
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-segment-tree"><a class="header" href="#lazy-segment-tree">Lazy Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A lazy segment tree is a data struture for a pair of a monoid \( (S, \cdot : S \times S \rightarrow S, e \in S) \) and a set \(F\) of \(S \rightarrow S\) mappings that satisfies the following properties:</p>
<ul>
<li>\(F\) contains the identity mapping \(Id\) such that \( Id(x) = x \) for all \(x\in S\).</li>
<li>\(F\) is closed under composition. That is, \( f \circ g \in F \) for all \( f, g \in F \).</li>
<li>\( f (x \cdot y) = f(x) \cdot f(y) \) hold for all \(f \in F \) and \( x, y \in S \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(S\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Apply the mapping \( f \in F \) on all the elements of an interval</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<pre><code class="language-rust noplayground">fn ceil_pow2(n: usize) -&gt; usize {
    let mut x: usize = 0;
    while (1 &lt;&lt; x) &lt; n {
        x += 1;
    }
    x
}

/// Represents a monoid in a lazy segment tree $(S, \cdot)$.
trait Monoid {
    fn opr(&amp;self, other: &amp;Self) -&gt; Self;
    fn e() -&gt; Self;
}

/// Represents a map $F$ acting on the monoid $(S, \cdot)$.
trait Mapping&lt;T: Monoid&gt; {
    fn map(&amp;self, apply: &amp;T) -&gt; T;
    fn compos(&amp;self, other: &amp;Self) -&gt; Self;
    fn id() -&gt; Self;
}

/// Lazy segment tree for the monoid $(S, \cdot)$ and the map $F$.
struct LazySeg&lt;S: Monoid, F: Mapping&lt;S&gt;&gt; {
    n: usize,
    size: usize,
    log: usize,
    data: Vec&lt;S&gt;,
    lazy: Vec&lt;F&gt;,
}

impl&lt;S, F&gt; LazySeg&lt;S, F&gt;
where
    S: Monoid + Clone,
    F: Mapping&lt;S&gt; + Clone,
{
    fn update(&amp;mut self, k: usize) {
        self.data[k] = self.data[k &lt;&lt; 1].opr(&amp;self.data[(k &lt;&lt; 1) + 1]);
    }

    fn all_apply(&amp;mut self, k: usize, f: &amp;F) {
        self.data[k] = f.map(&amp;self.data[k]);
        if k &lt; self.size {
            self.lazy[k] = f.compos(&amp;self.lazy[k]);
        }
    }

    fn push(&amp;mut self, k: usize) {
        self.all_apply(k &lt;&lt; 1, &amp;self.lazy[k].clone());
        self.all_apply((k &lt;&lt; 1) + 1, &amp;self.lazy[k].clone());
        self.lazy[k] = F::id();
    }

    /// Initializes the lazy segment tree from the given array.
    fn new(arr: &amp;Vec&lt;S&gt;) -&gt; Self {
        let log = ceil_pow2(arr.len());
        let mut ls: Self = LazySeg {
            n: arr.len(),
            log,
            size: 1 &lt;&lt; log,
            data: vec![S::e(); 1 &lt;&lt; (log + 1)],
            lazy: vec![F::id(); 1 &lt;&lt; log],
        };
        for (i, v) in arr.into_iter().enumerate() {
            ls.data[ls.size + i] = (*v).clone();
        }
        for i in (1..ls.size).rev() {
            ls.update(i);
        }
        ls
    }

    /// Sets a value at the index `i` to `v`.
    fn set(&amp;mut self, i: usize, v: &amp;S) {
        let i = i + self.size;
        for j in (1..=self.log).rev() {
            self.push(i &gt;&gt; j);
        }
        self.data[i] = v.clone();
        for j in 1..=self.log {
            self.update(i &gt;&gt; j);
        }
    }

    /// Returns a reference to the value at the index `i`.
    fn get(&amp;mut self, i: usize) -&gt; &amp;S {
        let i = i + self.size;
        for j in (1..=self.log).rev() {
            self.push(i &gt;&gt; j);
        }
        &amp;self.data[i]
    }

    /// Returns a product of elements in [l, r).
    fn prod(&amp;mut self, l: usize, r: usize) -&gt; S {
        if l == r {
            return S::e();
        }

        let (mut l, mut r) = (l + self.size, r + self.size);

        for i in (1..=self.log).rev() {
            if ((l &gt;&gt; i) &lt;&lt; i) != l {
                self.push(l &gt;&gt; i);
            }
            if ((r &gt;&gt; i) &lt;&lt; i) != r {
                self.push((r - 1) &gt;&gt; i);
            }
        }

        let (mut sml, mut smr) = (S::e(), S::e());
        while l &lt; r {
            if l &amp; 1 == 1 {
                sml = sml.opr(&amp;self.data[l]);
                l += 1;
            }
            if r &amp; 1 == 1 {
                r -= 1;
                smr = self.data[r].opr(&amp;smr);
            }
            l &gt;&gt;= 1;
            r &gt;&gt;= 1;
        }

        sml.opr(&amp;smr)
    }

    /// Returns the product of every elements.
    fn all_prod(&amp;self) -&gt; S {
        self.data[1].clone()
    }

    /// Apply a map `f` to the element at `i`.
    fn apply(&amp;mut self, i: usize, f: &amp;F) {
        let i = i + self.size;
        for j in (1..=self.log).rev() {
            self.push(i &gt;&gt; j);
        }
        self.data[i] = f.map(&amp;self.data[i]);
        for j in 1..=self.log {
            self.update(i &gt;&gt; j);
        }
    }

    /// Apply a map `f` to the element in an interval [l, r).
    fn apply_range(&amp;mut self, l: usize, r: usize, f: &amp;F) {
        if l == r {
            return;
        }

        let (mut l, mut r) = (l + self.size, r + self.size);

        for i in (1..=self.log).rev() {
            if ((l &gt;&gt; i) &lt;&lt; i) != l {
                self.push(l &gt;&gt; i);
            }
            if ((r &gt;&gt; i) &lt;&lt; i) != r {
                self.push((r - 1) &gt;&gt; i);
            }
        }

        let (l2, r2) = (l, r);
        while l &lt; r {
            if l &amp; 1 == 1 {
                self.all_apply(l, f);
                l += 1;
            }
            if r &amp; 1 == 1 {
                r -= 1;
                self.all_apply(r, f);
            }
            l &gt;&gt;= 1;
            r &gt;&gt;= 1;
        }
        l = l2;
        r = r2;

        for i in 1..=self.log {
            if ((l &gt;&gt; i) &lt;&lt; i) != l {
                self.update(l &gt;&gt; i);
            }
            if ((r &gt;&gt; i) &lt;&lt; i) != r {
                self.update((r - 1) &gt;&gt; i);
            }
        }
    }
    
    fn max_right&lt;C: Fn(&amp;S) -&gt; bool&gt;(&amp;mut self, l: usize, g: C) -&gt; usize {
        if l == self.n {
            return self.n;
        }

        let mut l = l + self.size;
        for i in (1..=self.log).rev() {
            self.push(l &gt;&gt; i);
        }

        let mut sm = S::e();
        loop {
            while l &amp; 1 == 0 {
                l &gt;&gt;= 1;
            }
            if !g(&amp;sm.opr(&amp;self.data[l])) {
                while l &lt; self.size {
                    self.push(l);
                    l &lt;&lt;= 1;
                    if g(&amp;sm.opr(&amp;self.data[l])) {
                        sm = sm.opr(&amp;self.data[l]);
                        l += 1;
                    }
                }
                return l - self.size;
            }
            sm = sm.opr(&amp;self.data[l]);
            l += 1;

            if l &amp; ((!l) + 1) != l {
                break;
            }
        }
        self.n
    }
    
    fn min_left&lt;C: Fn(&amp;S) -&gt; bool&gt;(&amp;mut self, r: usize, g: C) -&gt; usize {
        if r == 0 {
            return 0;
        }

        let mut r = r + self.size;
        for i in (1..=self.log).rev() {
            self.push((r - 1) &gt;&gt; i);
        }

        let mut sm = S::e();
        loop {
            r -= 1;
            while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                r &gt;&gt;= 1;
            }
            if !g(&amp;self.data[r].opr(&amp;sm)) {
                while r &lt; self.size {
                    self.push(r);
                    r = (r &lt;&lt; 1) + 1;
                    if g(&amp;self.data[r].opr(&amp;sm)) {
                        sm = self.data[r].opr(&amp;sm);
                        r -= 1;
                    }
                }
                return r + 1 - self.size;
            }
            sm = self.data[r].opr(&amp;sm);

            if r &amp; ((!r) + 1) == r {
                break;
            }
        }
        0
    }
}
</code></pre>
<h2 id="using-max_right-and-min_left-1"><a class="header" href="#using-max_right-and-min_left-1">Using max_right and min_left</a></h2>
<h3 id="max_right-1"><a class="header" href="#max_right-1">max_right</a></h3>
<p>Given an index \(l\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(r=l\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(r=n\) or \( f \left( A_l \cdot A_{l+1} \cdots A_r \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the maximum \(r\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq l \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(r\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<h3 id="min_left-1"><a class="header" href="#min_left-1">min_left</a></h3>
<p>Given an index \(r\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(l=r\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(l=0\) or \( f \left( A_{l-1} \cdot A_l \cdots A_{r-1} \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the minimum \(l\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq r \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(l\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<h2 id="examples-of-monoid-and-mapping-implementation"><a class="header" href="#examples-of-monoid-and-mapping-implementation">Examples of monoid and mapping implementation</a></h2>
<h3 id="axb-lazy-segment-tree"><a class="header" href="#axb-lazy-segment-tree">\(ax+b\) lazy segment tree</a></h3>
<pre><code class="language-rust noplayground">#[derive(Clone)]
struct Elm {
    len: i128,
    sum: i128,
}

impl Monoid for Elm {
    fn opr(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            len: self.len + other.len,
            sum: self.sum + other.sum,
        }
    }
    fn e() -&gt; Self {
        Self { len: 0, sum: 0 }
    }
}

#[derive(Clone)]
struct Map {
    mul: i128,
    add: i128,
}

impl Mapping&lt;Elm&gt; for Map {
    fn map(&amp;self, apply: &amp;Elm) -&gt; Elm {
        Elm {
            len: apply.len,
            sum: self.mul * apply.sum + self.add * apply.len,
        }
    }
    fn compos(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            mul: self.mul * other.mul,
            add: self.mul * other.add + self.add,
        }
    }
    fn id() -&gt; Self {
        Self { mul: 1, add: 0 }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adjacency-list-graph-representation"><a class="header" href="#adjacency-list-graph-representation">Adjacency List Graph Representation</a></h1>
<p>Credits to kiwiyou</p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Graph&lt;T&gt; {
    n: usize,
    first: Vec&lt;usize&gt;,
    edge: Vec&lt;(usize, usize, T)&gt;, // (to, prev, data)
}

impl&lt;T&gt; Graph&lt;T&gt; {
    fn new(n: usize, e: usize) -&gt; Self {
        Self {
            n,
            first: vec![usize::MAX; n],
            edge: Vec::with_capacity(e),
        }
    }

    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len());
        self.edge.push((to, prev, data));
    }

    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
        Neighbor {
            graph: self,
            next_edge: self.first[of],
        }
    }
}

struct Neighbor&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    next_edge: usize,
}

impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
    type Item = (usize, &amp;'g T);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (to, next_edge, data) = self.graph.edge.get(self.next_edge)?;
        self.next_edge = *next_edge;
        Some((*to, data))
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disjoint-set-union"><a class="header" href="#disjoint-set-union">Disjoint Set Union</a></h1>
<p>Disjoint set union (a.k.a Union-Find) processes the following queries on a graph with \(n\) nodes without any edges:</p>
<ul>
<li>Add an undirected edge between two nodes (<code>union</code>)</li>
<li>Determine if there exist a path between two nodes (<code>is_reachable</code>)</li>
</ul>
<pre><code class="language-rust noplayground">struct UnionFind {
    size: usize,
    parents: Vec&lt;usize&gt;,
    group_size: Vec&lt;usize&gt;,
    group_num: usize,
}

impl UnionFind {
    /// Returns a new UnionFind instance where `size` number of elements are in their own disjoint set.
    fn new(size: usize) -&gt; Self {
        Self {
            size,
            parents: vec![size; size],
            group_size: vec![1; size],
            group_num: size,
        }
    }

    /// Returns the number of nodes which can be reached from x.
    fn get_group_size(&amp;mut self, x: usize) -&gt; usize {
        let root = self.find_root(x);
        self.group_size[root]
    }

    /// Returns the number of connected components.
    fn get_group_num(&amp;self) -&gt; usize {
        self.group_num
    }

    fn find_root(&amp;mut self, x: usize) -&gt; usize {
        if self.parents[x] == self.size {
            return x;
        }
        let root = self.find_root(self.parents[x]);
        self.parents[x] = root;
        root
    }

    /// Returns true if there exists a path from a to b.
    fn is_reachable(&amp;mut self, a: usize, b: usize) -&gt; bool {
        self.find_root(a) == self.find_root(b)
    }

    /// Add an edge between a and b.
    fn union(&amp;mut self, a: usize, b: usize) {
        let a_root = self.find_root(a);
        let b_root = self.find_root(b);

        if a_root != b_root {
            self.group_num -= 1;
            let a_size = self.group_size[a_root];
            let b_size = self.group_size[b_root];
            if a_size &lt; b_size {
                self.parents[a_root] = b_root;
                self.group_size[b_root] += a_size;
            } else {
                self.parents[b_root] = a_root;
                self.group_size[a_root] += b_size;
            }
        }
    }
}
</code></pre>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-rust noplayground">let mut uf = UnionFind::new(10);
assert_eq!(uf.is_reachable(2, 6), false);
uf.union(2, 6);
assert_eq!(uf.is_reachable(2, 6), true);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strongly-connected-components"><a class="header" href="#strongly-connected-components">Strongly Connected Components</a></h1>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Graph&lt;T&gt; {
    n: usize,
    first: Vec&lt;usize&gt;,
    edge: Vec&lt;(usize, usize, T)&gt;, // (to, prev, data)
}

impl&lt;T&gt; Graph&lt;T&gt; {
    fn new(n: usize, e: usize) -&gt; Self {
        Self {
            n,
            first: vec![usize::MAX; n],
            edge: Vec::with_capacity(e),
        }
    }

    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len());
        self.edge.push((to, prev, data));
    }

    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
        Neighbor {
            graph: self,
            next_edge: self.first[of],
        }
    }
}

struct Neighbor&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    next_edge: usize,
}

impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
    type Item = (usize, &amp;'g T);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (to, next_edge, data) = self.graph.edge.get(self.next_edge)?;
        self.next_edge = *next_edge;
        Some((*to, data))
    }
}

struct SccStack {
    stack: Vec&lt;usize&gt;,
    check: Vec&lt;bool&gt;,
}

impl SccStack {
    fn new(cap: usize) -&gt; Self {
        Self {
            stack: vec![0; cap],
            check: vec![false; cap],
        }
    }

    fn len(&amp;self) -&gt; usize {
        self.stack.len()
    }

    fn push(&amp;mut self, n: usize) {
        self.stack.push(n);
        self.check[n] = true;
    }

    fn get(&amp;self) -&gt; usize {
        self.stack[self.len() - 1]
    }

    fn pop(&amp;mut self) -&gt; usize {
        let tmp = self.stack.pop().unwrap();
        self.check[tmp] = false;
        tmp
    }

    fn is_in(&amp;self, n: usize) -&gt; bool {
        self.check[n]
    }
}

struct SCC&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    scc_list: Vec&lt;Vec&lt;usize&gt;&gt;,
    scc_ids: Vec&lt;usize&gt;,
}

impl&lt;'g, T: 'g&gt; SCC&lt;'g, T&gt; {
    fn new(graph: &amp;'g Graph&lt;T&gt;) -&gt; Self {
        let mut st = SccStack::new(graph.n);
        let mut list: Vec&lt;Vec&lt;usize&gt;&gt; = Vec::new();
        let mut gid: usize = 0;
        let mut id = vec![graph.n; graph.n];
        let mut low = vec![usize::MAX; graph.n];

        for x in 0..graph.n {
            if id[x] != graph.n {
                continue;
            }
            Self::dfs(graph, x, &amp;mut gid, &amp;mut id, &amp;mut low, &amp;mut st, &amp;mut list)
        }
        list.reverse();

        let mut ids = vec![0; graph.n];
        for (i, l) in list.iter().enumerate() {
            for v in l.iter() {
                ids[*v] = i;
            }
        }

        Self {
            graph,
            scc_list: list,
            scc_ids: ids,
        }
    }

    fn dfs(
        graph: &amp;Graph&lt;T&gt;,
        curr: usize,
        gid: &amp;mut usize,
        id: &amp;mut Vec&lt;usize&gt;,
        low: &amp;mut Vec&lt;usize&gt;,
        st: &amp;mut SccStack,
        list: &amp;mut Vec&lt;Vec&lt;usize&gt;&gt;,
    ) {
        st.push(curr);
        id[curr] = *gid;
        low[curr] = *gid;
        (*gid) += 1;

        for (next, _) in graph.neighbor(curr) {
            if id[next] == graph.n {
                Self::dfs(graph, next, gid, id, low, st, list);
            }
        }

        for (next, _) in graph.neighbor(curr) {
            if st.is_in(next) {
                low[curr] = low[curr].min(low[next]);
            }
        }

        if id[curr] == low[curr] {
            let p = list.len();
            list.push(Vec::new());
            while st.len() != 0 &amp;&amp; st.get() != curr {
                list[p].push(st.pop());
            }
            st.pop();
            list[p].push(curr);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sat"><a class="header" href="#2-sat">2-SAT</a></h1>
<p>Required snippets: <a href="graphs/./scc.html#strongly-connected-components">SCC</a></p>
<pre><code class="language-rust noplayground">struct TwoSat {
    n: usize,
    graph: Graph&lt;()&gt;,
}

impl TwoSat {
    fn new(n: usize, clause_num: usize) -&gt; Self {
        Self {
            n,
            graph: Graph::new(n &lt;&lt; 1, clause_num &lt;&lt; 1),
        }
    }

    fn judge(f: bool, a: usize, b: usize) -&gt; usize {
        if f {
            a
        } else {
            b
        }
    }

    fn add_clause(&amp;mut self, i: usize, f: bool, j: usize, g: bool) {
        self.graph.add_edge(
            (i &lt;&lt; 1) + Self::judge(f, 0, 1),
            (j &lt;&lt; 1) + Self::judge(g, 1, 0),
            (),
        );
        self.graph.add_edge(
            (j &lt;&lt; 1) + Self::judge(g, 0, 1),
            (i &lt;&lt; 1) + Self::judge(f, 1, 0),
            (),
        );
    }

    fn solve(self) -&gt; Option&lt;Vec&lt;bool&gt;&gt; {
        let mut answer = vec![false; self.n];

        let scc = SCC::new(&amp;self.graph);
        let ids = &amp;scc.scc_ids;

        for i in 0..self.n {
            if ids[i &lt;&lt; 1] == ids[(i &lt;&lt; 1) + 1] {
                return None;
            }
            answer[i] = ids[i &lt;&lt; 1] &lt; ids[(i &lt;&lt; 1) + 1];
        }
        Some(answer)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convex-hull"><a class="header" href="#convex-hull">Convex Hull</a></h1>
<h2 id="graham-scan"><a class="header" href="#graham-scan">Graham Scan</a></h2>
<p>This snippet excludes every points on vertices from the convex hull, and only includes points of both ends.</p>
<h3 id="snippet"><a class="header" href="#snippet">Snippet</a></h3>
<pre><code class="language-rust noplayground">use std::cmp::Ordering;

#[derive(Clone, Debug, Eq, PartialEq)]
struct Point {
    x: i64,
    y: i64,
}

impl Point {
    fn add(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
    fn sub(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
enum Turn {
    CW,
    CCW,
    Zero,
}

fn get_turn(v1: &amp;Point, v2: &amp;Point) -&gt; Turn {
    let prod = v1.x * v2.y - v1.y * v2.x;
    if prod &gt; 0 {
        Turn::CCW
    } else if prod &lt; 0 {
        Turn::CW
    } else {
        Turn::Zero
    }
}

fn compare_ccw(a: &amp;Point, b: &amp;Point) -&gt; Ordering {
    if a == b {
        return Ordering::Equal;
    }
    if a.x == 0 &amp;&amp; a.y == 0 {
        return Ordering::Less;
    } else if b.x == 0 &amp;&amp; b.y == 0 {
        return Ordering::Greater;
    }

    let turn = get_turn(a, b);
    if turn == Turn::CCW {
        return Ordering::Less;
    } else if turn == Turn::CW {
        return Ordering::Greater;
    }

    let a_dist = a.x * a.x + a.y * a.y;
    let b_dist = b.x * b.x + b.y * b.y;
    a_dist.cmp(&amp;b_dist)
}

fn convex_hull(arr: &amp;mut [Point]) -&gt; Vec&lt;Point&gt; {
    let pivot = {
        let mut pivot = Point {
            x: i64::MAX,
            y: i64::MAX,
        };
        for v in arr.iter() {
            if pivot.y &gt; v.y || (pivot.y == v.y &amp;&amp; pivot.x &gt; v.x) {
                pivot.x = v.x;
                pivot.y = v.y;
            }
        }
        pivot
    };

    for v in arr.iter_mut() {
        *v = v.sub(&amp;pivot);
    }

    arr.sort_unstable_by(compare_ccw);

    let mut stack = vec![arr[0].clone()];
    let mut i = 1;
    while i &lt; arr.len() {
        if stack.len() == 1 {
            if arr[i] != stack[0] {
                stack.push(arr[i].clone());
            }
            i += 1;
            continue;
        }

        let a = &amp;arr[i];
        let b = &amp;stack[stack.len() - 1];
        let c = &amp;stack[stack.len() - 2];
        match get_turn(&amp;b.sub(c), &amp;a.sub(b)) {
            Turn::CCW =&gt; {
                stack.push(a.clone());
                i += 1;
            }
            Turn::CW =&gt; {
                stack.pop();
            }
            _ =&gt; {
                stack.pop();
                stack.push(a.clone());
                i += 1;
            }
        }
    }

    for v in arr.iter_mut() {
        *v = v.add(&amp;pivot);
    }
    for v in stack.iter_mut() {
        *v = v.add(&amp;pivot);
    }

    stack
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-compression"><a class="header" href="#value-compression">Value Compression</a></h1>
<pre><code class="language-rust noplayground">/// Returns (compressor, reevaluator)
/// compressor[original_value] = compressed_value
/// reevaluator[compressed_value] = original_value
fn compress_value&lt;T: Clone + Ord + Hash&gt;(arr: &amp;Vec&lt;T&gt;) -&gt; (HashMap&lt;T, usize&gt;, Vec&lt;T&gt;) {
    let mut sorted = arr.clone();
    sorted.sort_unstable();

    let mut compressor: HashMap&lt;T, usize&gt; = HashMap::new();
    let mut reevaluator: Vec&lt;T&gt; = Vec::new();

    let mut prev: Option&lt;&amp;T&gt; = None;
    let mut cmpr = 0usize;
    for v in sorted.iter() {
        if let Some(prev) = prev {
            if prev == v {
                continue;
            }
        }
        prev = Some(v);
        compressor.insert(v.clone(), cmpr);
        reevaluator.push(v.clone());
        cmpr += 1;
    }

    (compressor, reevaluator)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-increasing-subsequence"><a class="header" href="#longest-increasing-subsequence">Longest Increasing Subsequence</a></h1>
<h2 id="length"><a class="header" href="#length">Length</a></h2>
<pre><code class="language-rust noplayground">fn lis_len(arr: &amp;[i64]) -&gt; usize {
    let mut table: Vec&lt;i64&gt; = vec![arr[0]];
    for &amp;v in arr[1..].iter() {
        let p = table.partition_point(|&amp;x| x &lt; v);
        if p == table.len() {
            table.push(v);
        } else {
            table[p] = v;
        }
    }
    table.len()
}
</code></pre>
<h2 id="sequence"><a class="header" href="#sequence">Sequence</a></h2>
<pre><code class="language-rust noplayground">fn lis(arr: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
    let n = arr.len();
    let mut seq: Vec&lt;i64&gt; = Vec::with_capacity(n + 1);
    seq.push(i64::MIN);
    seq.extend(arr.iter().copied());

    let mut back = vec![0usize; n + 1];
    let mut table = vec![0usize];

    for (i, &amp;v) in seq.iter().enumerate().skip(1) {
        let p = table.partition_point(|&amp;x| seq[x] &lt; v);
        if p == table.len() {
            table.push(i);
        } else {
            table[p] = i;
        }
        back[i] = table[p - 1];
    }

    let mut ptr = *table.last().unwrap();
    let mut ans: Vec&lt;i64&gt; = Vec::with_capacity(table.len() - 1);
    while ptr != 0 {
        ans.push(seq[ptr]);
        ptr = back[ptr];
    }

    ans.reverse();
    ans
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-template"><a class="header" href="#base-template">Base Template</a></h1>
<h2 id="wo-testcases"><a class="header" href="#wo-testcases">w/o Testcases</a></h2>
<pre><code class="language-rust noplayground">use std::{
    io::*,
    str::{FromStr, SplitWhitespace},
};

fn main() {
    let stdin = std::fs::File::open(&quot;input.txt&quot;).ok().unwrap();
    let mut handle = BufReader::new(stdin);
    // let stdin = stdin();
    // let mut handle = stdin.lock();
    let mut input_str = String::new();
    handle
        .read_to_string(&amp;mut input_str)
        .expect(&quot;Failed to read&quot;);
    let mut scan = Scanner::new(&amp;input_str);
    let stdout = stdout();
    let out = &amp;mut BufWriter::with_capacity(262144, stdout.lock());

    macro_rules! next {
        () =&gt; {
            scan.next()
        };
        ($t:ty) =&gt; {
            scan.next::&lt;$t&gt;()
        };
    }
}

struct Scanner&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; {
    input: I,
}

impl&lt;'a&gt; Scanner&lt;'a, SplitWhitespace&lt;'a&gt;&gt; {
    fn new(s: &amp;'a str) -&gt; Self {
        Self {
            input: s.split_whitespace(),
        }
    }
}

impl&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; Scanner&lt;'a, I&gt; {
    #[inline(always)]
    fn next&lt;T: FromStr&gt;(&amp;mut self) -&gt; T {
        self.input
            .next()
            .expect(&quot;Input has been exhausted&quot;)
            .parse()
            .ok()
            .expect(&quot;Failed to parse&quot;)
    }

    #[inline(always)]
    fn next_option&lt;T: FromStr&gt;(&amp;mut self) -&gt; Option&lt;T&gt; {
        let token = self.input.next();
        match token {
            Some(s) =&gt; s.parse().ok(),
            None =&gt; None,
        }
    }

    #[inline(always)]
    fn next_str(&amp;mut self) -&gt; &amp;'a str {
        self.input.next().expect(&quot;Input has been exhausted&quot;)
    }

    #[inline(always)]
    fn next_str_option(&amp;mut self) -&gt; Option&lt;&amp;'a str&gt; {
        self.input.next()
    }
}
</code></pre>
<h2 id="w-testcases"><a class="header" href="#w-testcases">w/ Testcases</a></h2>
<pre><code class="language-rust noplayground">use std::{
    io::*,
    str::{FromStr, SplitWhitespace},
};

fn main() {
    let stdin = std::fs::File::open(&quot;input.txt&quot;).ok().unwrap();
    let mut handle = BufReader::new(stdin);
    // let stdin = stdin();
    // let mut handle = stdin.lock();
    let mut input_str = String::new();
    handle
        .read_to_string(&amp;mut input_str)
        .expect(&quot;Failed to read&quot;);
    let mut scan = Scanner::new(&amp;input_str);
    let stdout = stdout();
    let out = &amp;mut BufWriter::with_capacity(262144, stdout.lock());

    macro_rules! next {
        () =&gt; {
            scan.next()
        };
        ($t:ty) =&gt; {
            scan.next::&lt;$t&gt;()
        };
    }

    let tc = next!(usize);
    for _ in 0..tc {}
}

struct Scanner&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; {
    input: I,
}

impl&lt;'a&gt; Scanner&lt;'a, SplitWhitespace&lt;'a&gt;&gt; {
    fn new(s: &amp;'a str) -&gt; Self {
        Self {
            input: s.split_whitespace(),
        }
    }
}

impl&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; Scanner&lt;'a, I&gt; {
    #[inline(always)]
    fn next&lt;T: FromStr&gt;(&amp;mut self) -&gt; T {
        self.input
            .next()
            .expect(&quot;Input has been exhausted&quot;)
            .parse()
            .ok()
            .expect(&quot;Failed to parse&quot;)
    }

    #[inline(always)]
    fn next_option&lt;T: FromStr&gt;(&amp;mut self) -&gt; Option&lt;T&gt; {
        let token = self.input.next();
        match token {
            Some(s) =&gt; s.parse().ok(),
            None =&gt; None,
        }
    }

    #[inline(always)]
    fn next_str(&amp;mut self) -&gt; &amp;'a str {
        self.input.next().expect(&quot;Input has been exhausted&quot;)
    }

    #[inline(always)]
    fn next_str_option(&amp;mut self) -&gt; Option&lt;&amp;'a str&gt; {
        self.input.next()
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zeroone-trait"><a class="header" href="#zeroone-trait">Zero/One Trait</a></h1>
<pre><code class="language-rust noplayground">pub trait ZeroOne: Sized + Copy {
    fn zero() -&gt; Self;
    fn one() -&gt; Self;
}

macro_rules! impl_zero_one {
    ($($ty:ty), *) =&gt; {
        $(
            impl ZeroOne for $ty {
                #[inline(always)]
                fn one() -&gt; Self {
                    1
                }
                #[inline(always)]
                fn zero() -&gt; Self {
                    0
                }
            }
        )*
    };
}

impl_zero_one!(isize, i8, i16, i32, i64, i128, usize, u8, u16, u32, u64, u128);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
