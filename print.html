<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js nord_light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Snippets for Competitive Programming</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "nord_dark" : "nord_light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('nord_light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Algebra</li><li class="chapter-item expanded "><a href="algebra/gcd.html"><strong aria-hidden="true">1.</strong> GCD, LCM</a></li><li class="chapter-item expanded "><a href="algebra/extgcd.html"><strong aria-hidden="true">2.</strong> Extended Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="algebra/crt.html"><strong aria-hidden="true">3.</strong> Chinese Remainder Theorem</a></li><li class="chapter-item expanded "><a href="algebra/millerrabin.html"><strong aria-hidden="true">4.</strong> Deterministic Miller-Rabin Primality Test</a></li><li class="chapter-item expanded "><a href="algebra/pollardrho.html"><strong aria-hidden="true">5.</strong> Pollard's Rho Algorithm</a></li><li class="chapter-item expanded affix "><li class="part-title">Numerical Algorithms</li><li class="chapter-item expanded "><a href="numerical/isqrt.html"><strong aria-hidden="true">6.</strong> Integer Square Root</a></li><li class="chapter-item expanded "><a href="numerical/linrec/intro.html"><strong aria-hidden="true">7.</strong> Linear Recurrence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="numerical/linrec/berlekamp.html"><strong aria-hidden="true">7.1.</strong> Berlekamp-Massey</a></li><li class="chapter-item expanded "><a href="numerical/linrec/kitamasa.html"><strong aria-hidden="true">7.2.</strong> Kitamasa</a></li><li class="chapter-item expanded "><a href="numerical/linrec/bostanmori.html"><strong aria-hidden="true">7.3.</strong> Bostan-Mori</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Data Structures</li><li class="chapter-item expanded "><a href="datastructure/matrix.html"><strong aria-hidden="true">8.</strong> Fast n-dimensional Array</a></li><li class="chapter-item expanded "><a href="datastructure/bitarray.html"><strong aria-hidden="true">9.</strong> Bitset</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/intro.html"><strong aria-hidden="true">10.</strong> Segment Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datastructure/segtree/segtree.html"><strong aria-hidden="true">10.1.</strong> Segment Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/fenwick.html"><strong aria-hidden="true">10.2.</strong> Fenwick Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/lazyseg.html"><strong aria-hidden="true">10.3.</strong> Lazy Segment Tree</a></li></ol></li><li class="chapter-item expanded "><a href="datastructure/rope.html"><strong aria-hidden="true">11.</strong> Rope</a></li><li class="chapter-item expanded affix "><li class="part-title">Graphs</li><li class="chapter-item expanded "><a href="graphs/adjlist.html"><strong aria-hidden="true">12.</strong> Adjacency List Graph Representation</a></li><li class="chapter-item expanded "><a href="graphs/dijkstra.html"><strong aria-hidden="true">13.</strong> Dijkstra</a></li><li class="chapter-item expanded "><a href="graphs/dsu.html"><strong aria-hidden="true">14.</strong> Disjoint Set Union</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphs/wdsu.html"><strong aria-hidden="true">14.1.</strong> Weighted DSU</a></li></ol></li><li class="chapter-item expanded "><a href="graphs/scc.html"><strong aria-hidden="true">15.</strong> Strongly Connected Components</a></li><li class="chapter-item expanded "><a href="graphs/2sat.html"><strong aria-hidden="true">16.</strong> 2-SAT</a></li><li class="chapter-item expanded affix "><li class="part-title">Strings</li><li class="chapter-item expanded "><a href="strings/kmp.html"><strong aria-hidden="true">17.</strong> KMP</a></li><li class="chapter-item expanded "><a href="strings/manacher.html"><strong aria-hidden="true">18.</strong> Manacher</a></li><li class="chapter-item expanded "><a href="strings/salcp.html"><strong aria-hidden="true">19.</strong> Suffix Array and LCP Array</a></li><li class="chapter-item expanded affix "><li class="part-title">Geometry</li><li class="chapter-item expanded "><a href="geometry/convexhull.html"><strong aria-hidden="true">20.</strong> Convex Hull</a></li><li class="chapter-item expanded affix "><li class="part-title">Unclassified</li><li class="chapter-item expanded "><a href="unclass/valcomp.html"><strong aria-hidden="true">21.</strong> Value Compression</a></li><li class="chapter-item expanded "><a href="unclass/lis.html"><strong aria-hidden="true">22.</strong> Longest Increasing Subsequence</a></li><li class="chapter-item expanded "><a href="unclass/mos.html"><strong aria-hidden="true">23.</strong> Mo's</a></li><li class="chapter-item expanded "><a href="unclass/bigint.html"><strong aria-hidden="true">24.</strong> Arbitrary-Precision Integer</a></li><li class="chapter-item expanded affix "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="misc/fastio.html"><strong aria-hidden="true">25.</strong> Fast IO</a></li><li class="chapter-item expanded "><a href="misc/macro.html"><strong aria-hidden="true">26.</strong> Macros</a></li><li class="chapter-item expanded "><a href="misc/zero_one_trait.html"><strong aria-hidden="true">27.</strong> Zero/One Trait (Deprecated)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="nord_light">Nord Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="nord_dark">Nord Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Snippets for Competitive Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BamgoeSN/rust-ps-md" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is a collection of snippets for competitive programming and problem solving with Rust. All you have to do for using snippets is simply copying snippets you need and pasting them into your code.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Each snippet can be easily copied by clicking on the copy icon <i class="fa fa-copy"></i> at the top right corner of a code block.</p>
<p>Clicking on the search icon <i class="fa fa-search"></i> in the menu bar, or pressing the <code>S</code> key on the keyboard will open an input box for entering search terms. Any keywords included in this book can be searched by typing it in the box.</p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other Resources</a></h2>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<ul>
<li><a href="https://blog.shahjalalshohag.com/topic-list/">The Ultimate Topic List by Shahjalal Shohag</a></li>
</ul>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<ul>
<li><a href="https://github.com/EbTech/rust-algorithms">Contest Algorithms in Rust by EbTech</a></li>
<li><a href="https://snippets.kiwiyou.dev/">kiwiyou's Snippets Collection</a></li>
</ul>
<h3 id="c"><a class="header" href="#c">C++</a></h3>
<ul>
<li><a href="https://github.com/Aeren1564/Algorithms">aeren1564 Bible</a></li>
<li>AtCoder Library: <a href="https://atcoder.github.io/ac-library/production/document_en/">Doc</a>, <a href="https://github.com/atcoder/ac-library">GitHub</a></li>
<li><a href="https://github.com/koosaga/olympiad/tree/master/Library">koosaga's Library</a></li>
<li><a href="https://github.com/justiceHui/icpc-teamnote">justiceHui's Teamnote</a></li>
</ul>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<ul>
<li><a href="https://github.com/cheran-senthil/PyRival">PyRival</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcd-lcm"><a class="header" href="#gcd-lcm">GCD, LCM</a></h1>
<p><code>gcd(x, y)</code> returns the greatest common divisor (GCD) of <code>x</code> and <code>y</code>. <br />
<code>lcm(x, y)</code> returns the least common multiple (LCM) of <code>x</code> and <code>y</code>.</p>
<p><code>gcd</code> is implemented using Euclidean algorithm, whose time complexity is \(O( \log _{\phi} x )\) where \(\phi\) is a golden ratio.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let (x, y) = (10, 25);

let g = gcd(x, y);
println!(&quot;{}&quot;, g); // 5

let l = lcm(x, y);
println!(&quot;{}&quot;, l); // 50
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gcd(x: u64, y: u64) -&gt; u64 {
</span><span class="boring">   if y == 0 {
</span><span class="boring">       x
</span><span class="boring">   } else {
</span><span class="boring">       gcd(y, x % y)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn lcm(x: u64, y: u64) -&gt; u64 {
</span><span class="boring">   x / gcd(x, y) * y
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-rust noplayground">fn gcd(x: u64, y: u64) -&gt; u64 {
    if y == 0 {
        x
    } else {
        gcd(y, x % y)
    }
}

fn lcm(x: u64, y: u64) -&gt; u64 {
    x / gcd(x, y) * y
}</code></pre>
<h2 id="generic-version"><a class="header" href="#generic-version">Generic Version</a></h2>
<p>The function below works for any primitive unsigned integer types.</p>
<pre><code class="language-rust noplayground">pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy + PartialEq + PartialOrd + std::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
{
    if y == 0.into() {
        x
    } else {
        let v = x % y;
        gcd(y, v)
    }
}

pub fn lcm&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy
        + PartialEq
        + PartialOrd
        + std::ops::Rem&lt;Output = T&gt;
        + std::ops::Div&lt;Output = T&gt;
        + std::ops::Mul&lt;Output = T&gt;
        + From&lt;u8&gt;,
{
    x / gcd(x, y) * y
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extended-euclidean-algorithm"><a class="header" href="#extended-euclidean-algorithm">Extended Euclidean Algorithm</a></h1>
<p><code>ext_gcd(a, b)</code> returns \(g, s, t\) such that \(g = \gcd(a, b)\) and \(as+bt=g\).</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let (a, b) = (4, 11);
let (g, s, t) = ext_gcd(a, b);
println!(&quot;{} {} {}&quot;, g, s, t); // 1 3 -1
println!(&quot;{} == {}&quot;, g, a * s + b * t);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Extended Euclidean Algorithm
</span><span class="boring">// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/gcd.py
</span><span class="boring">
</span><span class="boring">fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
</span><span class="boring">    let (mut s, mut old_s) = (0, 1);
</span><span class="boring">    let (mut g, mut old_g) = (b, a);
</span><span class="boring">    while g != 0 {
</span><span class="boring">        let q = old_g / g;
</span><span class="boring">        let (new_r, new_s) = (old_g - q * g, old_s - q * s);
</span><span class="boring">        old_g = g; // Not using destructuring to support low version
</span><span class="boring">        g = new_r; // AtCoder is using 1.42.0
</span><span class="boring">        old_s = s;
</span><span class="boring">        s = new_s;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    (
</span><span class="boring">        old_g,
</span><span class="boring">        old_s,
</span><span class="boring">        if b != 0 { (old_g - old_s * a) / b } else { 0 },
</span><span class="boring">    )
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<pre><code class="language-rust noplayground">// Extended Euclidean Algorithm
// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/gcd.py

fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut g, mut old_g) = (b, a);
    while g != 0 {
        let q = old_g / g;
        let (new_r, new_s) = (old_g - q * g, old_s - q * s);
        old_g = g; // Not using destructuring to support low version
        g = new_r; // AtCoder is using 1.42.0
        old_s = s;
        s = new_s;
    }

    (
        old_g,
        old_s,
        if b != 0 { (old_g - old_s * a) / b } else { 0 },
    )
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chinese-remainder-theorem"><a class="header" href="#chinese-remainder-theorem">Chinese Remainder Theorem</a></h1>
<p><code>crt(r, m)</code> returns <code>Some(x)</code> such that \(x \equiv r_i \pmod {m_i}\) for all \(i\). If such \(x\) does not exist, then it returns <code>None</code>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let r: Vec&lt;i64&gt; = vec![1, 2, 3];
let m: Vec&lt;i64&gt; = vec![3, 5, 7];
let x = crt(&amp;r, &amp;m);
println!(&quot;{:?}&quot;, x); // Some(52)

let r: Vec&lt;i64&gt; = vec![2, 5];
let m: Vec&lt;i64&gt; = vec![10, 25];
let x = crt(&amp;r, &amp;m);
println!(&quot;{:?}&quot;, x); // None
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Chinese remainder theorem
</span><span class="boring">// Reference: PyRival &lt;https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py&gt;
</span><span class="boring">
</span><span class="boring">fn gcd(x: i64, y: i64) -&gt; i64 {
</span><span class="boring">    if y == 0 {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        gcd(y, x % y)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns gcd(a, b), s, r s.t. a*s + b*r = gcd(a, b)
</span><span class="boring">#[inline(always)]
</span><span class="boring">fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
</span><span class="boring">    let (mut s, mut old_s) = (0, 1);
</span><span class="boring">    let (mut r, mut old_r) = (b, a);
</span><span class="boring">    while r != 0 {
</span><span class="boring">        let q = old_r / r;
</span><span class="boring">        let (new_r, new_s) = (old_r - q * r, old_s - q * s);
</span><span class="boring">        old_r = r; // Not using destructuring to support low version
</span><span class="boring">        r = new_r; // AtCoder is using 1.42.0
</span><span class="boring">        old_s = s;
</span><span class="boring">        s = new_s;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    (
</span><span class="boring">        old_r,
</span><span class="boring">        old_s,
</span><span class="boring">        if b != 0 { (old_r - old_s * a) / b } else { 0 },
</span><span class="boring">    )
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns $x$ s.t. $x=r_i (mod m_i)$ for all $i$
</span><span class="boring">fn crt(r: &amp;[i64], m: &amp;[i64]) -&gt; Option&lt;i64&gt; {
</span><span class="boring">    let (mut x, mut m_prod) = (0, 1);
</span><span class="boring">    for (bi, mi) in r.iter().zip(m.iter()) {
</span><span class="boring">        let (g, s, _) = ext_gcd(m_prod, *mi);
</span><span class="boring">        if ((bi - x) % mi).rem_euclid(g) != 0 {
</span><span class="boring">            return None;
</span><span class="boring">        }
</span><span class="boring">        x += m_prod * ((s * ((bi - x).rem_euclid(*mi))).div_euclid(g));
</span><span class="boring">        m_prod = (m_prod * mi).div_euclid(gcd(m_prod, *mi));
</span><span class="boring">    }
</span><span class="boring">    Some(x.rem_euclid(m_prod))
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-2"><a class="header" href="#code-2">Code</a></h2>
<pre><code class="language-rust noplayground">// Chinese remainder theorem
// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py

fn gcd(x: i64, y: i64) -&gt; i64 {
    if y == 0 {
        x
    } else {
        gcd(y, x % y)
    }
}

/// Returns gcd(a, b), s, t s.t. a*s + b*t = gcd(a, b)
#[inline(always)]
fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut r, mut old_r) = (b, a);
    while r != 0 {
        let q = old_r / r;
        let (new_r, new_s) = (old_r - q * r, old_s - q * s);
        old_r = r; // Not using destructuring to support low version
        r = new_r; // AtCoder is using 1.42.0
        old_s = s;
        s = new_s;
    }

    (
        old_r,
        old_s,
        if b != 0 { (old_r - old_s * a) / b } else { 0 },
    )
}

/// Returns x s.t. x=r_i (mod m_i) for all i
fn crt(r: &amp;[i64], m: &amp;[i64]) -&gt; Option&lt;i64&gt; {
    let (mut x, mut m_prod) = (0, 1);
    for (bi, mi) in r.iter().zip(m.iter()) {
        let (g, s, _) = ext_gcd(m_prod, *mi);
        if ((bi - x) % mi).rem_euclid(g) != 0 {
            return None;
        }
        x += m_prod * ((s * ((bi - x).rem_euclid(*mi))).div_euclid(g));
        m_prod = (m_prod * mi).div_euclid(gcd(m_prod, *mi));
    }
    Some(x.rem_euclid(m_prod))
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deterministic-miller-rabin-primality-test"><a class="header" href="#deterministic-miller-rabin-primality-test">Deterministic Miller-Rabin Primality Test</a></h1>
<p>Deterministic Miller-Rabin primality test determines whether a certain unsigned integer is a prime in a time complexity of \(O(\log{n})\). This test only works for integers under \(2^{64}\).</p>
<p><code>x.is_prime()</code> chooses a roughly faster algorithm among naive primality test and Miller-Rabin test, and returns <code>true</code> if <code>x</code> is a prime, <code>false</code> if not.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, 3284729387909u64.is_prime()); // true
println!(&quot;{}&quot;, 3284729387911u64.is_prime()); // false 53×61976026187
<span class="boring">}
</span><span class="boring">
</span><span class="boring">trait MillerRabin: From&lt;u8&gt; + PartialOrd {
</span><span class="boring">    const MR_THRES: Self;
</span><span class="boring">    fn naive_primality(self) -&gt; bool;
</span><span class="boring">    fn miller_rabin_test(self, a: Self) -&gt; bool;
</span><span class="boring">    fn miller_primality(self) -&gt; bool;
</span><span class="boring">    fn is_prime(self) -&gt; bool {
</span><span class="boring">        if self &lt;= 1.into() {
</span><span class="boring">            false
</span><span class="boring">        } else if self &lt;= Self::MR_THRES {
</span><span class="boring">            self.naive_primality()
</span><span class="boring">        } else {
</span><span class="boring">            self.miller_primality()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! impl_millerrabin {
</span><span class="boring">    ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
</span><span class="boring">        impl MillerRabin for $t {
</span><span class="boring">            const MR_THRES: Self = $thres;
</span><span class="boring">
</span><span class="boring">            #[inline(always)]
</span><span class="boring">            fn naive_primality(self) -&gt; bool {
</span><span class="boring">                for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
</span><span class="boring">                    if self % i == 0 {
</span><span class="boring">                        return false;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                true
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">               #[inline(always)]
</span><span class="boring">               fn miller_rabin_test(self, a: Self) -&gt; bool {
</span><span class="boring">                   let d = self - 1;
</span><span class="boring">                   let mut p = d &gt;&gt; (d.trailing_zeros());
</span><span class="boring">
</span><span class="boring">                   let mut t = {
</span><span class="boring">                       let mut base = a as $u;
</span><span class="boring">                       let mut exp = p as $u;
</span><span class="boring">                       let rem = self as $u;
</span><span class="boring">                       let mut ret: $u = 1;
</span><span class="boring">                       while exp != 0 {
</span><span class="boring">                           if exp &amp; 1 != 0 {
</span><span class="boring">                               ret = ret * base % rem;
</span><span class="boring">                           }
</span><span class="boring">                           base = base*base%rem;
</span><span class="boring">                           exp &gt;&gt;= 1;
</span><span class="boring">                       }
</span><span class="boring">                       ret as $t
</span><span class="boring">                   };
</span><span class="boring">
</span><span class="boring">                   let at_last = t == d || t == 1;
</span><span class="boring">
</span><span class="boring">                   while p != d {
</span><span class="boring">                       p &lt;&lt;= 1;
</span><span class="boring">                       t = ((t as $u * t as $u) % self as $u) as $t;
</span><span class="boring">                       if t == self - 1 {
</span><span class="boring">                           return true;
</span><span class="boring">                       }
</span><span class="boring">                   }
</span><span class="boring">                   at_last
</span><span class="boring">               }
</span><span class="boring">
</span><span class="boring">            fn miller_primality(self) -&gt; bool {
</span><span class="boring">                $(
</span><span class="boring">                    if !self.miller_rabin_test($x) {
</span><span class="boring">                        return false;
</span><span class="boring">                    }
</span><span class="boring">                )*
</span><span class="boring">                true
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl_millerrabin!(u8, u16, 254, 2);
</span><span class="boring">impl_millerrabin!(u16, u32, 2000, 2, 3);
</span><span class="boring">impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
</span><span class="boring">impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);</span></code></pre></pre>
<h2 id="code-3"><a class="header" href="#code-3">Code</a></h2>
<pre><code class="language-rust noplayground">trait MillerRabin: From&lt;u8&gt; + PartialOrd {
    const MR_THRES: Self;
    fn naive_primality(self) -&gt; bool;
    fn miller_rabin_test(self, a: Self) -&gt; bool;
    fn miller_primality(self) -&gt; bool;
    fn is_prime(self) -&gt; bool {
        if self &lt;= 1.into() {
            false
        } else if self &lt;= Self::MR_THRES {
            self.naive_primality()
        } else {
            self.miller_primality()
        }
    }
}

macro_rules! impl_millerrabin {
        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
            impl MillerRabin for $t {
                const MR_THRES: Self = $thres;

                #[inline(always)]
                fn naive_primality(self) -&gt; bool {
                    for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
                        if self % i == 0 {
                            return false;
                        }
                    }
                    true
                }

                #[inline(always)]
                fn miller_rabin_test(self, a: Self) -&gt; bool {
                    let d = self - 1;
                    let mut p = d &gt;&gt; (d.trailing_zeros());

                    let mut t = {
                        let mut base = a as $u;
                        let mut exp = p as $u;
                        let rem = self as $u;
                        let mut ret: $u = 1;
                        while exp != 0 {
                            if exp &amp; 1 != 0 {
                                ret = ret * base % rem;
                            }
                            base = base*base%rem;
                            exp &gt;&gt;= 1;
                        }
                        ret as $t
                    };

                    let at_last = t == d || t == 1;

                    while p != d {
                        p &lt;&lt;= 1;
                        t = ((t as $u * t as $u) % self as $u) as $t;
                        if t == self - 1 {
                            return true;
                        }
                    }
                    at_last
                }

                fn miller_primality(self) -&gt; bool {
                    $(
                        if !self.miller_rabin_test($x) {
                            return false;
                        }
                    )*
                    true
                }
            }
        };
    }

impl_millerrabin!(u8, u16, 254, 2);
impl_millerrabin!(u16, u32, 2000, 2, 3);
impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pollards-rho-algorithm"><a class="header" href="#pollards-rho-algorithm">Pollard's Rho Algorithm</a></h1>
<p>Pollard rho algorithm is a randomized algorithm which factorizes a number in an average time complexity of \(O(n^{1/4})\).</p>
<p><code>x.factorize()</code> factorizes <code>x</code> and returns a vector with the factors. The order of factors in the vector is undefined.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut rng = rng::RNG::new(15163487);
let a: u32 = 1237172;
let mut factors = a.factorize(&amp;mut rng);
factors.sort_unstable();
println!(&quot;{:?}&quot;, factors); // [2, 2, 309293]
println!(&quot;{}&quot;, factors.iter().product::&lt;u32&gt;()); // 1237172
<span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PollardRho: MillerRabin + std::ops::ShrAssign + std::ops::BitAnd&lt;Output = Self&gt; + Clone {
</span><span class="boring">    fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG);
</span><span class="boring">    fn factorize(mut self, rng: &amp;mut rng::RNG) -&gt; Vec&lt;Self&gt; {
</span><span class="boring">        let mut arr: Vec&lt;Self&gt; = Vec::new();
</span><span class="boring">        if self &lt;= 1.into() {
</span><span class="boring">            return arr;
</span><span class="boring">        }
</span><span class="boring">        while self.clone() &amp; 1.into() == 0.into() {
</span><span class="boring">            self &gt;&gt;= 1.into();
</span><span class="boring">            arr.push(2.into());
</span><span class="boring">        }
</span><span class="boring">        self.rho(&amp;mut arr, rng);
</span><span class="boring">        arr
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! impl_pollardrho {
</span><span class="boring">    ($t:ty, $u:ty, $reset:expr) =&gt; {
</span><span class="boring">        impl PollardRho for $t {
</span><span class="boring">            fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG) {
</span><span class="boring">                if self &lt;= 1 {
</span><span class="boring">                    return;
</span><span class="boring">                } else if self.is_prime() {
</span><span class="boring">                    arr.push(self);
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                let mut i: u64 = 0;
</span><span class="boring">                let mut x: $t = (rng.next_u64() % self as u64) as $t;
</span><span class="boring">                let mut y: $t = x;
</span><span class="boring">                let mut k: u64 = 2;
</span><span class="boring">                let mut d: $t;
</span><span class="boring">                let mut reset_limit: u64 = $reset;
</span><span class="boring">
</span><span class="boring">                loop {
</span><span class="boring">                    i += 1;
</span><span class="boring">                    x = (((x as $u * x as $u % self as $u) + (self - 1) as $u) % self as $u) as $t;
</span><span class="boring">                    d = gcd(y.abs_diff(x), self);
</span><span class="boring">                    if d == self || i &gt;= reset_limit {
</span><span class="boring">                        // Reset
</span><span class="boring">                        reset_limit = reset_limit * 3 / 2;
</span><span class="boring">                        i = 0;
</span><span class="boring">                        x = (rng.next_u64() % self as u64) as $t;
</span><span class="boring">                        y = x;
</span><span class="boring">                    }
</span><span class="boring">                    if d != 1 {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                    if i == k {
</span><span class="boring">                        y = x;
</span><span class="boring">                        k &lt;&lt;= 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                if d != self {
</span><span class="boring">                    d.rho(arr, rng);
</span><span class="boring">                    (self / d).rho(arr, rng);
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                let mut i = 3;
</span><span class="boring">                while i * i &lt;= self {
</span><span class="boring">                    if self % i == 0 {
</span><span class="boring">                        i.rho(arr, rng);
</span><span class="boring">                        (d / i).rho(arr, rng);
</span><span class="boring">                        return;
</span><span class="boring">                    }
</span><span class="boring">                    i += 2;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl_pollardrho!(u8, u16, 100000);
</span><span class="boring">impl_pollardrho!(u16, u32, 100000);
</span><span class="boring">impl_pollardrho!(u32, u64, 100000);
</span><span class="boring">impl_pollardrho!(u64, u128, 100000);
</span><span class="boring">
</span><span class="boring">trait MillerRabin: From&lt;u8&gt; + PartialOrd {
</span><span class="boring">    const MR_THRES: Self;
</span><span class="boring">    fn naive_primality(self) -&gt; bool;
</span><span class="boring">    fn miller_rabin_test(self, a: Self) -&gt; bool;
</span><span class="boring">    fn miller_primality(self) -&gt; bool;
</span><span class="boring">    fn is_prime(self) -&gt; bool {
</span><span class="boring">        if self &lt;= 1.into() {
</span><span class="boring">            false
</span><span class="boring">        } else if self &lt;= Self::MR_THRES {
</span><span class="boring">            self.naive_primality()
</span><span class="boring">        } else {
</span><span class="boring">            self.miller_primality()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! impl_millerrabin {
</span><span class="boring">        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
</span><span class="boring">            impl MillerRabin for $t {
</span><span class="boring">                const MR_THRES: Self = $thres;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn naive_primality(self) -&gt; bool {
</span><span class="boring">                    for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
</span><span class="boring">                        if self % i == 0 {
</span><span class="boring">                            return false;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    true
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn miller_rabin_test(self, a: Self) -&gt; bool {
</span><span class="boring">                    let d = self - 1;
</span><span class="boring">                    let mut p = d &gt;&gt; (d.trailing_zeros());
</span><span class="boring">
</span><span class="boring">                    let mut t = {
</span><span class="boring">                        let mut base = a as $u;
</span><span class="boring">                        let mut exp = p as $u;
</span><span class="boring">                        let rem = self as $u;
</span><span class="boring">                        let mut ret: $u = 1;
</span><span class="boring">                        while exp != 0 {
</span><span class="boring">                            if exp &amp; 1 != 0 {
</span><span class="boring">                                ret = ret * base % rem;
</span><span class="boring">                            }
</span><span class="boring">                            base = base*base%rem;
</span><span class="boring">                            exp &gt;&gt;= 1;
</span><span class="boring">                        }
</span><span class="boring">                        ret as $t
</span><span class="boring">                    };
</span><span class="boring">
</span><span class="boring">                    let at_last = t == d || t == 1;
</span><span class="boring">
</span><span class="boring">                    while p != d {
</span><span class="boring">                        p &lt;&lt;= 1;
</span><span class="boring">                        t = ((t as $u * t as $u) % self as $u) as $t;
</span><span class="boring">                        if t == self - 1 {
</span><span class="boring">                            return true;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    at_last
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                fn miller_primality(self) -&gt; bool {
</span><span class="boring">                    $(
</span><span class="boring">                        if !self.miller_rabin_test($x) {
</span><span class="boring">                            return false;
</span><span class="boring">                        }
</span><span class="boring">                    )*
</span><span class="boring">                    true
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl_millerrabin!(u8, u16, 254, 2);
</span><span class="boring">impl_millerrabin!(u16, u32, 2000, 2, 3);
</span><span class="boring">impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
</span><span class="boring">impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
</span><span class="boring">
</span><span class="boring">pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
</span><span class="boring">where
</span><span class="boring">    T: Copy + PartialEq + PartialOrd + std::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
</span><span class="boring">{
</span><span class="boring">    if y == 0.into() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        let v = x % y;
</span><span class="boring">        gcd(y, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod rng {
</span><span class="boring">    pub struct RNG {
</span><span class="boring">        val: u64,
</span><span class="boring">    }
</span><span class="boring">    impl RNG {
</span><span class="boring">        pub fn new(seed: u64) -&gt; Self {
</span><span class="boring">            Self { val: seed }
</span><span class="boring">        }
</span><span class="boring">        pub fn next_u64(&amp;mut self) -&gt; u64 {
</span><span class="boring">            let mut x = self.val;
</span><span class="boring">            x ^= x &lt;&lt; 13;
</span><span class="boring">            x ^= x &gt;&gt; 7;
</span><span class="boring">            x ^= x &lt;&lt; 17;
</span><span class="boring">            self.val = x;
</span><span class="boring">            x
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-4"><a class="header" href="#code-4">Code</a></h2>
<pre><code class="language-rust noplayground">trait PollardRho: MillerRabin + std::ops::ShrAssign + std::ops::BitAnd&lt;Output = Self&gt; + Clone {
    fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG);
    fn factorize(mut self, rng: &amp;mut rng::RNG) -&gt; Vec&lt;Self&gt; {
        let mut arr: Vec&lt;Self&gt; = Vec::new();
        if self &lt;= 1.into() {
            return arr;
        }
        while self.clone() &amp; 1.into() == 0.into() {
            self &gt;&gt;= 1.into();
            arr.push(2.into());
        }
        self.rho(&amp;mut arr, rng);
        arr
    }
}

macro_rules! impl_pollardrho {
    ($t:ty, $u:ty, $reset:expr) =&gt; {
        impl PollardRho for $t {
            fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG) {
                if self &lt;= 1 {
                    return;
                } else if self.is_prime() {
                    arr.push(self);
                    return;
                }

                let mut i: u64 = 0;
                let mut x: $t = (rng.next_u64() % self as u64) as $t;
                let mut y: $t = x;
                let mut k: u64 = 2;
                let mut d: $t;
                let mut reset_limit: u64 = $reset;

                loop {
                    i += 1;
                    x = (((x as $u * x as $u % self as $u) + (self - 1) as $u) % self as $u) as $t;
                    d = gcd(y.abs_diff(x), self);
                    if d == self || i &gt;= reset_limit {
                        // Reset
                        reset_limit = reset_limit * 3 / 2;
                        i = 0;
                        x = (rng.next_u64() % self as u64) as $t;
                        y = x;
                    }
                    if d != 1 {
                        break;
                    }
                    if i == k {
                        y = x;
                        k &lt;&lt;= 1;
                    }
                }

                if d != self {
                    d.rho(arr, rng);
                    (self / d).rho(arr, rng);
                    return;
                }

                let mut i = 3;
                while i * i &lt;= self {
                    if self % i == 0 {
                        i.rho(arr, rng);
                        (d / i).rho(arr, rng);
                        return;
                    }
                    i += 2;
                }
            }
        }
    };
}

impl_pollardrho!(u8, u16, 100000);
impl_pollardrho!(u16, u32, 100000);
impl_pollardrho!(u32, u64, 100000);
impl_pollardrho!(u64, u128, 100000);

trait MillerRabin: From&lt;u8&gt; + PartialOrd {
    const MR_THRES: Self;
    fn naive_primality(self) -&gt; bool;
    fn miller_rabin_test(self, a: Self) -&gt; bool;
    fn miller_primality(self) -&gt; bool;
    fn is_prime(self) -&gt; bool {
        if self &lt;= 1.into() {
            false
        } else if self &lt;= Self::MR_THRES {
            self.naive_primality()
        } else {
            self.miller_primality()
        }
    }
}

macro_rules! impl_millerrabin {
        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
            impl MillerRabin for $t {
                const MR_THRES: Self = $thres;

                #[inline(always)]
                fn naive_primality(self) -&gt; bool {
                    for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
                        if self % i == 0 {
                            return false;
                        }
                    }
                    true
                }

                #[inline(always)]
                fn miller_rabin_test(self, a: Self) -&gt; bool {
                    let d = self - 1;
                    let mut p = d &gt;&gt; (d.trailing_zeros());

                    let mut t = {
                        let mut base = a as $u;
                        let mut exp = p as $u;
                        let rem = self as $u;
                        let mut ret: $u = 1;
                        while exp != 0 {
                            if exp &amp; 1 != 0 {
                                ret = ret * base % rem;
                            }
                            base = base*base%rem;
                            exp &gt;&gt;= 1;
                        }
                        ret as $t
                    };

                    let at_last = t == d || t == 1;

                    while p != d {
                        p &lt;&lt;= 1;
                        t = ((t as $u * t as $u) % self as $u) as $t;
                        if t == self - 1 {
                            return true;
                        }
                    }
                    at_last
                }

                fn miller_primality(self) -&gt; bool {
                    $(
                        if !self.miller_rabin_test($x) {
                            return false;
                        }
                    )*
                    true
                }
            }
        };
    }

impl_millerrabin!(u8, u16, 254, 2);
impl_millerrabin!(u16, u32, 2000, 2, 3);
impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);

pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy + PartialEq + PartialOrd + std::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
{
    if y == 0.into() {
        x
    } else {
        let v = x % y;
        gcd(y, v)
    }
}

mod rng {
    pub struct RNG {
        val: u64,
    }
    impl RNG {
        pub fn new(seed: u64) -&gt; Self {
            Self { val: seed }
        }
        pub fn next_u64(&amp;mut self) -&gt; u64 {
            let mut x = self.val;
            x ^= x &lt;&lt; 13;
            x ^= x &gt;&gt; 7;
            x ^= x &lt;&lt; 17;
            self.val = x;
            x
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-square-root"><a class="header" href="#integer-square-root">Integer Square Root</a></h1>
<p><code>isqrt(s)</code> returns \( \left\lfloor \sqrt{s} \right\rfloor \). It runs much faster than the typical binary search method, but slower than casting the result from <code>std::f64::sqrt</code>. If the value can be perfectly represented with <code>f64</code> and the memory limit isn't too short, it's better to use the <code>f64</code> square root function from <code>std</code>.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let x: u64 = 10002;
let sq = isqrt(x);
println!(&quot;{}&quot;, sq); // 100
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn isqrt(s: u64) -&gt; u64 {
</span><span class="boring">    let mut x0 = s &gt;&gt; 1;
</span><span class="boring">    if x0 != 0 {
</span><span class="boring">        let mut x1 = (x0 + s / x0) &gt;&gt; 1;
</span><span class="boring">        while x1 &lt; x0 {
</span><span class="boring">            x0 = x1;
</span><span class="boring">            x1 = (x0 + s / x0) &gt;&gt; 1
</span><span class="boring">        }
</span><span class="boring">        x0
</span><span class="boring">    } else {
</span><span class="boring">        s
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-5"><a class="header" href="#code-5">Code</a></h2>
<pre><code class="language-rust noplayground">fn isqrt(s: u64) -&gt; u64 {
    let mut x0 = s &gt;&gt; 1;
    if x0 != 0 {
        let mut x1 = (x0 + s / x0) &gt;&gt; 1;
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) &gt;&gt; 1
        }
        x0
    } else {
        s
    }
}</code></pre>
<h2 id="generic-version-1"><a class="header" href="#generic-version-1">Generic Version</a></h2>
<p>The function below works for any primitive unsigned integer types.</p>
<pre><code class="language-rust noplayground">fn isqrt&lt;T&gt;(s: T) -&gt; T
where
    T: Copy
        + std::ops::Shr&lt;Output = T&gt;
        + std::ops::Add&lt;Output = T&gt;
        + std::ops::Div&lt;Output = T&gt;
        + PartialOrd
        + From&lt;u8&gt;,
{
    let mut x0 = s &gt;&gt; 1.into();
    if x0 != 0.into() {
        let mut x1 = (x0 + s / x0) &gt;&gt; 1.into();
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) &gt;&gt; 1.into();
        }
        x0
    } else {
        s
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-recurrence"><a class="header" href="#linear-recurrence">Linear Recurrence</a></h1>
<p>Algorithms related to linear recurrences</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="berlekamp-massey"><a class="header" href="#berlekamp-massey">Berlekamp-Massey</a></h1>
<p><code>berlekamp_massey(A, m)</code> returns a vector <code>C</code> of length \(n\) which satisfies
\[ \begin{aligned}
A_x &amp;= \sum_{i=0}^{i=k-1} {C_i A_{x-k+i}} \\
&amp;= C_0 A_{x-k} + C_1 A_{x-k+1} + \cdots + C_{k-1} A_{x-1}
\end{aligned} \]
with minimum \(n\) under <strong>prime</strong> modulo \(m\). It is safe to have the length of <code>vals</code> as at least \(3n\).</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>// vals[x] = vals[x-3] + 2*vals[x-2] + 3*vals[x-1]
let m: u64 = 1000000007;
let mut vals: Vec&lt;u64&gt; = vec![1, 2, 3];
for x in 3..20 {
    vals.push((vals[x - 3] + 2 * vals[x - 2] + 3 * vals[x - 1]) % m);
}

let rec = berlekamp_massey(&amp;vals, m);
println!(&quot;{:?}&quot;, rec); // [1, 2, 3]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Berlekamp-Massey
</span><span class="boring">// References
</span><span class="boring">// https://blog.naver.com/jinhan814/222140081932
</span><span class="boring">// https://koosaga.com/231
</span><span class="boring">
</span><span class="boring">fn rem_pow(mut base: i64, mut exp: i64, m: i64) -&gt; i64 {
</span><span class="boring">    let mut result = 1;
</span><span class="boring">    while exp != 0 {
</span><span class="boring">        if exp &amp; 1 != 0 {
</span><span class="boring">            result = (result * base) % m;
</span><span class="boring">        }
</span><span class="boring">        exp &gt;&gt;= 1;
</span><span class="boring">        base = (base * base) % m;
</span><span class="boring">    }
</span><span class="boring">    result
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Finds rec[n] which satisfies
</span><span class="boring">/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rec[d-1]vals[d-1]
</span><span class="boring">/// with minimum n.
</span><span class="boring">fn berlekamp_massey(vals: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">    let m = m as i64;
</span><span class="boring">    let mut cur: Vec&lt;i64&gt; = Vec::new();
</span><span class="boring">    let (mut lf, mut ld) = (0, 0);
</span><span class="boring">    let mut ls: Vec&lt;i64&gt; = Vec::new();
</span><span class="boring">    for i in 0..vals.len() {
</span><span class="boring">        let mut t = 0;
</span><span class="boring">        for (j, v) in cur.iter().enumerate() {
</span><span class="boring">            t = (t + vals[i - j - 1] as i64 * v) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if (t - vals[i] as i64) % m == 0 {
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if cur.len() == 0 {
</span><span class="boring">            cur = vec![0; i + 1];
</span><span class="boring">            lf = i;
</span><span class="boring">            ld = (t - vals[i] as i64) % m;
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;
</span><span class="boring">        let mut c: Vec&lt;i64&gt; = vec![0; i - lf + ls.len()];
</span><span class="boring">        c[i - lf - 1] = k as i64;
</span><span class="boring">        for (p, j) in ls.iter().enumerate() {
</span><span class="boring">            c[i - lf + p] = -j * k % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if c.len() &lt; cur.len() {
</span><span class="boring">            c.extend((0..(cur.len() - c.len())).map(|_| 0));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        for j in 0..cur.len() {
</span><span class="boring">            c[j] = (c[j] + cur[j]) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if i - lf + ls.len() &gt;= cur.len() {
</span><span class="boring">            ls = cur;
</span><span class="boring">            lf = i;
</span><span class="boring">            ld = (t - vals[i] as i64) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        cur = c;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    for i in 0..cur.len() {
</span><span class="boring">        cur[i] = (cur[i] % m + m) % m;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    cur.into_iter().rev().map(|x| x as u64).collect()
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-6"><a class="header" href="#code-6">Code</a></h2>
<pre><code class="language-rust noplayground">// Berlekamp-Massey
// References
// https://blog.naver.com/jinhan814/222140081932
// https://koosaga.com/231

fn rem_pow(mut base: i64, mut exp: i64, m: i64) -&gt; i64 {
    let mut result = 1;
    while exp != 0 {
        if exp &amp; 1 != 0 {
            result = (result * base) % m;
        }
        exp &gt;&gt;= 1;
        base = (base * base) % m;
    }
    result
}

/// Finds rec[n] which satisfies
/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rec[d-1]vals[d-1]
/// with minimum n.
fn berlekamp_massey(vals: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let m = m as i64;
    let mut cur: Vec&lt;i64&gt; = Vec::new();
    let (mut lf, mut ld) = (0, 0);
    let mut ls: Vec&lt;i64&gt; = Vec::new();
    for i in 0..vals.len() {
        let mut t = 0;
        for (j, v) in cur.iter().enumerate() {
            t = (t + vals[i - j - 1] as i64 * v) % m;
        }

        if (t - vals[i] as i64) % m == 0 {
            continue;
        }

        if cur.len() == 0 {
            cur = vec![0; i + 1];
            lf = i;
            ld = (t - vals[i] as i64) % m;
            continue;
        }

        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;
        let mut c: Vec&lt;i64&gt; = vec![0; i - lf + ls.len()];
        c[i - lf - 1] = k as i64;
        for (p, j) in ls.iter().enumerate() {
            c[i - lf + p] = -j * k % m;
        }

        if c.len() &lt; cur.len() {
            c.extend((0..(cur.len() - c.len())).map(|_| 0));
        }

        for j in 0..cur.len() {
            c[j] = (c[j] + cur[j]) % m;
        }

        if i - lf + ls.len() &gt;= cur.len() {
            ls = cur;
            lf = i;
            ld = (t - vals[i] as i64) % m;
        }

        cur = c;
    }

    for i in 0..cur.len() {
        cur[i] = (cur[i] % m + m) % m;
    }

    cur.into_iter().rev().map(|x| x as u64).collect()
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kitamasa"><a class="header" href="#kitamasa">Kitamasa</a></h1>
<p><code>kitamasa(C, A, n, m)</code> returns \(A_n\) where
\[ \begin{aligned}
A_x &amp;= \sum_{i=0}^{i=k-1} {C_i A_{x-k+i}} \\
&amp;= C_0 A_{x-k} + C_1 A_{x-k+1} + \cdots + C_{k-1} A_{x-1}
\end{aligned} \]
in a time complexity of \( O(T(k) \log{n}) \), where \(O(T(k))\) is a time complexity taken for multiplying two polynomials of order \(k\), and \(k\) is a length of \(C\).</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>// vals[x] = vals[x-3] + 2*vals[x-2] + 3*vals[x-1]
// 1, 2, 3, 14, 50, 181, 657, 2383, 8644, 31355, 113736, 412562, 1496513, 5428399, 19690785, 71425666, ...
let m: u64 = 1000000007;
let vals: Vec&lt;u64&gt; = vec![1, 2, 3];
let rec: Vec&lt;u64&gt; = vec![1, 2, 3];

let v = kitamasa(&amp;rec, &amp;vals, 15, m);
println!(&quot;{}&quot;, v); // 71425666
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Kitamasas
</span><span class="boring">// Reference: https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/
</span><span class="boring">
</span><span class="boring">fn poly_mul(v: &amp;[u64], w: &amp;[u64], rec: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">    let mut t = vec![0; 2 * v.len()];
</span><span class="boring">
</span><span class="boring">    for j in 0..v.len() {
</span><span class="boring">        for k in 0..w.len() {
</span><span class="boring">            t[j + k] += v[j] * w[k] % m;
</span><span class="boring">            if t[j + k] &gt;= m {
</span><span class="boring">                t[j + k] -= m;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    for j in (v.len()..2 * v.len()).rev() {
</span><span class="boring">        for k in 1..=v.len() {
</span><span class="boring">            t[j - k] += t[j] * rec[k - 1] % m;
</span><span class="boring">            if t[j - k] &gt;= m {
</span><span class="boring">                t[j - k] -= m;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    t[..v.len()].iter().map(|x| *x).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Finds arr[n] where
</span><span class="boring">/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
</span><span class="boring">/// under modulo m where d=rec.len()=arr.len()
</span><span class="boring">fn kitamasa(rec: &amp;[u64], vals: &amp;[u64], mut n: u64, m: u64) -&gt; u64 {
</span><span class="boring">    let recurr: Vec&lt;_&gt; = rec.iter().rev().copied().collect();
</span><span class="boring">    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);
</span><span class="boring">    s[0] = 1;
</span><span class="boring">    if recurr.len() != 1 {
</span><span class="boring">        t[1] = 1;
</span><span class="boring">    } else {
</span><span class="boring">        t[0] = recurr[0];
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    while n != 0 {
</span><span class="boring">        if n &amp; 1 != 0 {
</span><span class="boring">            s = poly_mul(&amp;s, &amp;t, &amp;recurr, m);
</span><span class="boring">        }
</span><span class="boring">        t = poly_mul(&amp;t, &amp;t, &amp;recurr, m);
</span><span class="boring">        n &gt;&gt;= 1;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mut ret = 0u64;
</span><span class="boring">    for i in 0..recurr.len() {
</span><span class="boring">        ret += s[i] * vals[i] % m;
</span><span class="boring">        if ret &gt;= m {
</span><span class="boring">            ret -= m;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    ret
</span><span class="boring">}</span></code></pre></pre>
<h2 id="ok2-logn-implementation"><a class="header" href="#ok2-logn-implementation">\(O(k^2 \log{n})\) Implementation</a></h2>
<p>The implementation below uses naive polynomial multiplication.</p>
<pre><code class="language-rust noplayground">// Kitamasa
// Reference: JusticeHui's Blog: &lt;https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/&gt;

fn poly_mul(v: &amp;[u64], w: &amp;[u64], rec: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut t = vec![0; 2 * v.len()];

    for j in 0..v.len() {
        for k in 0..w.len() {
            t[j + k] += v[j] * w[k] % m;
            if t[j + k] &gt;= m {
                t[j + k] -= m;
            }
        }
    }

    for j in (v.len()..2 * v.len()).rev() {
        for k in 1..=v.len() {
            t[j - k] += t[j] * rec[k - 1] % m;
            if t[j - k] &gt;= m {
                t[j - k] -= m;
            }
        }
    }

    t[..v.len()].iter().map(|x| *x).collect()
}

/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under modulo m where d=rec.len()=arr.len()
fn kitamasa(rec: &amp;[u64], vals: &amp;[u64], mut n: u64, m: u64) -&gt; u64 {
    let recurr: Vec&lt;_&gt; = rec.iter().rev().copied().collect();
    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);
    s[0] = 1;
    if recurr.len() != 1 {
        t[1] = 1;
    } else {
        t[0] = recurr[0];
    }

    while n != 0 {
        if n &amp; 1 != 0 {
            s = poly_mul(&amp;s, &amp;t, &amp;recurr, m);
        }
        t = poly_mul(&amp;t, &amp;t, &amp;recurr, m);
        n &gt;&gt;= 1;
    }

    let mut ret = 0u64;
    for i in 0..recurr.len() {
        ret += s[i] * vals[i] % m;
        if ret &gt;= m {
            ret -= m;
        }
    }
    ret
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bostan-mori"><a class="header" href="#bostan-mori">Bostan-Mori</a></h1>
<p>Reference - <a href="https://hal.inria.fr/hal-02917827v2/document">Alin Bostan, Ryuhei Mori. A Simple and Fast Algorithm for Computing the N-th Term of a Linearly Recurrent Sequence. SOSA’21 (SIAM Symposium on Simplicity in Algorithms), Jan 2021, Alexandria, United States. ffhal-02917827v2f</a></p>
<h2 id="calculating-one-value-of-the-sequence"><a class="header" href="#calculating-one-value-of-the-sequence">Calculating one value of the sequence</a></h2>
<h3 id="naive-multiplication-under-prime-modulo"><a class="header" href="#naive-multiplication-under-prime-modulo">Naive multiplication, under prime modulo</a></h3>
<pre><code class="language-rust noplayground">/// Returns g, s, t s.t. g=gcd(a,b) and as+bt=r
#[inline(always)]
fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut r, mut old_r) = (b, a);
    while r != 0 {
        let q = old_r / r;

        let new_r = old_r - q * r;
        old_r = r;
        r = new_r;

        let new_s = old_s - q * s;
        old_s = s;
        s = new_s;
    }

    (
        old_r,
        old_s,
        if b != 0 { (old_r - old_s * a) / b } else { 0 },
    )
}

fn mod_inv(a: u64, m: u64) -&gt; u64 {
    let (_, mut x, _) = ext_gcd((a % m) as i64, m as i64);
    if x &lt; 0 {
        x += m as i64;
    }
    x as u64 % m
}

/// f = f[0] + f[1]x + f[2]x2 + ...
#[inline(always)]
fn poly_mul(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; f.len() + g.len() - 1];
    for (i, &amp;u) in f.iter().enumerate() {
        // u*x**i
        for (j, &amp;v) in g.iter().enumerate() {
            // v*x**j
            h[i + j] += u * v;
            h[i + j] %= m;
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

#[inline(always)]
fn poly_mul_even_order(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; (f.len() + g.len()) / 2 + 2];
    for (i, &amp;u) in f.iter().enumerate() {
        if i &amp; 1 == 0 {
            for (j, &amp;v) in g.iter().enumerate().step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        } else {
            for (j, &amp;v) in g.iter().enumerate().skip(1).step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

#[inline(always)]
fn poly_mul_odd_order(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; (f.len() + g.len()) / 2 + 2];
    for (i, &amp;u) in f.iter().enumerate() {
        if i &amp; 1 != 0 {
            for (j, &amp;v) in g.iter().enumerate().step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        } else {
            for (j, &amp;v) in g.iter().enumerate().skip(1).step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

/// f(x) -&gt; f(-x)
#[inline(always)]
fn get_neg_x(f: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    f.iter()
        .enumerate()
        .map(|(i, &amp;v)| if i &amp; 1 == 0 { v } else { m - v })
        .collect()
}

/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under modulo m where d=rec.len()=arr.len()
fn bostan_mori(rec: &amp;[u64], vals: &amp;[u64], n: u64, m: u64) -&gt; u64 {
    if vals.len() as u64 &gt; n {
        return vals[n as usize];
    }
    let d = rec.len();

    let mut q: Vec&lt;u64&gt; = Vec::with_capacity(d + 1);
    q.push(1);
    q.extend(rec.iter().map(|&amp;v| m - v).rev());

    let mut p = poly_mul(vals, &amp;q, m);
    p.truncate(d);

    let mut n = n;
    while n &gt;= 1 {
        let mq = get_neg_x(&amp;q, m);
        if n &amp; 1 == 0 {
            p = poly_mul_even_order(&amp;p, &amp;mq, m);
        } else {
            p = poly_mul_odd_order(&amp;p, &amp;mq, m);
        }
        q = poly_mul_even_order(&amp;q, &amp;mq, m);
        n &gt;&gt;= 1;
    }
    p[0] * mod_inv(q[0], m) // Requires GCD(q[0], m) = 1, it's safe to have m as a prime
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-n-dimensional-array"><a class="header" href="#fast-n-dimensional-array">Fast n-dimensional Array</a></h1>
<pre><code class="language-rust noplayground">struct Matrix&lt;T&gt;(Vec&lt;T&gt;, usize); // colnum

impl&lt;T&gt; Matrix&lt;T&gt; {
    fn new(arr: Vec&lt;T&gt;, r: usize, c: usize) -&gt; Self {
        assert_eq!(arr.len(), r * c);
        Self(arr, c)
    }
}

impl&lt;T&gt; std::ops::Index&lt;usize&gt; for Matrix&lt;T&gt; {
    type Output = [T];

    fn index(&amp;self, i: usize) -&gt; &amp;Self::Output {
        &amp;self.0[self.1 * i..self.1 * (i + 1)]
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for Matrix&lt;T&gt; {
    fn index_mut(&amp;mut self, i: usize) -&gt; &amp;mut Self::Output {
        &amp;mut self.0[self.1 * i..self.1 * (i + 1)]
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitset"><a class="header" href="#bitset">Bitset</a></h1>
<pre><code class="language-rust noplayground">struct Bitset {
    bytes: Vec&lt;u8&gt;,
}

impl Bitset {
    #[inline(always)]
    fn new(size: usize) -&gt; Self {
        Self {
            bytes: vec![0; (size &gt;&gt; 3) + 1],
        }
    }

    #[inline(always)]
    fn get(&amp;self, idx: usize) -&gt; bool {
        (self.bytes[idx &gt;&gt; 3] &gt;&gt; (idx &amp; 0b111)) &amp; 1 == 1
    }

    #[inline(always)]
    fn set_true(&amp;mut self, idx: usize) {
        self.bytes[idx &gt;&gt; 3] |= 1 &lt;&lt; (idx &amp; 0b111);
    }

    #[inline(always)]
    fn set_false(&amp;mut self, idx: usize) {
        self.bytes[idx &gt;&gt; 3] &amp;= !(1 &lt;&lt; (idx &amp; 0b111));
    }

    #[inline(always)]
    fn set(&amp;mut self, idx: usize, to: bool) {
        if to {
            self.set_true(idx);
        } else {
            self.set_false(idx);
        }
    }

    #[inline(always)]
    fn toggle(&amp;mut self, idx: usize) {
        self.bytes[idx &gt;&gt; 3] ^= 1 &lt;&lt; (idx &amp; 0b111);
    }

    #[inline(always)]
    fn fill(&amp;mut self, with: u8) {
        for v in self.bytes.iter_mut() {
            *v = with;
        }
    }

    #[inline(always)]
    fn fill_range(&amp;mut self, chunk_start: usize, chunk_end: usize, with: u8) {
        for v in self.bytes[chunk_start..chunk_end].iter_mut() {
            *v = with;
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-trees"><a class="header" href="#segment-trees">Segment Trees</a></h1>
<p>Segment trees are a category of data structures which can handle range queries efficiently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A segment tree is a data structure for monoids \( (S, \cdot : S \times S \rightarrow S, e \in S) \). A monoid is an algebraic structure which follows the following conditions:</p>
<ul>
<li>\(\cdot\) is associative. That is, \( (a \cdot b) \cdot c = a \cdot (b \cdot c) \) for all \( a, b, c \in S \).</li>
<li>There is the identity element \(e\) such that \( a \cdot e = e \cdot a = a \) for all \( a \in S \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(S\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Update an element</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use segtree::*;
</span><span class="boring">
</span>// Range sum segment tree
impl Monoid for i32 {
    fn e() -&gt; Self { 0 }
    fn opr_lhs(&amp;mut self, rhs: &amp;Self) { *self += rhs; }
    fn opr_rhs(&amp;mut self, lhs: &amp;Self) { *self += lhs; }
}

<span class="boring">fn main() {
</span>let mut st = SegTree::new(vec![0i32, 4, 0, 0, 0, 0, 0, 0, 0]);
st.set(2, 5);
st.set(4, 8);

println!(&quot;{}&quot;, st[2]);         // 5
println!(&quot;{}&quot;, st.prod(0..3)); // 9
println!(&quot;{}&quot;, st.prod(..));   // 17

let r = st.max_right(2, |&amp;x| x &lt; 13);
println!(&quot;{}&quot;, r);             // 4
let l = st.min_left(st.len(), |&amp;x| x &lt; 100);
println!(&quot;{}&quot;, l);             // 0
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod segtree {
</span><span class="boring">    use std::ops::{Index, RangeBounds};
</span><span class="boring">
</span><span class="boring">    fn ceil_pow2(n: usize) -&gt; u32 {
</span><span class="boring">        let mut x = 0;
</span><span class="boring">        while 1 &lt;&lt; x &lt; n {
</span><span class="boring">            x += 1;
</span><span class="boring">        }
</span><span class="boring">        x
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub trait Monoid: Sized {
</span><span class="boring">        fn e() -&gt; Self;
</span><span class="boring">        fn opr_lhs(&amp;mut self, rhs: &amp;Self);
</span><span class="boring">        fn opr_rhs(&amp;mut self, lhs: &amp;Self);
</span><span class="boring">        fn opr(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
</span><span class="boring">            let mut ret = Self::e();
</span><span class="boring">            ret.opr_rhs(lhs);
</span><span class="boring">            ret.opr_lhs(rhs);
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">        fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
</span><span class="boring">            *self = Self::opr(lhs, rhs);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct SegTree&lt;S&gt; {
</span><span class="boring">        n: usize,
</span><span class="boring">        size: usize,
</span><span class="boring">        log: u32,
</span><span class="boring">        data: Vec&lt;S&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;S: Monoid&gt; SegTree&lt;S&gt; {
</span><span class="boring">        fn update(&amp;mut self, k: usize) {
</span><span class="boring">            let mut ret = S::e();
</span><span class="boring">            ret.opr_set(&amp;self.data[k &lt;&lt; 1], &amp;self.data[(k &lt;&lt; 1) + 1]);
</span><span class="boring">            self.data[k] = ret;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn new(arr: Vec&lt;S&gt;) -&gt; Self {
</span><span class="boring">            let n = arr.len();
</span><span class="boring">            let log = ceil_pow2(n);
</span><span class="boring">            let size = 1 &lt;&lt; log;
</span><span class="boring">            let stsize = 1 &lt;&lt; (log + 1);
</span><span class="boring">
</span><span class="boring">            let mut data = Vec::with_capacity(stsize);
</span><span class="boring">            data.extend((0..size).map(|_| S::e()));
</span><span class="boring">            data.extend(arr.into_iter());
</span><span class="boring">            data.extend((data.len()..stsize).map(|_| S::e()));
</span><span class="boring">
</span><span class="boring">            let mut st = Self { n, size, log, data };
</span><span class="boring">            for i in (1..size).rev() {
</span><span class="boring">                st.update(i);
</span><span class="boring">            }
</span><span class="boring">            st
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">            self.n
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn set(&amp;mut self, i: usize, v: S) {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            self.data[i] = v;
</span><span class="boring">            for j in 1..=self.log {
</span><span class="boring">                self.update(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn get(&amp;self, i: usize) -&gt; &amp;S {
</span><span class="boring">            &amp;self.data[i + self.size]
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn prod(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; S {
</span><span class="boring">            use std::ops::Bound::*;
</span><span class="boring">            let (mut sml, mut smr) = (S::e(), S::e());
</span><span class="boring">            let mut l = match range.start_bound() {
</span><span class="boring">                Included(&amp;v) =&gt; v,
</span><span class="boring">                Excluded(&amp;v) =&gt; v + 1,
</span><span class="boring">                Unbounded =&gt; 0,
</span><span class="boring">            } + self.size;
</span><span class="boring">            let mut r = match range.end_bound() {
</span><span class="boring">                Included(&amp;v) =&gt; v + 1,
</span><span class="boring">                Excluded(&amp;v) =&gt; v,
</span><span class="boring">                Unbounded =&gt; self.n,
</span><span class="boring">            } + self.size;
</span><span class="boring">
</span><span class="boring">            if (l, r) == (0, self.n) {
</span><span class="boring">                let mut ret = S::e();
</span><span class="boring">                ret.opr_lhs(&amp;self.data[1]);
</span><span class="boring">                return ret;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            while l &lt; r {
</span><span class="boring">                if l &amp; 1 == 1 {
</span><span class="boring">                    sml.opr_lhs(&amp;self.data[l]);
</span><span class="boring">                    l += 1;
</span><span class="boring">                }
</span><span class="boring">                if r &amp; 1 == 1 {
</span><span class="boring">                    r -= 1;
</span><span class="boring">                    smr.opr_rhs(&amp;self.data[r]);
</span><span class="boring">                }
</span><span class="boring">                l &gt;&gt;= 1;
</span><span class="boring">                r &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            sml.opr_lhs(&amp;smr);
</span><span class="boring">            sml
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Given an index l and a check function f, max_right finds an index r that satisfies
</span><span class="boring">        ///   (r == l || f(self.prod(l..r)) &amp;&amp; (r == n || !f(self.prod(l..=r)))
</span><span class="boring">        /// If f is monotone, this is the maximum r that satisfies f(self.prod(l..r)).
</span><span class="boring">        /// It should be guaranteed that f(S::e()) is true, 0 &lt;= l and l &lt;= n.
</span><span class="boring">        pub fn max_right(&amp;self, l: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
</span><span class="boring">            if l == self.n {
</span><span class="boring">                return self.n;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut l = l + self.size;
</span><span class="boring">            let mut sm = S::e();
</span><span class="boring">
</span><span class="boring">            loop {
</span><span class="boring">                l &gt;&gt;= l.trailing_zeros();
</span><span class="boring">                if !f(&amp;S::opr(&amp;sm, &amp;self.data[l])) {
</span><span class="boring">                    while l &lt; self.size {
</span><span class="boring">                        l &lt;&lt;= 1;
</span><span class="boring">                        let tmp = S::opr(&amp;sm, &amp;self.data[l]);
</span><span class="boring">                        if f(&amp;tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            l += 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return l - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm.opr_lhs(&amp;self.data[l]);
</span><span class="boring">                l += 1;
</span><span class="boring">
</span><span class="boring">                if l &amp; ((!l) + 1) == l {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            self.n
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Given an index r and a check function f, min_left finds an index l that satisfies
</span><span class="boring">        ///   (l == r || f(self.prod(l..r))) &amp;&amp; (l == 0 || !f(self.prod(l-1..r)))
</span><span class="boring">        /// If f is monotone, this is the minimum l that satisfies f(self.prod(l..r)).
</span><span class="boring">        /// It should be guaranteed that f(S::e()) is true, 0 &lt;= r and r &lt;= n.
</span><span class="boring">        pub fn min_left(&amp;self, r: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
</span><span class="boring">            if r == 0 {
</span><span class="boring">                return 0;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut r = r + self.size;
</span><span class="boring">            let mut sm = S::e();
</span><span class="boring">
</span><span class="boring">            loop {
</span><span class="boring">                r -= 1;
</span><span class="boring">                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
</span><span class="boring">                    r &gt;&gt;= 1;
</span><span class="boring">                }
</span><span class="boring">                if !f(&amp;S::opr(&amp;self.data[r], &amp;sm)) {
</span><span class="boring">                    while r &lt; self.size {
</span><span class="boring">                        r = (r &lt;&lt; 1) + 1;
</span><span class="boring">                        let tmp = S::opr(&amp;self.data[r], &amp;sm);
</span><span class="boring">                        if f(&amp;tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            r -= 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return r + 1 - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm.opr_rhs(&amp;self.data[r]);
</span><span class="boring">
</span><span class="boring">                if r &amp; ((!r) + 1) == r {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            0
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;S: Monoid&gt; Index&lt;usize&gt; for SegTree&lt;S&gt; {
</span><span class="boring">        type Output = S;
</span><span class="boring">        fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">            self.get(index)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-7"><a class="header" href="#code-7">Code</a></h2>
<pre><code class="language-rust noplayground">mod segtree {
    use std::ops::{Index, RangeBounds};

    fn ceil_pow2(n: usize) -&gt; u32 {
        let mut x = 0;
        while 1 &lt;&lt; x &lt; n {
            x += 1;
        }
        x
    }

    pub trait Monoid: Sized {
        fn e() -&gt; Self;
        fn opr_lhs(&amp;mut self, rhs: &amp;Self);
        fn opr_rhs(&amp;mut self, lhs: &amp;Self);
        fn opr(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
            let mut ret = Self::e();
            ret.opr_rhs(lhs);
            ret.opr_lhs(rhs);
            ret
        }
        fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
            *self = Self::opr(lhs, rhs);
        }
    }

    pub struct SegTree&lt;S&gt; {
        n: usize,
        size: usize,
        log: u32,
        data: Vec&lt;S&gt;,
    }

    impl&lt;S: Monoid&gt; SegTree&lt;S&gt; {
        fn update(&amp;mut self, k: usize) {
            let mut ret = S::e();
            ret.opr_set(&amp;self.data[k &lt;&lt; 1], &amp;self.data[(k &lt;&lt; 1) + 1]);
            self.data[k] = ret;
        }

        pub fn new(arr: Vec&lt;S&gt;) -&gt; Self {
            let n = arr.len();
            let log = ceil_pow2(n);
            let size = 1 &lt;&lt; log;
            let stsize = 1 &lt;&lt; (log + 1);

            let mut data = Vec::with_capacity(stsize);
            data.extend((0..size).map(|_| S::e()));
            data.extend(arr.into_iter());
            data.extend((data.len()..stsize).map(|_| S::e()));

            let mut st = Self { n, size, log, data };
            for i in (1..size).rev() {
                st.update(i);
            }
            st
        }

        pub fn len(&amp;self) -&gt; usize {
            self.n
        }

        pub fn get(&amp;self, i: usize) -&gt; &amp;S {
            &amp;self.data[i + self.size]
        }

        pub fn set(&amp;mut self, i: usize, v: S) {
            let i = i + self.size;
            self.data[i] = v;
            for j in 1..=self.log {
                self.update(i &gt;&gt; j);
            }
        }

        pub fn prod(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; S {
            use std::ops::Bound::*;
            let (mut sml, mut smr) = (S::e(), S::e());
            let mut l = match range.start_bound() {
                Included(&amp;v) =&gt; v,
                Excluded(&amp;v) =&gt; v + 1,
                Unbounded =&gt; 0,
            } + self.size;
            let mut r = match range.end_bound() {
                Included(&amp;v) =&gt; v + 1,
                Excluded(&amp;v) =&gt; v,
                Unbounded =&gt; self.n,
            } + self.size;

            if (l, r) == (0, self.n) {
                let mut ret = S::e();
                ret.opr_lhs(&amp;self.data[1]);
                return ret;
            }

            while l &lt; r {
                if l &amp; 1 == 1 {
                    sml.opr_lhs(&amp;self.data[l]);
                    l += 1;
                }
                if r &amp; 1 == 1 {
                    r -= 1;
                    smr.opr_rhs(&amp;self.data[r]);
                }
                l &gt;&gt;= 1;
                r &gt;&gt;= 1;
            }

            sml.opr_lhs(&amp;smr);
            sml
        }

        /// Given an index l and a check function f, max_right finds an index r that satisfies
        ///   (r == l || f(self.prod(l..r)) &amp;&amp; (r == n || !f(self.prod(l..=r)))
        /// If f is monotone, this is the maximum r that satisfies f(self.prod(l..r)).
        /// It should be guaranteed that f(S::e()) is true, 0 &lt;= l and l &lt;= n.
        pub fn max_right(&amp;self, l: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
            if l == self.n {
                return self.n;
            }

            let mut l = l + self.size;
            let mut sm = S::e();

            loop {
                l &gt;&gt;= l.trailing_zeros();
                if !f(&amp;S::opr(&amp;sm, &amp;self.data[l])) {
                    while l &lt; self.size {
                        l &lt;&lt;= 1;
                        let tmp = S::opr(&amp;sm, &amp;self.data[l]);
                        if f(&amp;tmp) {
                            sm = tmp;
                            l += 1;
                        }
                    }
                    return l - self.size;
                }
                sm.opr_lhs(&amp;self.data[l]);
                l += 1;

                if l &amp; ((!l) + 1) == l {
                    break;
                }
            }
            self.n
        }

        /// Given an index r and a check function f, min_left finds an index l that satisfies
        ///   (l == r || f(self.prod(l..r))) &amp;&amp; (l == 0 || !f(self.prod(l-1..r)))
        /// If f is monotone, this is the minimum l that satisfies f(self.prod(l..r)).
        /// It should be guaranteed that f(S::e()) is true, 0 &lt;= r and r &lt;= n.
        pub fn min_left(&amp;self, r: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
            if r == 0 {
                return 0;
            }

            let mut r = r + self.size;
            let mut sm = S::e();

            loop {
                r -= 1;
                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                    r &gt;&gt;= 1;
                }
                if !f(&amp;S::opr(&amp;self.data[r], &amp;sm)) {
                    while r &lt; self.size {
                        r = (r &lt;&lt; 1) + 1;
                        let tmp = S::opr(&amp;self.data[r], &amp;sm);
                        if f(&amp;tmp) {
                            sm = tmp;
                            r -= 1;
                        }
                    }
                    return r + 1 - self.size;
                }
                sm.opr_rhs(&amp;self.data[r]);

                if r &amp; ((!r) + 1) == r {
                    break;
                }
            }
            0
        }
    }

    impl&lt;S: Monoid&gt; Index&lt;usize&gt; for SegTree&lt;S&gt; {
        type Output = S;
        fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
            self.get(index)
        }
    }
}</code></pre>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<ul>
<li>
<p><code>trait Monoid</code> represents a monoid \(S\) explained above. Three methods <code>e</code>, <code>opr_lhs</code>, <code>opr_rhs</code> are required to be implemented. Implementing <code>opr</code> and <code>opr_set</code> is optional.</p>
<ul>
<li><code>fn e() -&gt; Self</code> returns an identity element of the monoid.</li>
<li><code>fn opr_lhs(&amp;mut self, rhs: &amp;Self)</code> calculates the product of <code>self</code> and <code>rhs</code> in this order, and sets <code>self</code> with it.</li>
<li><code>fn opr_rhs(&amp;mut self, lhs: &amp;Self)</code> calculates the product of <code>lhs</code> and <code>self</code> in this order, and sets <code>self</code> with it.</li>
<li>(Optional) <code>fn opr(lhs: &amp;Self, rhs: &amp;Self)</code> calculates the product of <code>lhs</code> and <code>rhs</code> and returns it.</li>
<li>(Optional) <code>fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self)</code> calculates the product of <code>lhs</code> and <code>rhs</code> and sets <code>self</code> with it.</li>
</ul>
</li>
<li>
<p><code>fn new(arr: Vec&lt;S&gt;) -&gt; Self</code> generates a segment tree from <code>arr</code>.</p>
</li>
<li>
<p><code>fn len(&amp;self) -&gt; usize</code> returns the length of the segment tree, which is equal to the length of the array used for constructing the segment tree.</p>
</li>
<li>
<p><code>fn get(&amp;self, i: usize) -&gt; &amp;S</code> returns the reference to the <code>i</code>th element of the segment tree.</p>
</li>
<li>
<p><code>fn set(&amp;mut self, i: usize, v: S)</code> sets the <code>i</code>th element of the segment tree with <code>v</code>.</p>
</li>
<li>
<p><code>fn prod(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; S</code> returns the product of values of the segment tree within the given range.</p>
<ul>
<li>Example: <code>let v = st.prod(3..10);</code> <code>let u = st.prod(..7);</code></li>
</ul>
</li>
<li>
<p><code>fn max_right(&amp;self, l: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize</code> returns an index <code>r</code> such that <code>(r == l || f(self.prod(l..r)) &amp;&amp; (r == n || !f(self.prod(l..=r)))</code>. If <code>f</code> is monotone, this is the maximum <code>r</code> that makes <code>f(self.prod(l..r)</code> true. It must be guaranteed that <code>f(S::e())</code> is true, and <code>0 &lt;= l &lt;= n</code>. This method is basically equivalent to <code>partition_point</code> of a slice type, but with a set left bound.</p>
</li>
<li>
<p><code>fn min_left(&amp;self, r: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize</code> returns an index <code>l</code> such that <code>(l == r || f(self.prod(l..r))) &amp;&amp; (l == 0 || !f(self.prod(l-1..r)))</code>. If <code>f</code> is monotone, this is the minimum <code>l</code> that makes <code>f(self.prod(l..r))</code> true. It must be guaranteed that <code>f(S::e())</code> is true, and <code>0 &lt;= r &lt;= n</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fenwick-tree"><a class="header" href="#fenwick-tree">Fenwick Tree</a></h1>
<p>Given an integer array \(A\) of length \(n\), a Fenwick tree processes the following queries in \(O(\log{n})\) time:</p>
<ul>
<li>Add a certain amount to an element</li>
<li>Calculate the sum of the elements of an interval</li>
</ul>
<p>A Fenwick tree uses half the memory of a segment tree, but the performance in terms of time is just about the same.</p>
<p>A type of elements of \(A\) must be a primitive signed integer type, such as <code>i32</code> and <code>i64</code>, and floats such as <code>f64</code>. Unsigned integer types like <code>u64</code> do not work.</p>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut fw: Fenwick&lt;i32&gt; = Fenwick::new(10);
for i in 0..10 {
    print!(&quot;{} &quot;, fw.get(i));
}
println!(); // 0 0 0 0 0 0 0 0 0 0

fw.add(2, 10);
fw.add(5, 100);
fw.add(3, -1);
for i in 0..10 {
    print!(&quot;{} &quot;, fw.get(i));
}
println!(); // 0 0 10 -1 0 100 0 0 0 0
<span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct Fenwick&lt;T&gt; {
</span><span class="boring">    n: usize,
</span><span class="boring">    data: Vec&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Copy + From&lt;i8&gt; + std::ops::AddAssign + std::ops::Sub&lt;Output = T&gt;&gt; Fenwick&lt;T&gt; {
</span><span class="boring">    fn new(n: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            data: vec![0.into(); n],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add(&amp;mut self, idx: usize, val: T) {
</span><span class="boring">        let mut idx = idx + 1;
</span><span class="boring">        while idx &lt;= self.n {
</span><span class="boring">            self.data[idx - 1] += val;
</span><span class="boring">            idx += idx &amp; (!idx + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self, idx: usize) -&gt; T {
</span><span class="boring">        self.sum(idx, idx + 1)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn sum(&amp;self, l: usize, r: usize) -&gt; T {
</span><span class="boring">        self.inner_sum(r) - self.inner_sum(l)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn inner_sum(&amp;self, mut r: usize) -&gt; T {
</span><span class="boring">        let mut s: T = 0.into();
</span><span class="boring">        while r &gt; 0 {
</span><span class="boring">            s += self.data[r - 1];
</span><span class="boring">            r -= r &amp; (!r + 1);
</span><span class="boring">        }
</span><span class="boring">        s
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-8"><a class="header" href="#code-8">Code</a></h2>
<pre><code class="language-rust noplayground#[derive(Clone  Debug)]">struct Fenwick&lt;T&gt; {
    n: usize,
    data: Vec&lt;T&gt;,
}

impl&lt;T: Copy + From&lt;i8&gt; + std::ops::AddAssign + std::ops::Sub&lt;Output = T&gt;&gt; Fenwick&lt;T&gt; {
    fn new(n: usize) -&gt; Self {
        Self {
            n,
            data: vec![0.into(); n],
        }
    }

    fn add(&amp;mut self, idx: usize, val: T) {
        let mut idx = idx + 1;
        while idx &lt;= self.n {
            self.data[idx - 1] += val;
            idx += idx &amp; (!idx + 1);
        }
    }

    fn get(&amp;self, idx: usize) -&gt; T {
        self.sum(idx, idx + 1)
    }

    fn sum(&amp;self, l: usize, r: usize) -&gt; T {
        self.inner_sum(r) - self.inner_sum(l)
    }

    fn inner_sum(&amp;self, mut r: usize) -&gt; T {
        let mut s: T = 0.into();
        while r &gt; 0 {
            s += self.data[r - 1];
            r -= r &amp; (!r + 1);
        }
        s
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-segment-tree"><a class="header" href="#lazy-segment-tree">Lazy Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A lazy segment tree is a data struture for a pair of <a href="datastructure/segtree/./segtree.html">a monoid</a> \( (S, \cdot : S \times S \rightarrow S, e \in S) \) and a set \(F\) of \(S \rightarrow S\) mappings that satisfies the following properties:</p>
<ul>
<li>\(F\) contains the identity mapping \(Id\) such that \( Id(x) = x \) for all \(x\in S\).</li>
<li>\(F\) is closed under composition. That is, \( f \circ g \in F \) for all \( f, g \in F \).</li>
<li>\( f (x \cdot y) = f(x) \cdot f(y) \) hold for all \(f \in F \) and \( x, y \in S \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(S\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Apply the mapping \( f \in F \) on all the elements of an interval</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use lazyseg::*;
</span><span class="boring">
</span>// ax+b lazy segment tree
type P = (i64, i64);

// P = (sum, len)
impl LzMonoid for P {
    fn e() -&gt; Self { (0, 0) }
    fn opr_lhs(&amp;mut self, rhs: &amp;Self) {
        self.0 += rhs.0; self.1 += rhs.1;
    }
    fn opr_rhs(&amp;mut self, lhs: &amp;Self) {
        self.0 += lhs.0; self.1 += lhs.1;
    }
}

// P = (a, b) equiv. to applying ax+b on LzMonoids
impl LzMap&lt;P&gt; for P {
    fn id() -&gt; Self { (1, 0) }
    fn map(&amp;self, apply: &amp;mut P) {
        apply.0 = self.0 * apply.0 + self.1 * apply.1;
    }
    fn compos_lhs(&amp;mut self, rhs: &amp;Self) {
        let (a, b, c, d) = (self.0, self.1, rhs.0, rhs.1);
        *self = (a * c, a * d + b);
    }
    fn compos_rhs(&amp;mut self, lhs: &amp;Self) {
        let (a, b, c, d) = (lhs.0, lhs.1, self.0, self.1);
        *self = (a * c, a * d + b);
    }
}

<span class="boring">fn main() {
</span>let mut st: LazySeg&lt;_, P&gt; = LazySeg::new((0..10).map(|v| (v, 1)).collect());
println!(&quot;{}&quot;, st.get(3).0); // 3
println!(&quot;{}&quot;, st.prod(2..6).0); // 14

// Add 5 to 1..6
st.apply_range(1..6, &amp;(1, 5));
// Multiply 6.. by 4
st.apply_range(6.., &amp;(4, 0));
// 0 6 7 8 9 10 24 28 32 36

let r = st.max_right(4, |&amp;(v, _)| v &lt; 43);
println!(&quot;{}&quot;, r); // 6
let l = st.min_left(6, |&amp;(v, _)| v &lt; 32);
println!(&quot;{}&quot;, l); // 3
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod lazyseg {
</span><span class="boring">    use std::ops::RangeBounds;
</span><span class="boring">
</span><span class="boring">    fn ceil_pow2(n: usize) -&gt; u32 {
</span><span class="boring">        let mut x = 0;
</span><span class="boring">        while 1 &lt;&lt; x &lt; n {
</span><span class="boring">            x += 1;
</span><span class="boring">        }
</span><span class="boring">        x
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn range_to_bounds(n: usize, range: impl RangeBounds&lt;usize&gt;) -&gt; (usize, usize) {
</span><span class="boring">        use std::ops::Bound::*;
</span><span class="boring">
</span><span class="boring">        let l = match range.start_bound() {
</span><span class="boring">            Included(&amp;v) =&gt; v,
</span><span class="boring">            Excluded(&amp;v) =&gt; v + 1,
</span><span class="boring">            Unbounded =&gt; 0,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let r = match range.end_bound() {
</span><span class="boring">            Included(&amp;v) =&gt; v + 1,
</span><span class="boring">            Excluded(&amp;v) =&gt; v,
</span><span class="boring">            Unbounded =&gt; n,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        (l, r)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub trait LzMonoid: Sized {
</span><span class="boring">        fn e() -&gt; Self;
</span><span class="boring">        fn opr_lhs(&amp;mut self, rhs: &amp;Self);
</span><span class="boring">        fn opr_rhs(&amp;mut self, lhs: &amp;Self);
</span><span class="boring">        fn opr(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
</span><span class="boring">            let mut ret = Self::e();
</span><span class="boring">            ret.opr_rhs(lhs);
</span><span class="boring">            ret.opr_lhs(rhs);
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">        fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
</span><span class="boring">            *self = Self::opr(lhs, rhs);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub trait LzMap&lt;S&gt;: Sized {
</span><span class="boring">        fn id() -&gt; Self;
</span><span class="boring">        fn map(&amp;self, apply: &amp;mut S);
</span><span class="boring">        fn compos_lhs(&amp;mut self, rhs: &amp;Self);
</span><span class="boring">        fn compos_rhs(&amp;mut self, lhs: &amp;Self);
</span><span class="boring">        fn compos(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
</span><span class="boring">            let mut ret = Self::id();
</span><span class="boring">            ret.compos_rhs(lhs);
</span><span class="boring">            ret.compos_lhs(rhs);
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">        fn opr_self(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
</span><span class="boring">            *self = Self::compos(lhs, rhs);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct LazySeg&lt;S, F&gt; {
</span><span class="boring">        n: usize,
</span><span class="boring">        size: usize,
</span><span class="boring">        log: u32,
</span><span class="boring">        data: Vec&lt;S&gt;,
</span><span class="boring">        lazy: Vec&lt;F&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;S, F&gt; LazySeg&lt;S, F&gt;
</span><span class="boring">    where
</span><span class="boring">        S: LzMonoid,
</span><span class="boring">        F: LzMap&lt;S&gt;,
</span><span class="boring">    {
</span><span class="boring">        fn update(&amp;mut self, k: usize) {
</span><span class="boring">            let val = S::opr(&amp;self.data[k &lt;&lt; 1], &amp;self.data[(k &lt;&lt; 1) + 1]);
</span><span class="boring">            self.data[k] = val;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn all_apply(&amp;mut self, k: usize, f: &amp;F) {
</span><span class="boring">            f.map(&amp;mut self.data[k]);
</span><span class="boring">            if k &lt; self.size {
</span><span class="boring">                self.lazy[k].compos_rhs(f);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn all_apply_unsafe(size: usize, k: usize, f: usize, data: &amp;mut [S], lazy: &amp;mut [F]) {
</span><span class="boring">            // f &lt; k
</span><span class="boring">            lazy[f].map(&amp;mut data[k]);
</span><span class="boring">            if k &lt; size {
</span><span class="boring">                let (fs, ks) = lazy.split_at_mut(k);
</span><span class="boring">                ks[0].compos_rhs(&amp;fs[f]);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn push(&amp;mut self, k: usize) {
</span><span class="boring">            Self::all_apply_unsafe(self.size, k &lt;&lt; 1, k, &amp;mut self.data, &amp;mut self.lazy);
</span><span class="boring">            Self::all_apply_unsafe(self.size, (k &lt;&lt; 1) + 1, k, &amp;mut self.data, &amp;mut self.lazy);
</span><span class="boring">            self.lazy[k] = F::id();
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn new(arr: Vec&lt;S&gt;) -&gt; Self {
</span><span class="boring">            let n = arr.len();
</span><span class="boring">            let log = ceil_pow2(n);
</span><span class="boring">            let size = 1 &lt;&lt; log;
</span><span class="boring">            let stsize = 1 &lt;&lt; (log + 1);
</span><span class="boring">
</span><span class="boring">            let mut data = Vec::with_capacity(stsize);
</span><span class="boring">            data.extend((0..size).map(|_| S::e()));
</span><span class="boring">            data.extend(arr.into_iter());
</span><span class="boring">            data.extend((data.len()..stsize).map(|_| S::e()));
</span><span class="boring">
</span><span class="boring">            let mut ls = Self {
</span><span class="boring">                n,
</span><span class="boring">                log,
</span><span class="boring">                size,
</span><span class="boring">                data,
</span><span class="boring">                lazy: Vec::from_iter((0..size).map(|_| F::id())),
</span><span class="boring">            };
</span><span class="boring">            for i in (1..size).rev() {
</span><span class="boring">                ls.update(i);
</span><span class="boring">            }
</span><span class="boring">            ls
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn set(&amp;mut self, i: usize, v: S) {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            for j in (1..=self.log).rev() {
</span><span class="boring">                self.push(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">            self.data[i] = v;
</span><span class="boring">            for j in 1..=self.log {
</span><span class="boring">                self.update(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn get(&amp;mut self, i: usize) -&gt; &amp;S {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            for j in (1..=self.log).rev() {
</span><span class="boring">                self.push(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">            &amp;self.data[i]
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn prod(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; S {
</span><span class="boring">            let (l, r) = range_to_bounds(self.size, range);
</span><span class="boring">
</span><span class="boring">            if l == 0 &amp;&amp; r == self.size {
</span><span class="boring">                let mut ret = S::e();
</span><span class="boring">                ret.opr_lhs(&amp;self.data[1]);
</span><span class="boring">                return ret;
</span><span class="boring">            } else if l == r {
</span><span class="boring">                return S::e();
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut l, mut r) = (l + self.size, r + self.size);
</span><span class="boring">
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                if ((l &gt;&gt; i) &lt;&lt; i) != l {
</span><span class="boring">                    self.push(l &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">                if ((r &gt;&gt; i) &lt;&lt; i) != r {
</span><span class="boring">                    self.push((r - 1) &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut sml, mut smr) = (S::e(), S::e());
</span><span class="boring">            while l &lt; r {
</span><span class="boring">                if l &amp; 1 == 1 {
</span><span class="boring">                    sml.opr_lhs(&amp;self.data[l]);
</span><span class="boring">                    l += 1;
</span><span class="boring">                }
</span><span class="boring">                if r &amp; 1 == 1 {
</span><span class="boring">                    r -= 1;
</span><span class="boring">                    smr.opr_rhs(&amp;self.data[r]);
</span><span class="boring">                }
</span><span class="boring">                l &gt;&gt;= 1;
</span><span class="boring">                r &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            S::opr(&amp;sml, &amp;smr)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn apply(&amp;mut self, i: usize, f: &amp;F) {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            for j in (1..=self.log).rev() {
</span><span class="boring">                self.push(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">            f.map(&amp;mut self.data[i]);
</span><span class="boring">            for j in 1..=self.log {
</span><span class="boring">                self.update(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn apply_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;, f: &amp;F) {
</span><span class="boring">            let (l, r) = range_to_bounds(self.size, range);
</span><span class="boring">
</span><span class="boring">            if l == r {
</span><span class="boring">                return;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut l, mut r) = (l + self.size, r + self.size);
</span><span class="boring">
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                if ((l &gt;&gt; i) &lt;&lt; i) != l {
</span><span class="boring">                    self.push(l &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">                if ((r &gt;&gt; i) &lt;&lt; i) != r {
</span><span class="boring">                    self.push((r - 1) &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (l2, r2) = (l, r);
</span><span class="boring">            while l &lt; r {
</span><span class="boring">                if l &amp; 1 == 1 {
</span><span class="boring">                    self.all_apply(l, f);
</span><span class="boring">                    l += 1;
</span><span class="boring">                }
</span><span class="boring">                if r &amp; 1 == 1 {
</span><span class="boring">                    r -= 1;
</span><span class="boring">                    self.all_apply(r, f);
</span><span class="boring">                }
</span><span class="boring">                l &gt;&gt;= 1;
</span><span class="boring">                r &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">            l = l2;
</span><span class="boring">            r = r2;
</span><span class="boring">
</span><span class="boring">            for i in 1..=self.log {
</span><span class="boring">                if ((l &gt;&gt; i) &lt;&lt; i) != l {
</span><span class="boring">                    self.update(l &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">                if ((r &gt;&gt; i) &lt;&lt; i) != r {
</span><span class="boring">                    self.update((r - 1) &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn max_right(&amp;mut self, l: usize, g: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
</span><span class="boring">            if l == self.n {
</span><span class="boring">                return self.n;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut l = l + self.size;
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                self.push(l &gt;&gt; i);
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut sm = S::e();
</span><span class="boring">            loop {
</span><span class="boring">                l &gt;&gt;= l.trailing_zeros();
</span><span class="boring">                if !g(&amp;S::opr(&amp;sm, &amp;self.data[l])) {
</span><span class="boring">                    while l &lt; self.size {
</span><span class="boring">                        self.push(l);
</span><span class="boring">                        l &lt;&lt;= 1;
</span><span class="boring">                        let tmp = S::opr(&amp;sm, &amp;self.data[l]);
</span><span class="boring">                        if g(&amp;tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            l += 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return l - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm.opr_lhs(&amp;self.data[l]);
</span><span class="boring">                l += 1;
</span><span class="boring">
</span><span class="boring">                if l &amp; ((!l) + 1) != l {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            self.n
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn min_left(&amp;mut self, r: usize, g: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
</span><span class="boring">            if r == 0 {
</span><span class="boring">                return 0;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut r = r + self.size;
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                self.push((r - 1) &gt;&gt; i);
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut sm = S::e();
</span><span class="boring">            loop {
</span><span class="boring">                r -= 1;
</span><span class="boring">                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
</span><span class="boring">                    r &gt;&gt;= 1;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                if !g(&amp;S::opr(&amp;self.data[r], &amp;sm)) {
</span><span class="boring">                    while r &lt; self.size {
</span><span class="boring">                        self.push(r);
</span><span class="boring">                        r = (r &lt;&lt; 1) + 1;
</span><span class="boring">                        let tmp = S::opr(&amp;self.data[r], &amp;sm);
</span><span class="boring">                        if g(&amp;tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            r -= 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return r + 1 - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm.opr_rhs(&amp;self.data[r]);
</span><span class="boring">
</span><span class="boring">                if r &amp; ((!r) + 1) == r {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            0
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-9"><a class="header" href="#code-9">Code</a></h2>
<pre><code class="language-rust noplayground">mod lazyseg {
    use std::ops::RangeBounds;

    fn ceil_pow2(n: usize) -&gt; u32 {
        let mut x = 0;
        while 1 &lt;&lt; x &lt; n {
            x += 1;
        }
        x
    }

    fn range_to_bounds(n: usize, range: impl RangeBounds&lt;usize&gt;) -&gt; (usize, usize) {
        use std::ops::Bound::*;

        let l = match range.start_bound() {
            Included(&amp;v) =&gt; v,
            Excluded(&amp;v) =&gt; v + 1,
            Unbounded =&gt; 0,
        };

        let r = match range.end_bound() {
            Included(&amp;v) =&gt; v + 1,
            Excluded(&amp;v) =&gt; v,
            Unbounded =&gt; n,
        };

        (l, r)
    }

    pub trait LzMonoid: Sized {
        fn e() -&gt; Self;
        fn opr_lhs(&amp;mut self, rhs: &amp;Self);
        fn opr_rhs(&amp;mut self, lhs: &amp;Self);
        fn opr(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
            let mut ret = Self::e();
            ret.opr_rhs(lhs);
            ret.opr_lhs(rhs);
            ret
        }
        fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
            *self = Self::opr(lhs, rhs);
        }
    }

    pub trait LzMap&lt;S&gt;: Sized {
        fn id() -&gt; Self;
        fn map(&amp;self, apply: &amp;mut S);
        fn compos_lhs(&amp;mut self, rhs: &amp;Self);
        fn compos_rhs(&amp;mut self, lhs: &amp;Self);
        fn compos(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
            let mut ret = Self::id();
            ret.compos_rhs(lhs);
            ret.compos_lhs(rhs);
            ret
        }
        fn opr_self(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
            *self = Self::compos(lhs, rhs);
        }
    }

    pub struct LazySeg&lt;S, F&gt; {
        n: usize,
        size: usize,
        log: u32,
        data: Vec&lt;S&gt;,
        lazy: Vec&lt;F&gt;,
    }

    impl&lt;S, F&gt; LazySeg&lt;S, F&gt;
    where
        S: LzMonoid,
        F: LzMap&lt;S&gt;,
    {
        fn update(&amp;mut self, k: usize) {
            let val = S::opr(&amp;self.data[k &lt;&lt; 1], &amp;self.data[(k &lt;&lt; 1) + 1]);
            self.data[k] = val;
        }

        fn all_apply(&amp;mut self, k: usize, f: &amp;F) {
            f.map(&amp;mut self.data[k]);
            if k &lt; self.size {
                self.lazy[k].compos_rhs(f);
            }
        }

        fn all_apply_unsafe(size: usize, k: usize, f: usize, data: &amp;mut [S], lazy: &amp;mut [F]) {
            // f &lt; k
            lazy[f].map(&amp;mut data[k]);
            if k &lt; size {
                let (fs, ks) = lazy.split_at_mut(k);
                ks[0].compos_rhs(&amp;fs[f]);
            }
        }

        fn push(&amp;mut self, k: usize) {
            Self::all_apply_unsafe(self.size, k &lt;&lt; 1, k, &amp;mut self.data, &amp;mut self.lazy);
            Self::all_apply_unsafe(self.size, (k &lt;&lt; 1) + 1, k, &amp;mut self.data, &amp;mut self.lazy);
            self.lazy[k] = F::id();
        }

        pub fn new(arr: Vec&lt;S&gt;) -&gt; Self {
            let n = arr.len();
            let log = ceil_pow2(n);
            let size = 1 &lt;&lt; log;
            let stsize = 1 &lt;&lt; (log + 1);

            let mut data = Vec::with_capacity(stsize);
            data.extend((0..size).map(|_| S::e()));
            data.extend(arr.into_iter());
            data.extend((data.len()..stsize).map(|_| S::e()));

            let mut ls = Self {
                n,
                log,
                size,
                data,
                lazy: Vec::from_iter((0..size).map(|_| F::id())),
            };
            for i in (1..size).rev() {
                ls.update(i);
            }
            ls
        }

        pub fn set(&amp;mut self, i: usize, v: S) {
            let i = i + self.size;
            for j in (1..=self.log).rev() {
                self.push(i &gt;&gt; j);
            }
            self.data[i] = v;
            for j in 1..=self.log {
                self.update(i &gt;&gt; j);
            }
        }

        pub fn get(&amp;mut self, i: usize) -&gt; &amp;S {
            let i = i + self.size;
            for j in (1..=self.log).rev() {
                self.push(i &gt;&gt; j);
            }
            &amp;self.data[i]
        }

        pub fn prod(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; S {
            let (l, r) = range_to_bounds(self.size, range);

            if l == 0 &amp;&amp; r == self.size {
                let mut ret = S::e();
                ret.opr_lhs(&amp;self.data[1]);
                return ret;
            } else if l == r {
                return S::e();
            }

            let (mut l, mut r) = (l + self.size, r + self.size);

            for i in (1..=self.log).rev() {
                if ((l &gt;&gt; i) &lt;&lt; i) != l {
                    self.push(l &gt;&gt; i);
                }
                if ((r &gt;&gt; i) &lt;&lt; i) != r {
                    self.push((r - 1) &gt;&gt; i);
                }
            }

            let (mut sml, mut smr) = (S::e(), S::e());
            while l &lt; r {
                if l &amp; 1 == 1 {
                    sml.opr_lhs(&amp;self.data[l]);
                    l += 1;
                }
                if r &amp; 1 == 1 {
                    r -= 1;
                    smr.opr_rhs(&amp;self.data[r]);
                }
                l &gt;&gt;= 1;
                r &gt;&gt;= 1;
            }

            S::opr(&amp;sml, &amp;smr)
        }

        pub fn apply(&amp;mut self, i: usize, f: &amp;F) {
            let i = i + self.size;
            for j in (1..=self.log).rev() {
                self.push(i &gt;&gt; j);
            }
            f.map(&amp;mut self.data[i]);
            for j in 1..=self.log {
                self.update(i &gt;&gt; j);
            }
        }

        pub fn apply_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;, f: &amp;F) {
            let (l, r) = range_to_bounds(self.size, range);

            if l == r {
                return;
            }

            let (mut l, mut r) = (l + self.size, r + self.size);

            for i in (1..=self.log).rev() {
                if ((l &gt;&gt; i) &lt;&lt; i) != l {
                    self.push(l &gt;&gt; i);
                }
                if ((r &gt;&gt; i) &lt;&lt; i) != r {
                    self.push((r - 1) &gt;&gt; i);
                }
            }

            let (l2, r2) = (l, r);
            while l &lt; r {
                if l &amp; 1 == 1 {
                    self.all_apply(l, f);
                    l += 1;
                }
                if r &amp; 1 == 1 {
                    r -= 1;
                    self.all_apply(r, f);
                }
                l &gt;&gt;= 1;
                r &gt;&gt;= 1;
            }
            l = l2;
            r = r2;

            for i in 1..=self.log {
                if ((l &gt;&gt; i) &lt;&lt; i) != l {
                    self.update(l &gt;&gt; i);
                }
                if ((r &gt;&gt; i) &lt;&lt; i) != r {
                    self.update((r - 1) &gt;&gt; i);
                }
            }
        }

        pub fn max_right(&amp;mut self, l: usize, g: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
            if l == self.n {
                return self.n;
            }

            let mut l = l + self.size;
            for i in (1..=self.log).rev() {
                self.push(l &gt;&gt; i);
            }

            let mut sm = S::e();
            loop {
                l &gt;&gt;= l.trailing_zeros();
                if !g(&amp;S::opr(&amp;sm, &amp;self.data[l])) {
                    while l &lt; self.size {
                        self.push(l);
                        l &lt;&lt;= 1;
                        let tmp = S::opr(&amp;sm, &amp;self.data[l]);
                        if g(&amp;tmp) {
                            sm = tmp;
                            l += 1;
                        }
                    }
                    return l - self.size;
                }
                sm.opr_lhs(&amp;self.data[l]);
                l += 1;

                if l &amp; ((!l) + 1) != l {
                    break;
                }
            }

            self.n
        }

        pub fn min_left(&amp;mut self, r: usize, g: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
            if r == 0 {
                return 0;
            }

            let mut r = r + self.size;
            for i in (1..=self.log).rev() {
                self.push((r - 1) &gt;&gt; i);
            }

            let mut sm = S::e();
            loop {
                r -= 1;
                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                    r &gt;&gt;= 1;
                }

                if !g(&amp;S::opr(&amp;self.data[r], &amp;sm)) {
                    while r &lt; self.size {
                        self.push(r);
                        r = (r &lt;&lt; 1) + 1;
                        let tmp = S::opr(&amp;self.data[r], &amp;sm);
                        if g(&amp;tmp) {
                            sm = tmp;
                            r -= 1;
                        }
                    }
                    return r + 1 - self.size;
                }
                sm.opr_rhs(&amp;self.data[r]);

                if r &amp; ((!r) + 1) == r {
                    break;
                }
            }

            0
        }
    }
}</code></pre>
<h2 id="apis-1"><a class="header" href="#apis-1">APIs</a></h2>
<p>Will be done soon. For <code>max_right</code> and <code>min_left</code>, either check the explanation from <a href="datastructure/segtree/./segtree.html#apis">the segment tree documentation</a>, or see the below mathematical definitions (which will be replaced with better explanation).</p>
<h3 id="max_right"><a class="header" href="#max_right"><code>max_right</code></a></h3>
<p>Given an index \(l\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(r=l\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(r=n\) or \( f \left( A_l \cdot A_{l+1} \cdots A_r \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the maximum \(r\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq l \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(r\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<h3 id="min_left"><a class="header" href="#min_left"><code>min_left</code></a></h3>
<p>Given an index \(r\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(l\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(l=r\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(l=0\) or \( f \left( A_{l-1} \cdot A_l \cdots A_{r-1} \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the minimum \(l\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq r \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(l\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rope"><a class="header" href="#rope">Rope</a></h1>
<p>Rope acts as if it is a list, but inserting a value at an arbitrary position takes time complexity of amortized \( O(\log{N}) \). However, accessing values also takes amortized \( O(\log{x}) \) time. Building a rope from an iterator takes \( O(N) \).</p>
<h2 id="example-11"><a class="header" href="#example-11">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>use rope::Rope;

let mut arr: Rope&lt;i32&gt; = (0..10).collect();
println!(&quot;{:?}&quot;, arr);

let out = arr.take_range(1..5).unwrap();
arr.merge_right(out);
println!(&quot;{:?}&quot;, arr);

for i in 11..100000 {
    let n = arr.len() / 2;
    arr.insert(n, i);
}
println!(&quot;{}&quot;, arr[50000]);

for _ in 0..arr.len() - 10 {
    let n = arr.len() / 2;
    arr.remove(n + 1);
}
println!(&quot;{:?}&quot;, arr);
<span class="boring">}
</span><span class="boring">mod rope {
</span><span class="boring">    use std::{
</span><span class="boring">        cmp::Ordering,
</span><span class="boring">        fmt::{Debug, Display},
</span><span class="boring">        ops::{Bound::*, Index, IndexMut, RangeBounds},
</span><span class="boring">        ptr::{self, NonNull},
</span><span class="boring">        iter::FromIterator,
</span><span class="boring">    };
</span><span class="boring">    pub struct Node&lt;T&gt; {
</span><span class="boring">        data: T,
</span><span class="boring">        subt: usize,
</span><span class="boring">        l: Link&lt;T&gt;,
</span><span class="boring">        r: Link&lt;T&gt;,
</span><span class="boring">        p: Link&lt;T&gt;,
</span><span class="boring">    }
</span><span class="boring">    type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">    impl&lt;T&gt; Node&lt;T&gt; {
</span><span class="boring">        fn new(data: T) -&gt; Self {
</span><span class="boring">            Node {
</span><span class="boring">                data,
</span><span class="boring">                subt: 1,
</span><span class="boring">                l: None,
</span><span class="boring">                r: None,
</span><span class="boring">                p: None,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn left_size(&amp;self) -&gt; usize {
</span><span class="boring">            unsafe { self.l.map_or(0, |l| (*l.as_ptr()).subt) }
</span><span class="boring">        }
</span><span class="boring">        fn right_size(&amp;self) -&gt; usize {
</span><span class="boring">            unsafe { self.r.map_or(0, |r| (*r.as_ptr()).subt) }
</span><span class="boring">        }
</span><span class="boring">        fn upd_subtree(&amp;mut self) {
</span><span class="boring">            self.subt = 1 + self.left_size() + self.right_size();
</span><span class="boring">        }
</span><span class="boring">        // Option&lt;(is_left, parent)&gt;
</span><span class="boring">        unsafe fn is_left_child(x: NonNull&lt;Self&gt;) -&gt; Option&lt;(bool, NonNull&lt;Self&gt;)&gt; {
</span><span class="boring">            if let Some(p) = (*x.as_ptr()).p {
</span><span class="boring">                if (*p.as_ptr())
</span><span class="boring">                    .l
</span><span class="boring">                    .map_or(false, |pl| ptr::eq(x.as_ptr(), pl.as_ptr()))
</span><span class="boring">                {
</span><span class="boring">                    Some((true, p))
</span><span class="boring">                } else {
</span><span class="boring">                    Some((false, p))
</span><span class="boring">                }
</span><span class="boring">            } else {
</span><span class="boring">                None
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct Rope&lt;T&gt; {
</span><span class="boring">        root: Link&lt;T&gt;,
</span><span class="boring">        size: usize,
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Default for Rope&lt;T&gt; {
</span><span class="boring">        fn default() -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                root: None,
</span><span class="boring">                size: 0,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Rope&lt;T&gt; {
</span><span class="boring">        pub fn new() -&gt; Self {
</span><span class="boring">            Self::default()
</span><span class="boring">        }
</span><span class="boring">        pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">            self.size
</span><span class="boring">        }
</span><span class="boring">        pub fn insert(&amp;mut self, idx: usize, data: T) {
</span><span class="boring">            debug_assert!(idx &lt;= self.size);
</span><span class="boring">            unsafe {
</span><span class="boring">                let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));
</span><span class="boring">                if let Some(r) = self.root {
</span><span class="boring">                    let idx = self.kth_ptr(idx);
</span><span class="boring">                    if let Some(idx) = idx {
</span><span class="boring">                        // idx_node is the node which new_node should replace
</span><span class="boring">                        // &quot;Replace&quot; means the new_node should be placed right before the idx_node
</span><span class="boring">                        if let Some(l) = (*idx.as_ptr()).l {
</span><span class="boring">                            // Attach at the right of rightmost node from l
</span><span class="boring">                            let mut p = l;
</span><span class="boring">                            while let Some(r) = (*p.as_ptr()).r {
</span><span class="boring">                                p = r;
</span><span class="boring">                            }
</span><span class="boring">                            // Attach new_node to the right of p
</span><span class="boring">                            (*new_node.as_ptr()).p = Some(p);
</span><span class="boring">                            (*p.as_ptr()).r = Some(new_node);
</span><span class="boring">                        } else {
</span><span class="boring">                            // Attach it right away
</span><span class="boring">                            let p = idx;
</span><span class="boring">                            (*new_node.as_ptr()).p = Some(p);
</span><span class="boring">                            (*p.as_ptr()).l = Some(new_node);
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // idx == self.size
</span><span class="boring">                        // new_node goes to the rightmost of the tree
</span><span class="boring">                        let mut p = r;
</span><span class="boring">                        while let Some(r) = (*p.as_ptr()).r {
</span><span class="boring">                            p = r;
</span><span class="boring">                        }
</span><span class="boring">                        // Attach new_node to the right of p
</span><span class="boring">                        (*new_node.as_ptr()).p = Some(p);
</span><span class="boring">                        (*p.as_ptr()).r = Some(new_node);
</span><span class="boring">                    }
</span><span class="boring">                    let mut c = new_node;
</span><span class="boring">                    while let Some(p) = (*c.as_ptr()).p {
</span><span class="boring">                        c = p;
</span><span class="boring">                        (*c.as_ptr()).upd_subtree();
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    self.root = Some(new_node);
</span><span class="boring">                }
</span><span class="boring">                self.splay(new_node);
</span><span class="boring">                self.size += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        pub fn remove(&amp;mut self, idx: usize) -&gt; Option&lt;T&gt; {
</span><span class="boring">            if idx &gt;= self.size {
</span><span class="boring">                return None;
</span><span class="boring">            }
</span><span class="boring">            let data: T = unsafe {
</span><span class="boring">                if let Some(mut rt) = self.kth_ptr(idx) {
</span><span class="boring">                    rt = self.remove_helper(rt);
</span><span class="boring">                    if let Some(rp) = (*rt.as_ptr()).p {
</span><span class="boring">                        self.splay(rp);
</span><span class="boring">                    }
</span><span class="boring">                    let retr = Box::from_raw(rt.as_ptr());
</span><span class="boring">                    retr.data
</span><span class="boring">                } else {
</span><span class="boring">                    unreachable!()
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">            self.size -= 1;
</span><span class="boring">            Some(data)
</span><span class="boring">        }
</span><span class="boring">        pub fn push_front(&amp;mut self, data: T) {
</span><span class="boring">            self.insert(0, data);
</span><span class="boring">        }
</span><span class="boring">        pub fn push_back(&amp;mut self, data: T) {
</span><span class="boring">            self.insert(self.size, data);
</span><span class="boring">        }
</span><span class="boring">        pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">            self.remove(0)
</span><span class="boring">        }
</span><span class="boring">        pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">            self.remove(self.size - 1)
</span><span class="boring">        }
</span><span class="boring">        /// Splits out the rope, leaving self[..at] and returning self[at..].
</span><span class="boring">        /// If the index is invalid, it returns None.
</span><span class="boring">        pub fn take_right(&amp;mut self, right_start: usize) -&gt; Option&lt;Self&gt; {
</span><span class="boring">            let rhs = unsafe {
</span><span class="boring">                if right_start == 0 {
</span><span class="boring">                    let rhs = Self {
</span><span class="boring">                        root: self.root,
</span><span class="boring">                        size: self.size,
</span><span class="boring">                    };
</span><span class="boring">                    self.root = None;
</span><span class="boring">                    self.size = 0;
</span><span class="boring">                    rhs
</span><span class="boring">                } else {
</span><span class="boring">                    let root = self.kth_ptr(right_start - 1)?;
</span><span class="boring">                    self.splay(root);
</span><span class="boring">                    if let Some(r) = (*root.as_ptr()).r {
</span><span class="boring">                        (*root.as_ptr()).r = None;
</span><span class="boring">                        (*r.as_ptr()).p = None;
</span><span class="boring">                        (*root.as_ptr()).upd_subtree();
</span><span class="boring">                        self.size = (*root.as_ptr()).subt;
</span><span class="boring">                        Self {
</span><span class="boring">                            root: Some(r),
</span><span class="boring">                            size: (*r.as_ptr()).subt,
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        Self {
</span><span class="boring">                            root: None,
</span><span class="boring">                            size: 0,
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">            Some(rhs)
</span><span class="boring">        }
</span><span class="boring">        /// Splits out the rope and returns self[..at] and self[at..].
</span><span class="boring">        /// If the index is invalid, it returns None.
</span><span class="boring">        pub fn split_at(mut self, at: usize) -&gt; Option&lt;(Self, Self)&gt; {
</span><span class="boring">            let rhs = self.take_right(at)?;
</span><span class="boring">            Some((self, rhs))
</span><span class="boring">        }
</span><span class="boring">        /// Takes out the range from the rope.
</span><span class="boring">        /// Returns None if the index is invalid.
</span><span class="boring">        pub fn take_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; Option&lt;Self&gt; {
</span><span class="boring">            let l = match range.start_bound() {
</span><span class="boring">                Included(&amp;l) =&gt; l,
</span><span class="boring">                Excluded(&amp;l) =&gt; l + 1,
</span><span class="boring">                Unbounded =&gt; 0,
</span><span class="boring">            };
</span><span class="boring">            let r = match range.end_bound() {
</span><span class="boring">                Included(&amp;r) =&gt; r + 1,
</span><span class="boring">                Excluded(&amp;r) =&gt; r,
</span><span class="boring">                Unbounded =&gt; self.size,
</span><span class="boring">            };
</span><span class="boring">            if l &gt; r || l &gt; self.size || r &gt; self.size {
</span><span class="boring">                return None;
</span><span class="boring">            }
</span><span class="boring">            // Now the operations below never ends early
</span><span class="boring">            let c = self.take_right(r)?;
</span><span class="boring">            let b = self.take_right(l)?;
</span><span class="boring">            self.merge_right(c);
</span><span class="boring">            Some(b)
</span><span class="boring">        }
</span><span class="boring">        pub fn merge_right(&amp;mut self, mut rhs: Self) {
</span><span class="boring">            if self.len() == 0 {
</span><span class="boring">                self.root = rhs.root;
</span><span class="boring">                self.size = rhs.size;
</span><span class="boring">            } else {
</span><span class="boring">                unsafe {
</span><span class="boring">                    let rmost = self.kth_ptr(self.size - 1).unwrap();
</span><span class="boring">                    self.splay(rmost);
</span><span class="boring">                    (*rmost.as_ptr()).r = rhs.root;
</span><span class="boring">                    if let Some(rhs_root) = rhs.root {
</span><span class="boring">                        (*rhs_root.as_ptr()).p = Some(rmost);
</span><span class="boring">                    }
</span><span class="boring">                    (*rmost.as_ptr()).upd_subtree();
</span><span class="boring">                    self.size = (*rmost.as_ptr()).subt;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            rhs.root = None;
</span><span class="boring">            rhs.size = 0;
</span><span class="boring">        }
</span><span class="boring">        pub fn merge_left(&amp;mut self, mut lhs: Self) {
</span><span class="boring">            if self.len() == 0 {
</span><span class="boring">                self.root = lhs.root;
</span><span class="boring">                self.size = lhs.size;
</span><span class="boring">            } else {
</span><span class="boring">                unsafe {
</span><span class="boring">                    let lmost = self.kth_ptr(0).unwrap();
</span><span class="boring">                    self.splay(lmost);
</span><span class="boring">                    (*lmost.as_ptr()).l = lhs.root;
</span><span class="boring">                    if let Some(lhs_root) = lhs.root {
</span><span class="boring">                        (*lhs_root.as_ptr()).p = Some(lmost);
</span><span class="boring">                    }
</span><span class="boring">                    (*lmost.as_ptr()).upd_subtree();
</span><span class="boring">                    self.size = (*lmost.as_ptr()).subt;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            lhs.root = None;
</span><span class="boring">            lhs.size = 0;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T: Debug&gt; Debug for Rope&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">            write!(f, &quot;[&quot;)?;
</span><span class="boring">            let mut cnt: usize = 0;
</span><span class="boring">            unsafe {
</span><span class="boring">                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
</span><span class="boring">                let mut curr = self.root;
</span><span class="boring">                loop {
</span><span class="boring">                    while let Some(x) = curr {
</span><span class="boring">                        stack.push(x.as_ptr());
</span><span class="boring">                        curr = (*x.as_ptr()).l;
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(x) = stack.pop() {
</span><span class="boring">                        if cnt == 0 {
</span><span class="boring">                            write!(f, &quot;{:?}&quot;, (*x).data)?;
</span><span class="boring">                        } else {
</span><span class="boring">                            write!(f, &quot;, {:?}&quot;, (*x).data)?;
</span><span class="boring">                        }
</span><span class="boring">                        cnt += 1;
</span><span class="boring">                        curr = (*x).r;
</span><span class="boring">                    } else {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            write!(f, &quot;]&quot;)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T: Display&gt; Display for Rope&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">            unsafe {
</span><span class="boring">                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
</span><span class="boring">                let mut curr = self.root;
</span><span class="boring">                loop {
</span><span class="boring">                    while let Some(x) = curr {
</span><span class="boring">                        stack.push(x.as_ptr());
</span><span class="boring">                        curr = (*x.as_ptr()).l;
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(x) = stack.pop() {
</span><span class="boring">                        write!(f, &quot;{}&quot;, (*x).data)?;
</span><span class="boring">                        curr = (*x).r;
</span><span class="boring">                    } else {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Drop for Rope&lt;T&gt; {
</span><span class="boring">        fn drop(&amp;mut self) {
</span><span class="boring">            if let Some(root) = self.root {
</span><span class="boring">                unsafe {
</span><span class="boring">                    let mut st: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
</span><span class="boring">                    st.push(root.as_ptr());
</span><span class="boring">                    while let Some(t) = st.pop() {
</span><span class="boring">                        let v = Box::from_raw(t);
</span><span class="boring">                        if let Some(l) = v.l {
</span><span class="boring">                            st.push(l.as_ptr());
</span><span class="boring">                        }
</span><span class="boring">                        if let Some(r) = v.r {
</span><span class="boring">                            st.push(r.as_ptr());
</span><span class="boring">                        }
</span><span class="boring">                        // retrieve.drop()
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Index&lt;usize&gt; for Rope&lt;T&gt; {
</span><span class="boring">        type Output = T;
</span><span class="boring">        fn index(&amp;self, idx: usize) -&gt; &amp;Self::Output {
</span><span class="boring">            unsafe {
</span><span class="boring">                let p = self.kth_ptr(idx);
</span><span class="boring">                &amp;(*p.unwrap().as_ptr()).data
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; IndexMut&lt;usize&gt; for Rope&lt;T&gt; {
</span><span class="boring">        fn index_mut(&amp;mut self, idx: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">            unsafe {
</span><span class="boring">                let p = self.kth_ptr(idx);
</span><span class="boring">                &amp;mut (*p.unwrap().as_ptr()).data
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; FromIterator&lt;T&gt; for Rope&lt;T&gt; {
</span><span class="boring">        fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {
</span><span class="boring">            let mut arr = Self::new();
</span><span class="boring">            for v in iter {
</span><span class="boring">                unsafe { arr.push_ontop_root(v) };
</span><span class="boring">            }
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    //------------------------
</span><span class="boring">    // Helper implementations
</span><span class="boring">    //------------------------
</span><span class="boring">    impl&lt;T&gt; Rope&lt;T&gt; {
</span><span class="boring">        /// Adds data as a new root of a rope, and putting the original root
</span><span class="boring">        /// as a left child of the root.
</span><span class="boring">        unsafe fn push_ontop_root(&amp;mut self, data: T) {
</span><span class="boring">            let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));
</span><span class="boring">            if let Some(root) = self.root {
</span><span class="boring">                (*root.as_ptr()).p = Some(new_node);
</span><span class="boring">                (*new_node.as_ptr()).l = Some(root);
</span><span class="boring">            }
</span><span class="boring">            self.root = Some(new_node);
</span><span class="boring">            (*new_node.as_ptr()).upd_subtree();
</span><span class="boring">            self.size += 1;
</span><span class="boring">        }
</span><span class="boring">        /// Returns false if x has no parent, and do nothing
</span><span class="boring">        /// Returns true if x has a parent, after performing rotation
</span><span class="boring">        unsafe fn rotate(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; bool {
</span><span class="boring">            if let Some((is_x_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                // Check if p is root
</span><span class="boring">                if let Some(root) = self.root {
</span><span class="boring">                    if ptr::eq(root.as_ptr(), p.as_ptr()) {
</span><span class="boring">                        self.root = Some(x);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                // Connect x to xpp. If pp is None, do nothing.
</span><span class="boring">                (*x.as_ptr()).p = (*p.as_ptr()).p;
</span><span class="boring">                if let Some((is_p_left, pp)) = Node::is_left_child(p) {
</span><span class="boring">                    if is_p_left {
</span><span class="boring">                        (*pp.as_ptr()).l = Some(x);
</span><span class="boring">                    } else {
</span><span class="boring">                        (*pp.as_ptr()).r = Some(x);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                if is_x_left {
</span><span class="boring">                    let b = (*x.as_ptr()).r;
</span><span class="boring">                    (*x.as_ptr()).r = Some(p);
</span><span class="boring">                    (*p.as_ptr()).p = Some(x);
</span><span class="boring">                    (*p.as_ptr()).l = b;
</span><span class="boring">                    if let Some(b) = b {
</span><span class="boring">                        (*b.as_ptr()).p = Some(p);
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    let b = (*x.as_ptr()).l;
</span><span class="boring">                    (*x.as_ptr()).l = Some(p);
</span><span class="boring">                    (*p.as_ptr()).p = Some(x);
</span><span class="boring">                    (*p.as_ptr()).r = b;
</span><span class="boring">                    if let Some(b) = b {
</span><span class="boring">                        (*b.as_ptr()).p = Some(p);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                (*p.as_ptr()).upd_subtree();
</span><span class="boring">                (*x.as_ptr()).upd_subtree();
</span><span class="boring">                true
</span><span class="boring">            } else {
</span><span class="boring">                false
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn splay(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) {
</span><span class="boring">            unsafe {
</span><span class="boring">                while let Some(root) = self.root {
</span><span class="boring">                    if ptr::eq(x.as_ptr(), root.as_ptr()) {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), p.as_ptr()) {
</span><span class="boring">                            // If p is root, rotate x once
</span><span class="boring">                            self.rotate(x);
</span><span class="boring">                        } else {
</span><span class="boring">                            // Panics if pp doesn't exist, which happens only when p is root
</span><span class="boring">                            let (is_p_left, _pp) = Node::is_left_child(p).unwrap();
</span><span class="boring">                            if is_x_left == is_p_left {
</span><span class="boring">                                self.rotate(p);
</span><span class="boring">                                self.rotate(x);
</span><span class="boring">                            } else {
</span><span class="boring">                                self.rotate(x);
</span><span class="boring">                                self.rotate(x);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // x has no parent, which should logically never happen
</span><span class="boring">                        unreachable!()
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        unsafe fn kth_ptr(&amp;self, idx: usize) -&gt; Link&lt;T&gt; {
</span><span class="boring">            if self.size &lt;= idx {
</span><span class="boring">                return None;
</span><span class="boring">            }
</span><span class="boring">            if let Some(r) = self.root {
</span><span class="boring">                let mut rem = idx;
</span><span class="boring">                let mut p = r;
</span><span class="boring">                loop {
</span><span class="boring">                    let lsize = (*p.as_ptr()).left_size();
</span><span class="boring">                    match rem.cmp(&amp;lsize) {
</span><span class="boring">                        Ordering::Less =&gt; {
</span><span class="boring">                            p = (*p.as_ptr()).l?;
</span><span class="boring">                        }
</span><span class="boring">                        Ordering::Equal =&gt; {
</span><span class="boring">                            break;
</span><span class="boring">                        }
</span><span class="boring">                        Ordering::Greater =&gt; {
</span><span class="boring">                            rem -= lsize + 1;
</span><span class="boring">                            p = (*p.as_ptr()).r?;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                Some(p)
</span><span class="boring">            } else {
</span><span class="boring">                None
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        unsafe fn remove_helper(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; NonNull&lt;Node&lt;T&gt;&gt; {
</span><span class="boring">            // Set remove_target to the actual node to delete
</span><span class="boring">            match ((*x.as_ptr()).l, ((*x.as_ptr()).r)) {
</span><span class="boring">                (None, None) =&gt; {
</span><span class="boring">                    // Reset root if the node itself is root
</span><span class="boring">                    if let Some(root) = self.root {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
</span><span class="boring">                            self.root = None;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // Detatch itself from parent
</span><span class="boring">                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if is_x_left {
</span><span class="boring">                            (*p.as_ptr()).l = None;
</span><span class="boring">                        } else {
</span><span class="boring">                            (*p.as_ptr()).r = None;
</span><span class="boring">                        }
</span><span class="boring">                        // Update subtree size
</span><span class="boring">                        let mut p = p;
</span><span class="boring">                        (*p.as_ptr()).upd_subtree();
</span><span class="boring">                        while let Some(pp) = (*p.as_ptr()).p {
</span><span class="boring">                            p = pp;
</span><span class="boring">                            (*p.as_ptr()).upd_subtree();
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    x
</span><span class="boring">                }
</span><span class="boring">                (Some(l), None) =&gt; {
</span><span class="boring">                    // Reset root if the node itself is a root
</span><span class="boring">                    if let Some(root) = self.root {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
</span><span class="boring">                            self.root = Some(l);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    (*l.as_ptr()).p = (*x.as_ptr()).p;
</span><span class="boring">                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if is_rt_left {
</span><span class="boring">                            (*p.as_ptr()).l = Some(l);
</span><span class="boring">                        } else {
</span><span class="boring">                            (*p.as_ptr()).r = Some(l);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    let mut p = l;
</span><span class="boring">                    while let Some(pp) = (*p.as_ptr()).p {
</span><span class="boring">                        p = pp;
</span><span class="boring">                        (*p.as_ptr()).upd_subtree();
</span><span class="boring">                    }
</span><span class="boring">                    x
</span><span class="boring">                }
</span><span class="boring">                (None, Some(r)) =&gt; {
</span><span class="boring">                    // Reset root if the node itself is a root
</span><span class="boring">                    if let Some(root) = self.root {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
</span><span class="boring">                            self.root = Some(r);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    (*r.as_ptr()).p = (*x.as_ptr()).p;
</span><span class="boring">                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if is_rt_left {
</span><span class="boring">                            (*p.as_ptr()).l = Some(r);
</span><span class="boring">                        } else {
</span><span class="boring">                            (*p.as_ptr()).r = Some(r);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    let mut p = r;
</span><span class="boring">                    while let Some(pp) = (*p.as_ptr()).p {
</span><span class="boring">                        p = pp;
</span><span class="boring">                        (*p.as_ptr()).upd_subtree();
</span><span class="boring">                    }
</span><span class="boring">                    x
</span><span class="boring">                }
</span><span class="boring">                (Some(l), Some(_)) =&gt; {
</span><span class="boring">                    let mut sw = l;
</span><span class="boring">                    while let Some(sr) = (*sw.as_ptr()).r {
</span><span class="boring">                        sw = sr;
</span><span class="boring">                    }
</span><span class="boring">                    std::mem::swap(&amp;mut (*x.as_ptr()).data, &amp;mut (*sw.as_ptr()).data);
</span><span class="boring">                    sw = self.remove_helper(sw);
</span><span class="boring">                    sw
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    //-----------
</span><span class="boring">    // Iterators
</span><span class="boring">    //-----------
</span><span class="boring">    impl&lt;T&gt; Rope&lt;T&gt; {
</span><span class="boring">        pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
</span><span class="boring">            Iter::new(self)
</span><span class="boring">        }
</span><span class="boring">        pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
</span><span class="boring">            IterMut::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct Iter&lt;'a, T&gt; {
</span><span class="boring">        rope: &amp;'a Rope&lt;T&gt;,
</span><span class="boring">        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
</span><span class="boring">        curr: Link&lt;T&gt;,
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
</span><span class="boring">        fn new(rope: &amp;'a Rope&lt;T&gt;) -&gt; Self {
</span><span class="boring">            let root = rope.root;
</span><span class="boring">            Self {
</span><span class="boring">                rope,
</span><span class="boring">                stack: Vec::new(),
</span><span class="boring">                curr: root,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; IntoIterator for &amp;'a Rope&lt;T&gt; {
</span><span class="boring">        type Item = &amp;'a T;
</span><span class="boring">        type IntoIter = Iter&lt;'a, T&gt;;
</span><span class="boring">        fn into_iter(self) -&gt; Self::IntoIter {
</span><span class="boring">            Self::IntoIter::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
</span><span class="boring">        type Item = &amp;'a T;
</span><span class="boring">        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">            unsafe {
</span><span class="boring">                while let Some(x) = self.curr {
</span><span class="boring">                    self.stack.push(x);
</span><span class="boring">                    self.curr = (*x.as_ptr()).l;
</span><span class="boring">                }
</span><span class="boring">                if let Some(x) = self.stack.pop() {
</span><span class="boring">                    self.curr = (*x.as_ptr()).r;
</span><span class="boring">                    Some(&amp;x.as_ref().data)
</span><span class="boring">                } else {
</span><span class="boring">                    None
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
</span><span class="boring">            (self.rope.len(), Some(self.rope.len()))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct IterMut&lt;'a, T&gt; {
</span><span class="boring">        rope: &amp;'a mut Rope&lt;T&gt;,
</span><span class="boring">        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
</span><span class="boring">        curr: Link&lt;T&gt;,
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; IterMut&lt;'a, T&gt; {
</span><span class="boring">        fn new(rope: &amp;'a mut Rope&lt;T&gt;) -&gt; Self {
</span><span class="boring">            let root = rope.root;
</span><span class="boring">            Self {
</span><span class="boring">                rope,
</span><span class="boring">                stack: Vec::new(),
</span><span class="boring">                curr: root,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Rope&lt;T&gt; {
</span><span class="boring">        type Item = &amp;'a mut T;
</span><span class="boring">        type IntoIter = IterMut&lt;'a, T&gt;;
</span><span class="boring">        fn into_iter(self) -&gt; Self::IntoIter {
</span><span class="boring">            Self::IntoIter::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
</span><span class="boring">        type Item = &amp;'a mut T;
</span><span class="boring">        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">            unsafe {
</span><span class="boring">                while let Some(x) = self.curr {
</span><span class="boring">                    self.stack.push(x);
</span><span class="boring">                    self.curr = (*x.as_ptr()).l;
</span><span class="boring">                }
</span><span class="boring">                if let Some(mut x) = self.stack.pop() {
</span><span class="boring">                    self.curr = (*x.as_ptr()).r;
</span><span class="boring">                    Some(&amp;mut x.as_mut().data)
</span><span class="boring">                } else {
</span><span class="boring">                    None
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
</span><span class="boring">            (self.rope.len(), Some(self.rope.len()))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-10"><a class="header" href="#code-10">Code</a></h2>
<pre><code class="language-rust noplayground">mod rope {
    use std::{
        cmp::Ordering,
        fmt::{Debug, Display},
        ops::{Bound::*, Index, IndexMut, RangeBounds},
        ptr::{self, NonNull},
    };

    pub struct Rope&lt;T&gt; {
        root: Link&lt;T&gt;,
        size: usize,
    }

    impl&lt;T&gt; Default for Rope&lt;T&gt; {
        fn default() -&gt; Self {
            Self {
                root: None,
                size: 0,
            }
        }
    }

    impl&lt;T&gt; Rope&lt;T&gt; {
        pub fn new() -&gt; Self {
            Self::default()
        }

        pub fn len(&amp;self) -&gt; usize {
            self.size
        }

        pub fn clear(&amp;mut self) {
            let drop_tree = Self {
                root: self.root,
                size: self.size,
            };
            drop(drop_tree);
            self.root = None;
            self.size = 0;
        }

        pub fn insert(&amp;mut self, idx: usize, data: T) {
            debug_assert!(idx &lt;= self.size);
            unsafe {
                let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));

                if let Some(r) = self.root {
                    let idx = self.kth_ptr(idx);
                    if let Some(idx) = idx {
                        // idx_node is the node which new_node should replace
                        // &quot;Replace&quot; means the new_node should be placed right before the idx_node
                        if let Some(l) = (*idx.as_ptr()).l {
                            // Attach at the right of rightmost node from l
                            let mut p = l;
                            while let Some(r) = (*p.as_ptr()).r {
                                p = r;
                            }
                            // Attach new_node to the right of p
                            (*new_node.as_ptr()).p = Some(p);
                            (*p.as_ptr()).r = Some(new_node);
                        } else {
                            // Attach it right away
                            let p = idx;
                            (*new_node.as_ptr()).p = Some(p);
                            (*p.as_ptr()).l = Some(new_node);
                        }
                    } else {
                        // idx == self.size
                        // new_node goes to the rightmost of the tree
                        let mut p = r;
                        while let Some(r) = (*p.as_ptr()).r {
                            p = r;
                        }
                        // Attach new_node to the right of p
                        (*new_node.as_ptr()).p = Some(p);
                        (*p.as_ptr()).r = Some(new_node);
                    }

                    let mut c = new_node;
                    while let Some(p) = (*c.as_ptr()).p {
                        c = p;
                        (*c.as_ptr()).upd_subtree();
                    }
                } else {
                    self.root = Some(new_node);
                }

                self.splay(new_node);
                self.size += 1;
            }
        }

        pub fn remove(&amp;mut self, idx: usize) -&gt; Option&lt;T&gt; {
            if idx &gt;= self.size {
                return None;
            }

            let data: T = unsafe {
                if let Some(mut rt) = self.kth_ptr(idx) {
                    rt = self.remove_helper(rt);
                    if let Some(rp) = (*rt.as_ptr()).p {
                        self.splay(rp);
                    }
                    let retr = Box::from_raw(rt.as_ptr());
                    retr.data
                } else {
                    unreachable!()
                }
            };

            self.size -= 1;
            Some(data)
        }

        pub fn push_front(&amp;mut self, data: T) {
            self.insert(0, data);
        }

        pub fn push_back(&amp;mut self, data: T) {
            self.insert(self.size, data);
        }

        pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.remove(0)
        }

        pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.remove(self.size - 1)
        }

        /// Splits out the rope, leaving self[..at] and returning self[at..].
        /// If the index is invalid, it returns None.
        pub fn take_right(&amp;mut self, right_start: usize) -&gt; Option&lt;Self&gt; {
            let rhs = unsafe {
                if right_start == 0 {
                    let rhs = Self {
                        root: self.root,
                        size: self.size,
                    };
                    self.root = None;
                    self.size = 0;
                    rhs
                } else {
                    let root = self.kth_ptr(right_start - 1)?;
                    self.splay(root);
                    if let Some(r) = (*root.as_ptr()).r {
                        (*root.as_ptr()).r = None;
                        (*r.as_ptr()).p = None;
                        (*root.as_ptr()).upd_subtree();
                        self.size = (*root.as_ptr()).subt;
                        Self {
                            root: Some(r),
                            size: (*r.as_ptr()).subt,
                        }
                    } else {
                        Self {
                            root: None,
                            size: 0,
                        }
                    }
                }
            };
            Some(rhs)
        }

        /// Splits out the rope and returns self[..at] and self[at..].
        /// If the index is invalid, it returns None.
        pub fn split_at(mut self, at: usize) -&gt; Option&lt;(Self, Self)&gt; {
            let rhs = self.take_right(at)?;
            Some((self, rhs))
        }

        /// Takes out the range from the rope.
        /// Returns None if the index is invalid.
        pub fn take_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; Option&lt;Self&gt; {
            let l = match range.start_bound() {
                Included(&amp;l) =&gt; l,
                Excluded(&amp;l) =&gt; l + 1,
                Unbounded =&gt; 0,
            };
            let r = match range.end_bound() {
                Included(&amp;r) =&gt; r + 1,
                Excluded(&amp;r) =&gt; r,
                Unbounded =&gt; self.size,
            };

            if l &gt; r || l &gt; self.size || r &gt; self.size {
                return None;
            }
            // Now the operations below never ends early
            let c = self.take_right(r)?;
            let b = self.take_right(l)?;
            self.merge_right(c);
            Some(b)
        }

        pub fn merge_right(&amp;mut self, mut rhs: Self) {
            if self.len() == 0 {
                self.root = rhs.root;
                self.size = rhs.size;
            } else {
                unsafe {
                    let rmost = self.kth_ptr(self.size - 1).unwrap();
                    self.splay(rmost);
                    (*rmost.as_ptr()).r = rhs.root;
                    if let Some(rhs_root) = rhs.root {
                        (*rhs_root.as_ptr()).p = Some(rmost);
                    }
                    (*rmost.as_ptr()).upd_subtree();
                    self.size = (*rmost.as_ptr()).subt;
                }
            }
            rhs.root = None;
            rhs.size = 0;
        }

        pub fn merge_left(&amp;mut self, mut lhs: Self) {
            if self.len() == 0 {
                self.root = lhs.root;
                self.size = lhs.size;
            } else {
                unsafe {
                    let lmost = self.kth_ptr(0).unwrap();
                    self.splay(lmost);
                    (*lmost.as_ptr()).l = lhs.root;
                    if let Some(lhs_root) = lhs.root {
                        (*lhs_root.as_ptr()).p = Some(lmost);
                    }
                    (*lmost.as_ptr()).upd_subtree();
                    self.size = (*lmost.as_ptr()).subt;
                }
            }
            lhs.root = None;
            lhs.size = 0;
        }

        /// Inserts rope into self at self.
        /// After the operation, rope[0] becomes self[at].
        /// Returns false if the specified index is invalid, true otherwise.
        pub fn insert_rope(&amp;mut self, rope: Self, at: usize) -&gt; bool {
            let rhs = self.take_right(at);
            if let Some(rhs) = rhs {
                self.merge_right(rope);
                self.merge_right(rhs);
                true
            } else {
                false
            }
        }
    }

    impl&lt;T: Clone&gt; Clone for Rope&lt;T&gt; {
        fn clone(&amp;self) -&gt; Self {
            self.iter().cloned().collect()
        }
    }

    impl&lt;T: Debug&gt; Debug for Rope&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;[&quot;)?;
            let mut cnt: usize = 0;
            unsafe {
                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
                let mut curr = self.root;
                loop {
                    while let Some(x) = curr {
                        stack.push(x.as_ptr());
                        curr = (*x.as_ptr()).l;
                    }
                    if let Some(x) = stack.pop() {
                        if cnt == 0 {
                            write!(f, &quot;{:?}&quot;, (*x).data)?;
                        } else {
                            write!(f, &quot;, {:?}&quot;, (*x).data)?;
                        }
                        cnt += 1;
                        curr = (*x).r;
                    } else {
                        break;
                    }
                }
            }
            write!(f, &quot;]&quot;)
        }
    }

    impl&lt;T: Display&gt; Display for Rope&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            unsafe {
                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
                let mut curr = self.root;
                loop {
                    while let Some(x) = curr {
                        stack.push(x.as_ptr());
                        curr = (*x.as_ptr()).l;
                    }
                    if let Some(x) = stack.pop() {
                        write!(f, &quot;{}&quot;, (*x).data)?;
                        curr = (*x).r;
                    } else {
                        break;
                    }
                }
            }
            Ok(())
        }
    }

    impl&lt;T&gt; Drop for Rope&lt;T&gt; {
        fn drop(&amp;mut self) {
            if let Some(root) = self.root {
                unsafe {
                    let mut st: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
                    st.push(root.as_ptr());
                    while let Some(t) = st.pop() {
                        let v = Box::from_raw(t);
                        if let Some(l) = v.l {
                            st.push(l.as_ptr());
                        }
                        if let Some(r) = v.r {
                            st.push(r.as_ptr());
                        }
                        drop(v);
                    }
                }
            }
        }
    }

    impl&lt;T&gt; Index&lt;usize&gt; for Rope&lt;T&gt; {
        type Output = T;
        fn index(&amp;self, idx: usize) -&gt; &amp;Self::Output {
            unsafe {
                let p = self.kth_ptr(idx).unwrap();
                &amp;(*p.as_ptr()).data
            }
        }
    }

    impl&lt;T&gt; IndexMut&lt;usize&gt; for Rope&lt;T&gt; {
        fn index_mut(&amp;mut self, idx: usize) -&gt; &amp;mut Self::Output {
            unsafe {
                let p = self.kth_ptr(idx).unwrap();
                self.splay(p);
                &amp;mut (*p.as_ptr()).data
            }
        }
    }

    impl&lt;T&gt; FromIterator&lt;T&gt; for Rope&lt;T&gt; {
        fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {
            let mut arr = Self::new();
            for v in iter {
                unsafe { arr.push_ontop_root(v) };
            }
            arr
        }
    }

    impl&lt;T&gt; Rope&lt;T&gt; {
        pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
            Iter::new(self)
        }

        pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
            IterMut::new(self)
        }
    }

    pub struct Iter&lt;'a, T&gt; {
        rope: &amp;'a Rope&lt;T&gt;,
        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
        curr: Link&lt;T&gt;,
    }

    impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
        fn new(rope: &amp;'a Rope&lt;T&gt;) -&gt; Self {
            let root = rope.root;
            Self {
                rope,
                stack: Vec::new(),
                curr: root,
            }
        }
    }

    impl&lt;'a, T&gt; IntoIterator for &amp;'a Rope&lt;T&gt; {
        type Item = &amp;'a T;
        type IntoIter = Iter&lt;'a, T&gt;;
        fn into_iter(self) -&gt; Self::IntoIter {
            Self::IntoIter::new(self)
        }
    }

    impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
        type Item = &amp;'a T;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            unsafe {
                while let Some(x) = self.curr {
                    self.stack.push(x);
                    self.curr = (*x.as_ptr()).l;
                }
                if let Some(x) = self.stack.pop() {
                    self.curr = (*x.as_ptr()).r;
                    Some(&amp;x.as_ref().data)
                } else {
                    None
                }
            }
        }

        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
            (self.rope.len(), Some(self.rope.len()))
        }
    }

    pub struct IterMut&lt;'a, T&gt; {
        rope: &amp;'a mut Rope&lt;T&gt;,
        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
        curr: Link&lt;T&gt;,
    }

    impl&lt;'a, T&gt; IterMut&lt;'a, T&gt; {
        fn new(rope: &amp;'a mut Rope&lt;T&gt;) -&gt; Self {
            let root = rope.root;
            Self {
                rope,
                stack: Vec::new(),
                curr: root,
            }
        }
    }

    impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Rope&lt;T&gt; {
        type Item = &amp;'a mut T;
        type IntoIter = IterMut&lt;'a, T&gt;;
        fn into_iter(self) -&gt; Self::IntoIter {
            Self::IntoIter::new(self)
        }
    }

    impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
        type Item = &amp;'a mut T;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            unsafe {
                while let Some(x) = self.curr {
                    self.stack.push(x);
                    self.curr = (*x.as_ptr()).l;
                }
                if let Some(mut x) = self.stack.pop() {
                    self.curr = (*x.as_ptr()).r;
                    Some(&amp;mut x.as_mut().data)
                } else {
                    None
                }
            }
        }

        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
            (self.rope.len(), Some(self.rope.len()))
        }
    }

    //------------------------
    // Helper implementations
    //------------------------

    struct Node&lt;T&gt; {
        data: T,
        subt: usize,
        l: Link&lt;T&gt;,
        r: Link&lt;T&gt;,
        p: Link&lt;T&gt;,
    }

    type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;

    impl&lt;T&gt; Node&lt;T&gt; {
        fn new(data: T) -&gt; Self {
            Node {
                data,
                subt: 1,
                l: None,
                r: None,
                p: None,
            }
        }
        fn left_size(&amp;self) -&gt; usize {
            unsafe { self.l.map_or(0, |l| (*l.as_ptr()).subt) }
        }
        fn right_size(&amp;self) -&gt; usize {
            unsafe { self.r.map_or(0, |r| (*r.as_ptr()).subt) }
        }
        fn upd_subtree(&amp;mut self) {
            self.subt = 1 + self.left_size() + self.right_size();
        }

        // Option&lt;(is_left, parent)&gt;
        unsafe fn is_left_child(x: NonNull&lt;Self&gt;) -&gt; Option&lt;(bool, NonNull&lt;Self&gt;)&gt; {
            if let Some(p) = (*x.as_ptr()).p {
                if (*p.as_ptr())
                    .l
                    .map_or(false, |pl| ptr::eq(x.as_ptr(), pl.as_ptr()))
                {
                    Some((true, p))
                } else {
                    Some((false, p))
                }
            } else {
                None
            }
        }
    }

    impl&lt;T&gt; Rope&lt;T&gt; {
        /// Adds data as a new root of a rope, and putting the original root
        /// as a left child of the root.
        unsafe fn push_ontop_root(&amp;mut self, data: T) {
            let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));
            if let Some(root) = self.root {
                (*root.as_ptr()).p = Some(new_node);
                (*new_node.as_ptr()).l = Some(root);
            }
            self.root = Some(new_node);
            (*new_node.as_ptr()).upd_subtree();
            self.size += 1;
        }

        /// Returns false if x has no parent, and do nothing
        /// Returns true if x has a parent, after performing rotation
        unsafe fn rotate(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; bool {
            if let Some((is_x_left, p)) = Node::is_left_child(x) {
                // Check if p is root
                if let Some(root) = self.root {
                    if ptr::eq(root.as_ptr(), p.as_ptr()) {
                        self.root = Some(x);
                    }
                }

                // Connect x to xpp. If pp is None, do nothing.
                (*x.as_ptr()).p = (*p.as_ptr()).p;
                if let Some((is_p_left, pp)) = Node::is_left_child(p) {
                    if is_p_left {
                        (*pp.as_ptr()).l = Some(x);
                    } else {
                        (*pp.as_ptr()).r = Some(x);
                    }
                }

                if is_x_left {
                    let b = (*x.as_ptr()).r;
                    (*x.as_ptr()).r = Some(p);
                    (*p.as_ptr()).p = Some(x);
                    (*p.as_ptr()).l = b;
                    if let Some(b) = b {
                        (*b.as_ptr()).p = Some(p);
                    }
                } else {
                    let b = (*x.as_ptr()).l;
                    (*x.as_ptr()).l = Some(p);
                    (*p.as_ptr()).p = Some(x);
                    (*p.as_ptr()).r = b;
                    if let Some(b) = b {
                        (*b.as_ptr()).p = Some(p);
                    }
                }

                (*p.as_ptr()).upd_subtree();
                (*x.as_ptr()).upd_subtree();
                true
            } else {
                false
            }
        }

        fn splay(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) {
            unsafe {
                while let Some(root) = self.root {
                    if ptr::eq(x.as_ptr(), root.as_ptr()) {
                        break;
                    }

                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
                        if ptr::eq(root.as_ptr(), p.as_ptr()) {
                            // If p is root, rotate x once
                            self.rotate(x);
                        } else {
                            // Panics if pp doesn't exist, which happens only when p is root
                            let (is_p_left, _pp) = Node::is_left_child(p).unwrap();
                            if is_x_left == is_p_left {
                                self.rotate(p);
                                self.rotate(x);
                            } else {
                                self.rotate(x);
                                self.rotate(x);
                            }
                        }
                    } else {
                        // x has no parent, which should logically never happen
                        unreachable!()
                    }
                }
            }
        }

        unsafe fn kth_ptr(&amp;self, idx: usize) -&gt; Link&lt;T&gt; {
            if self.size &lt;= idx {
                return None;
            }
            if let Some(r) = self.root {
                let mut rem = idx;
                let mut p = r;
                loop {
                    let lsize = (*p.as_ptr()).left_size();
                    match rem.cmp(&amp;lsize) {
                        Ordering::Less =&gt; {
                            p = (*p.as_ptr()).l?;
                        }
                        Ordering::Equal =&gt; {
                            break;
                        }
                        Ordering::Greater =&gt; {
                            rem -= lsize + 1;
                            p = (*p.as_ptr()).r?;
                        }
                    }
                }
                Some(p)
            } else {
                None
            }
        }

        unsafe fn remove_helper(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; NonNull&lt;Node&lt;T&gt;&gt; {
            // Set remove_target to the actual node to delete
            match ((*x.as_ptr()).l, ((*x.as_ptr()).r)) {
                (None, None) =&gt; {
                    // Reset root if the node itself is root
                    if let Some(root) = self.root {
                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
                            self.root = None;
                        }
                    }
                    // Detatch itself from parent
                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
                        if is_x_left {
                            (*p.as_ptr()).l = None;
                        } else {
                            (*p.as_ptr()).r = None;
                        }
                        // Update subtree size
                        let mut p = p;
                        (*p.as_ptr()).upd_subtree();
                        while let Some(pp) = (*p.as_ptr()).p {
                            p = pp;
                            (*p.as_ptr()).upd_subtree();
                        }
                    }
                    x
                }
                (Some(l), None) =&gt; {
                    // Reset root if the node itself is a root
                    if let Some(root) = self.root {
                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
                            self.root = Some(l);
                        }
                    }

                    (*l.as_ptr()).p = (*x.as_ptr()).p;
                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
                        if is_rt_left {
                            (*p.as_ptr()).l = Some(l);
                        } else {
                            (*p.as_ptr()).r = Some(l);
                        }
                    }

                    let mut p = l;
                    while let Some(pp) = (*p.as_ptr()).p {
                        p = pp;
                        (*p.as_ptr()).upd_subtree();
                    }
                    x
                }
                (None, Some(r)) =&gt; {
                    // Reset root if the node itself is a root
                    if let Some(root) = self.root {
                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
                            self.root = Some(r);
                        }
                    }

                    (*r.as_ptr()).p = (*x.as_ptr()).p;
                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
                        if is_rt_left {
                            (*p.as_ptr()).l = Some(r);
                        } else {
                            (*p.as_ptr()).r = Some(r);
                        }
                    }

                    let mut p = r;
                    while let Some(pp) = (*p.as_ptr()).p {
                        p = pp;
                        (*p.as_ptr()).upd_subtree();
                    }
                    x
                }
                (Some(l), Some(_)) =&gt; {
                    let mut sw = l;
                    while let Some(sr) = (*sw.as_ptr()).r {
                        sw = sr;
                    }
                    std::mem::swap(&amp;mut (*x.as_ptr()).data, &amp;mut (*sw.as_ptr()).data);
                    sw = self.remove_helper(sw);
                    sw
                }
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adjacency-list-graph-representation"><a class="header" href="#adjacency-list-graph-representation">Adjacency List Graph Representation</a></h1>
<p>Credits to kiwiyou</p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Graph&lt;T&gt; {
    n: usize,
    first: Vec&lt;usize&gt;,
    edge: Vec&lt;(usize, usize, T)&gt;, // (to, prev, data)
}

impl&lt;T&gt; Graph&lt;T&gt; {
    fn new(n: usize, e: usize) -&gt; Self {
        Self {
            n,
            first: vec![usize::MAX; n],
            edge: Vec::with_capacity(e),
        }
    }

    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len());
        self.edge.push((to, prev, data));
    }

    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
        Neighbor {
            graph: self,
            next_edge: self.first[of],
        }
    }
}

struct Neighbor&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    next_edge: usize,
}

impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
    type Item = (usize, &amp;'g T);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (to, next_edge, data) = self.graph.edge.get(self.next_edge)?;
        self.next_edge = *next_edge;
        Some((*to, data))
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dijkstra"><a class="header" href="#dijkstra">Dijkstra</a></h1>
<p><code>dijkstra(graph: &amp;Graph&lt;T&gt;, src: usize)</code> where <code>Graph&lt;T&gt;</code> is a <a href="graphs/./adjlist.html">graph representation</a>, <code>T</code> is a numeric data type, and <code>src</code> is an id of a source node. It returns a <code>dist = Vec&lt;Option&lt;T&gt;&gt;</code>, where <code>dist[dst]</code> is the length of a shortest path from <code>src</code> to <code>dst</code> if it exists, or <code>None</code> if <code>dst</code> is unreachable from <code>src</code>.</p>
<h2 id="example-12"><a class="header" href="#example-12">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut g: Graph&lt;i64&gt; = Graph::new(4, 3);
g.add_edge(0, 1, 5);
g.add_edge(1, 2, 5);
g.add_edge(1, 2, 15);
println!(&quot;{:?}&quot;, dijkstra(&amp;g, 0));
<span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Graph&lt;T&gt; {
</span><span class="boring">    n: usize,
</span><span class="boring">    first: Vec&lt;usize&gt;,
</span><span class="boring">    edge: Vec&lt;(usize, usize, T)&gt;, // (to, prev, data)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Graph&lt;T&gt; {
</span><span class="boring">    fn new(n: usize, e: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            first: vec![usize::MAX; n],
</span><span class="boring">            edge: Vec::with_capacity(e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
</span><span class="boring">        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len());
</span><span class="boring">        self.edge.push((to, prev, data));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
</span><span class="boring">        Neighbor {
</span><span class="boring">            graph: self,
</span><span class="boring">            next_edge: self.first[of],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Neighbor&lt;'g, T&gt; {
</span><span class="boring">    graph: &amp;'g Graph&lt;T&gt;,
</span><span class="boring">    next_edge: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
</span><span class="boring">    type Item = (usize, &amp;'g T);
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        let (to, next_edge, data) = self.graph.edge.get(self.next_edge)?;
</span><span class="boring">        self.next_edge = *next_edge;
</span><span class="boring">        Some((*to, data))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn dijkstra&lt;T: Copy + From&lt;u8&gt; + std::ops::Add&lt;Output = T&gt; + Eq + Ord&gt;(
</span><span class="boring">    graph: &amp;Graph&lt;T&gt;,
</span><span class="boring">    src: usize,
</span><span class="boring">) -&gt; Vec&lt;Option&lt;T&gt;&gt; {
</span><span class="boring">    use std::{cmp::Reverse, collections::BinaryHeap};
</span><span class="boring">    let mut dist: Vec&lt;Option&lt;T&gt;&gt; = vec![None; graph.n];
</span><span class="boring">    let mut heap: BinaryHeap&lt;(Reverse&lt;T&gt;, usize)&gt; = BinaryHeap::new();
</span><span class="boring">    heap.push((Reverse(0.into()), src));
</span><span class="boring">
</span><span class="boring">    while let Some((Reverse(curr_cost), curr)) = heap.pop() {
</span><span class="boring">        if dist[curr].map_or(false, |x| x &lt; curr_cost) {
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">        dist[curr] = Some(curr_cost);
</span><span class="boring">
</span><span class="boring">        for (next, &amp;weight) in graph.neighbor(curr) {
</span><span class="boring">            let next_cost = curr_cost + weight;
</span><span class="boring">            if dist[next].map_or(true, |x| x &gt; next_cost) {
</span><span class="boring">                dist[next] = Some(next_cost);
</span><span class="boring">                heap.push((Reverse(next_cost), next));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    dist
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-11"><a class="header" href="#code-11">Code</a></h2>
<pre><code class="language-rust noplayground">fn dijkstra&lt;T: Copy + From&lt;u8&gt; + std::ops::Add&lt;Output = T&gt; + Eq + Ord&gt;(
    graph: &amp;Graph&lt;T&gt;,
    src: usize,
) -&gt; Vec&lt;Option&lt;T&gt;&gt; {
    use std::{cmp::Reverse, collections::BinaryHeap};
    let mut dist: Vec&lt;Option&lt;T&gt;&gt; = vec![None; graph.n];
    let mut heap: BinaryHeap&lt;(Reverse&lt;T&gt;, usize)&gt; = BinaryHeap::new();
    heap.push((Reverse(0.into()), src));

    while let Some((Reverse(curr_cost), curr)) = heap.pop() {
        if dist[curr].map_or(false, |x| x &lt; curr_cost) {
            continue;
        }
        dist[curr] = Some(curr_cost);

        for (next, &amp;weight) in graph.neighbor(curr) {
            let next_cost = curr_cost + weight;
            if dist[next].map_or(true, |x| x &gt; next_cost) {
                dist[next] = Some(next_cost);
                heap.push((Reverse(next_cost), next));
            }
        }
    }
    dist
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disjoint-set-union"><a class="header" href="#disjoint-set-union">Disjoint Set Union</a></h1>
<p>Disjoint set union data structure.</p>
<h2 id="example-13"><a class="header" href="#example-13">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct UnionFind {
</span><span class="boring">    n: usize,
</span><span class="boring">    parent: Vec&lt;usize&gt;,
</span><span class="boring">    group_num: usize,
</span><span class="boring">    group_size: Vec&lt;usize&gt;,
</span><span class="boring">}
</span><span class="boring">impl UnionFind {
</span><span class="boring">    fn new(n: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            parent: vec![n; n],
</span><span class="boring">            group_num: n,
</span><span class="boring">            group_size: vec![1; n],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn find(&amp;mut self, u: usize) -&gt; usize {
</span><span class="boring">        let par = self.parent[u];
</span><span class="boring">        if par == self.n {
</span><span class="boring">            return u;
</span><span class="boring">        }
</span><span class="boring">        self.parent[u] = self.find(par);
</span><span class="boring">        self.parent[u]
</span><span class="boring">    }
</span><span class="boring">    fn is_differ(&amp;mut self, u: usize, v: usize) -&gt; bool {
</span><span class="boring">        self.find(u) != self.find(v)
</span><span class="boring">    }
</span><span class="boring">    fn union(&amp;mut self, u: usize, v: usize) {
</span><span class="boring">        let (ur, vr) = (self.find(u), self.find(v));
</span><span class="boring">        if ur != vr {
</span><span class="boring">            self.parent[vr] = ur;
</span><span class="boring">            self.group_size[ur] += self.group_size[vr];
</span><span class="boring">            self.group_num -= 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn get_group_size(&amp;mut self, u: usize) -&gt; usize {
</span><span class="boring">        let r = self.find(u);
</span><span class="boring">        self.group_size[r]
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">fn main() {
</span>let mut uf = UnionFind::new(10);
println!(&quot;{}&quot;, uf.is_differ(2, 6)); // true
uf.union(2, 6);
println!(&quot;{}&quot;, uf.is_differ(2, 6)); // false
<span class="boring">}</span></code></pre></pre>
<h2 id="code-12"><a class="header" href="#code-12">Code</a></h2>
<pre><code class="language-rust noplayground">struct UnionFind {
    n: usize,
    parent: Vec&lt;usize&gt;,
    group_num: usize,
    group_size: Vec&lt;usize&gt;,
}

impl UnionFind {
    fn new(n: usize) -&gt; Self {
        Self {
            n,
            parent: vec![n; n],
            group_num: n,
            group_size: vec![1; n],
        }
    }

    /// Returns the root of a group u is in
    fn find(&amp;mut self, u: usize) -&gt; usize {
        let par = self.parent[u];
        if par == self.n {
            return u;
        }
        self.parent[u] = self.find(par);
        self.parent[u]
    }

    /// Returns true if u and v are in different groups, false otherwise.
    fn is_differ(&amp;mut self, u: usize, v: usize) -&gt; bool {
        self.find(u) != self.find(v)
    }

    /// The group of v is merged into the group of u
    fn union(&amp;mut self, u: usize, v: usize) {
        let (ur, vr) = (self.find(u), self.find(v));
        if ur != vr {
            self.parent[vr] = ur;
            self.group_size[ur] += self.group_size[vr];
            self.group_num -= 1;
        }
    }

    fn get_group_size(&amp;mut self, u: usize) -&gt; usize {
        let r = self.find(u);
        self.group_size[r]
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weighted-dsu"><a class="header" href="#weighted-dsu">Weighted DSU</a></h1>
<p>Disjoint set union where vertices have their own &quot;potential value&quot;.</p>
<h2 id="code-13"><a class="header" href="#code-13">Code</a></h2>
<pre><code class="language-rust noplayground">struct WeightDSU {
    n: usize,
    group_num: usize,
    parent: Vec&lt;usize&gt;,
    group_size: Vec&lt;usize&gt;,
    potdiff: Vec&lt;i64&gt;,
}

impl WeightDSU {
    fn new(n: usize) -&gt; Self {
        Self {
            n,
            group_num: n,
            parent: vec![n; n],
            group_size: vec![1; n],
            potdiff: vec![0; n],
        }
    }

    /// Returns the root of u, and pot[u]-pot[root]
    fn find(&amp;mut self, u: usize) -&gt; (usize, i64) {
        let par = self.parent[u];
        if par == self.n {
            return (u, 0);
        }
        let (root, parpoten) = self.find(par);
        self.potdiff[u] += parpoten;
        self.parent[u] = root;
        (root, self.potdiff[u])
    }

    /// Returns pot[u]-pot[v]. Returns None if u and v aren't in the same group.
    fn pot_differ(&amp;mut self, u: usize, v: usize) -&gt; Option&lt;i64&gt; {
        let (ur, udiff) = self.find(u);
        let (vr, vdiff) = self.find(v);
        if ur != vr {
            None
        } else {
            Some(udiff - vdiff)
        }
    }

    /// Unions u and v, with setting pot[u]-pot[v] = w.
    /// Also puts the root of v under the root of u.
    /// Returns false if u and v are already unioned and the relation is not consistent.
    fn union(&amp;mut self, u: usize, v: usize, w: i64) -&gt; bool {
        let (ur, udiff) = self.find(u);
        let (vr, vdiff) = self.find(v);
        if ur == vr {
            udiff - vdiff == w
        } else {
            self.parent[vr] = ur;
            self.potdiff[vr] = udiff - vdiff - w;
            self.group_size[ur] += self.group_size[vr];
            self.group_num -= 1;
            true
        }
    }

    fn get_group_size(&amp;mut self, u: usize) -&gt; usize {
        let r = self.find(u).0;
        self.group_size[r]
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strongly-connected-components"><a class="header" href="#strongly-connected-components">Strongly Connected Components</a></h1>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Graph&lt;T&gt; {
    n: u32,
    first: Vec&lt;u32&gt;,
    edge: Vec&lt;(u32, u32, T)&gt;, // (to, prev, data)
}

impl&lt;T&gt; Graph&lt;T&gt; {
    fn new(n: u32, e: u32) -&gt; Self {
        Self {
            n,
            first: vec![u32::MAX; n as usize],
            edge: Vec::with_capacity(e as usize),
        }
    }

    fn add_edge(&amp;mut self, from: u32, to: u32, data: T) {
        let prev = std::mem::replace(&amp;mut self.first[from as usize], self.edge.len() as u32);
        self.edge.push((to, prev, data));
    }

    fn neighbor(&amp;self, of: u32) -&gt; Neighbor&lt;T&gt; {
        Neighbor {
            graph: self,
            next_edge: self.first[of as usize],
        }
    }
}

struct Neighbor&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    next_edge: u32,
}

impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
    type Item = (u32, &amp;'g T);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (to, next_edge, data) = self.graph.edge.get(self.next_edge as usize)?;
        self.next_edge = *next_edge;
        Some((*to, data))
    }
}

struct SccStack {
    stack: Vec&lt;u32&gt;,
    check: Vec&lt;bool&gt;,
}

impl SccStack {
    fn new(cap: u32) -&gt; Self {
        Self {
            stack: vec![0; cap as usize],
            check: vec![false; cap as usize],
        }
    }

    fn len(&amp;self) -&gt; u32 {
        self.stack.len() as u32
    }

    fn push(&amp;mut self, n: u32) {
        self.stack.push(n);
        self.check[n as usize] = true;
    }

    fn get(&amp;self) -&gt; u32 {
        self.stack[self.len() as usize - 1]
    }

    fn pop(&amp;mut self) -&gt; u32 {
        let tmp = self.stack.pop().unwrap();
        self.check[tmp as usize] = false;
        tmp
    }

    fn is_in(&amp;self, n: u32) -&gt; bool {
        self.check[n as usize]
    }
}

struct SCC&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    scc_list: Vec&lt;Vec&lt;u32&gt;&gt;,
    scc_ids: Vec&lt;u32&gt;,
}

impl&lt;'g, T: 'g&gt; SCC&lt;'g, T&gt; {
    fn new(graph: &amp;'g Graph&lt;T&gt;) -&gt; Self {
        let mut st = SccStack::new(graph.n);
        let mut list: Vec&lt;Vec&lt;u32&gt;&gt; = Vec::new();
        let mut gid: u32 = 0;
        let mut id = vec![graph.n; graph.n as usize];
        let mut low = vec![u32::MAX; graph.n as usize];

        for x in 0..graph.n {
            if id[x as usize] != graph.n {
                continue;
            }
            Self::dfs(graph, x, &amp;mut gid, &amp;mut id, &amp;mut low, &amp;mut st, &amp;mut list)
        }
        list.reverse();

        let mut ids = vec![0u32; graph.n as usize];
        for (i, l) in list.iter().enumerate() {
            for &amp;v in l.iter() {
                ids[v as usize] = i as u32;
            }
        }

        Self {
            graph,
            scc_list: list,
            scc_ids: ids,
        }
    }

    fn dfs(
        graph: &amp;Graph&lt;T&gt;,
        curr: u32,
        gid: &amp;mut u32,
        id: &amp;mut Vec&lt;u32&gt;,
        low: &amp;mut Vec&lt;u32&gt;,
        st: &amp;mut SccStack,
        list: &amp;mut Vec&lt;Vec&lt;u32&gt;&gt;,
    ) {
        st.push(curr);
        id[curr as usize] = *gid;
        low[curr as usize] = *gid;
        (*gid) += 1;

        for (next, _) in graph.neighbor(curr) {
            if id[next as usize] == graph.n {
                Self::dfs(graph, next, gid, id, low, st, list);
            }
        }

        for (next, _) in graph.neighbor(curr) {
            if st.is_in(next) {
                low[curr as usize] = low[curr as usize].min(low[next as usize]);
            }
        }

        if id[curr as usize] == low[curr as usize] {
            let p = list.len();
            list.push(Vec::new());
            while st.len() != 0 &amp;&amp; st.get() != curr {
                list[p].push(st.pop());
            }
            st.pop();
            list[p].push(curr);
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sat"><a class="header" href="#2-sat">2-SAT</a></h1>
<p>Required snippets: <a href="graphs/./scc.html#strongly-connected-components">SCC</a></p>
<pre><code class="language-rust noplayground">struct TwoSat {
    n: u32,
    graph: Graph&lt;()&gt;,
}

impl TwoSat {
    fn new(n: u32, clause_num: u32) -&gt; Self {
        Self {
            n,
            graph: Graph::new(n &lt;&lt; 1, clause_num &lt;&lt; 1),
        }
    }

    fn judge(f: bool, a: u32, b: u32) -&gt; u32 {
        if f {
            a
        } else {
            b
        }
    }

    fn add_clause(&amp;mut self, i: u32, f: bool, j: u32, g: bool) {
        self.graph.add_edge(
            (i &lt;&lt; 1) + Self::judge(f, 0, 1),
            (j &lt;&lt; 1) + Self::judge(g, 1, 0),
            (),
        );
        self.graph.add_edge(
            (j &lt;&lt; 1) + Self::judge(g, 0, 1),
            (i &lt;&lt; 1) + Self::judge(f, 1, 0),
            (),
        );
    }

    fn solve(self) -&gt; Option&lt;Vec&lt;bool&gt;&gt; {
        let mut answer = vec![false; self.n as usize];

        let scc = SCC::new(&amp;self.graph);
        let ids = &amp;scc.scc_ids;

        for i in 0..self.n {
            if ids[(i as usize) &lt;&lt; 1] == ids[((i as usize) &lt;&lt; 1) + 1] {
                return None;
            }
            answer[i as usize] = ids[(i as usize) &lt;&lt; 1] &lt; ids[((i as usize) &lt;&lt; 1) + 1];
        }
        Some(answer)
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<p>Given an array \(P\), <code>KMPNeedle::new(P)</code> returns a <code>KMPNeedle</code> instance for searching \(P\) in any array, using <code>KMPMatcher</code>.</p>
<p>Given a <code>KMPNeedle</code> instance <code>p</code> and an array target \(T\), <code>KMPMatcher::new(&amp;p, T)</code> returns an iterator yielding indicies where \(P\) appears within \(T\). Even if some ranges where \(P\) exists within \(T\) overlap with each other, they are still all yielded as shown in the second string from the example <code>&quot;ABCDABCDABCD&quot;</code>.</p>
<p><code>KMPNeedle::new(P)</code> runs in a time complexity of \(O(\left| P \right|)\) and <code>KMPMatcher::new(T)</code> takes a time complexity of \(O(\left| T \right|)\) to be consumed. <code>KMPMatcher</code> searches for a pattern lazily, so it only takes time of total searched length in \(T\).</p>
<p>A single <code>KMPNeedle</code> instance can be used to search \(P\) in multiple arrays as shown in the example.</p>
<h2 id="example-14"><a class="header" href="#example-14">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let pattern = &quot;ABCDABC&quot;;
let targets = vec![&quot;ABDABCDABCE&quot;, &quot;ABCDABCDABCD&quot;, &quot;ABBCCABCDABDABCDABC&quot;];

let needle = KMPNeedle::new(pattern.as_bytes());
for &amp;t in targets.iter() {
    let kmp = KMPMatcher::new(&amp;needle, t.as_bytes());
    for v in kmp {
        print!(&quot;{} &quot;, v);
    }
    println!();
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KMPNeedle&lt;'a, T: PartialEq&gt; {
</span><span class="boring">    p: &amp;'a [T],
</span><span class="boring">    c: Vec&lt;usize&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T: PartialEq&gt; KMPNeedle&lt;'a, T&gt; {
</span><span class="boring">    fn new(p: &amp;'a [T]) -&gt; Self {
</span><span class="boring">        let mut c: Vec&lt;usize&gt; = vec![0; p.len() + 1];
</span><span class="boring">
</span><span class="boring">        let mut l = 0;
</span><span class="boring">        for (r, v) in p.iter().enumerate().skip(1) {
</span><span class="boring">            while l &gt; 0 &amp;&amp; p[l] != *v {
</span><span class="boring">                l = c[l];
</span><span class="boring">            }
</span><span class="boring">            if p[l] == *v {
</span><span class="boring">                c[r + 1] = l + 1;
</span><span class="boring">                l += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Self { p, c }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KMPMatcher&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; {
</span><span class="boring">    needle: &amp;'c KMPNeedle&lt;'b, T&gt;,
</span><span class="boring">    t: &amp;'a [T],
</span><span class="boring">    i: usize,
</span><span class="boring">    j: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; KMPMatcher&lt;'a, 'b, 'c, T&gt; {
</span><span class="boring">    fn new(needle: &amp;'c KMPNeedle&lt;'b, T&gt;, t: &amp;'a [T]) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            needle,
</span><span class="boring">            t,
</span><span class="boring">            i: 0,
</span><span class="boring">            j: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; Iterator for KMPMatcher&lt;'a, 'b, 'c, T&gt; {
</span><span class="boring">    type Item = usize;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        while self.i &lt; self.t.len() {
</span><span class="boring">            while self.j &gt; 0 &amp;&amp; self.t[self.i] != self.needle.p[self.j] {
</span><span class="boring">                self.j = self.needle.c[self.j];
</span><span class="boring">            }
</span><span class="boring">            if self.t[self.i] == self.needle.p[self.j] {
</span><span class="boring">                if self.j == self.needle.p.len() - 1 {
</span><span class="boring">                    self.j = self.needle.c[self.j + 1];
</span><span class="boring">                    self.i += 1;
</span><span class="boring">                    return Some(self.i - self.needle.p.len());
</span><span class="boring">                } else {
</span><span class="boring">                    self.j += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            self.i += 1;
</span><span class="boring">        }
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-14"><a class="header" href="#code-14">Code</a></h2>
<pre><code class="language-rust noplayground">struct KMPNeedle&lt;'a, T: PartialEq&gt; {
    p: &amp;'a [T],
    c: Vec&lt;usize&gt;,
}

impl&lt;'a, T: PartialEq&gt; KMPNeedle&lt;'a, T&gt; {
    fn new(p: &amp;'a [T]) -&gt; Self {
        let mut c: Vec&lt;usize&gt; = vec![0; p.len() + 1];

        let mut l = 0;
        for (r, v) in p.iter().enumerate().skip(1) {
            while l &gt; 0 &amp;&amp; p[l] != *v {
                l = c[l];
            }
            if p[l] == *v {
                c[r + 1] = l + 1;
                l += 1;
            }
        }

        Self { p, c }
    }
}

struct KMPMatcher&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; {
    needle: &amp;'c KMPNeedle&lt;'b, T&gt;,
    t: &amp;'a [T],
    i: usize,
    j: usize,
}

impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; KMPMatcher&lt;'a, 'b, 'c, T&gt; {
    fn new(needle: &amp;'c KMPNeedle&lt;'b, T&gt;, t: &amp;'a [T]) -&gt; Self {
        Self {
            needle,
            t,
            i: 0,
            j: 0,
        }
    }
}

impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; Iterator for KMPMatcher&lt;'a, 'b, 'c, T&gt; {
    type Item = usize;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        while self.i &lt; self.t.len() {
            while self.j &gt; 0 &amp;&amp; self.t[self.i] != self.needle.p[self.j] {
                self.j = self.needle.c[self.j];
            }
            if self.t[self.i] == self.needle.p[self.j] {
                if self.j == self.needle.p.len() - 1 {
                    self.j = self.needle.c[self.j + 1];
                    self.i += 1;
                    return Some(self.i - self.needle.p.len());
                } else {
                    self.j += 1;
                }
            }
            self.i += 1;
        }
        None
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<p>For an array \(A\) of length \(n\), <code>manacher(A)</code> returns a vector \(M\) where, for every \(i \in \left[0, n\right)\), \(A_{i-j} = A_{i+j}\) holds for every \(j \in \left[0, M_i \right)\).</p>
<p>Additional modification should be added by a user to use this function for finding every palindromes among subsequences of a string.</p>
<h2 id="example-15"><a class="header" href="#example-15">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = &quot;abracadacabra&quot;.as_bytes();
let man = manacher(s);
println!(&quot;{:?}&quot;, man); // [1, 1, 1, 1, 2, 1, 4, 1, 2, 1, 1, 1, 1]

for i in 0..s.len() {
    println!(
        &quot;{}&quot;,
        std::str::from_utf8(&amp;s[i + 1 - man[i]..i + man[i]]).unwrap()
    );
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn manacher&lt;T: Eq&gt;(arr: &amp;[T]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    let n = arr.len();
</span><span class="boring">    let mut mana: Vec&lt;usize&gt; = vec![1; n];
</span><span class="boring">    let mut r: usize = 1;
</span><span class="boring">    let mut p: usize = 0;
</span><span class="boring">
</span><span class="boring">    for i in 1..arr.len() {
</span><span class="boring">        if i + 1 &gt;= r {
</span><span class="boring">            mana[i] = 1;
</span><span class="boring">        } else {
</span><span class="boring">            let j = 2 * p - i;
</span><span class="boring">            mana[i] = mana[j].min(r - i);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        while mana[i] &lt;= i &amp;&amp; i + mana[i] &lt; n {
</span><span class="boring">            if arr[(i - mana[i])] != arr[(i + mana[i])] {
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">            mana[i] += 1;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if r &lt; mana[i] + i {
</span><span class="boring">            r = mana[i] + i;
</span><span class="boring">            p = i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    mana
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-15"><a class="header" href="#code-15">Code</a></h2>
<pre><code class="language-rust noplayground">fn manacher&lt;T: Eq&gt;(arr: &amp;[T]) -&gt; Vec&lt;usize&gt; {
    let n = arr.len();
    let mut mana: Vec&lt;usize&gt; = vec![1; n];
    let mut r: usize = 1;
    let mut p: usize = 0;

    for i in 1..arr.len() {
        if i + 1 &gt;= r {
            mana[i] = 1;
        } else {
            let j = 2 * p - i;
            mana[i] = mana[j].min(r - i);
        }

        while mana[i] &lt;= i &amp;&amp; i + mana[i] &lt; n {
            if arr[(i - mana[i])] != arr[(i + mana[i])] {
                break;
            }
            mana[i] += 1;
        }

        if r &lt; mana[i] + i {
            r = mana[i] + i;
            p = i;
        }
    }

    mana
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suffix-array-and-lcp-array"><a class="header" href="#suffix-array-and-lcp-array">Suffix Array and LCP Array</a></h1>
<p>For an array \(A\) of length \(n\), <code>sa_lcp(A)</code> returns two vectors \(SA\) and \(LCP\) where,</p>
<ul>
<li>\(A[SA[i] \dots]\) is the \(i\)-th suffix in lexicographical order for every \(i \in \left[0, n\right)\)</li>
</ul>
<p>and</p>
<ul>
<li>\(LCP[i]\) is the length of the longest common prefix between \(A[SA[i-1] \dots]\) and \(A[SA[i] \dots]\) for every \(i \in \left[1, n \right)\). Also, \(LCP[0] = 0\).</li>
</ul>
<p>\(SA\) and \(LCP\) are called &quot;suffix array&quot; and &quot;LCP array&quot; of \(A\) respectively.</p>
<p>For finding SA, Manber-Myers algorithm combined with counting sort is used, hence the time complexity is \(O(n\log{n})\). For LCP array, Kasai's algorithm is used, hence the time complexity is \(O(n)\). The total time complexity is \(O(n\log{n})\).</p>
<h2 id="example-16"><a class="header" href="#example-16">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = &quot;asdsdasd&quot;;
let (sa, lcp) = sa_lcp(s.as_bytes());
println!(&quot;{:?}&quot;, sa);  // [5, 0, 7, 4, 2, 6, 3, 1]
println!(&quot;{:?}&quot;, lcp); // [x, 3, 0, 1, 1, 0, 2, 2]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Suffix array and LCP array
</span><span class="boring">// Reference: http://www.secmem.org/blog/2021/07/18/suffix-array-and-lcp/
</span><span class="boring">
</span><span class="boring">fn suffix_array&lt;T: Ord&gt;(s: &amp;[T]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    use std::collections::*;
</span><span class="boring">
</span><span class="boring">    if s.len() == 0 {
</span><span class="boring">        return vec![];
</span><span class="boring">    } else if s.len() == 1 {
</span><span class="boring">        return vec![0];
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let n = s.len();
</span><span class="boring">
</span><span class="boring">    let mut r: Vec&lt;usize&gt; = vec![0; n * 2];
</span><span class="boring">    let map: BTreeMap&lt;_, _&gt; = {
</span><span class="boring">        let mut sorted: Vec&lt;_&gt; = s.iter().collect();
</span><span class="boring">        sorted.sort_unstable();
</span><span class="boring">        sorted
</span><span class="boring">            .into_iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .map(|x| (x.1, x.0 + 1))
</span><span class="boring">            .collect()
</span><span class="boring">    };
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        r[i] = *map.get(&amp;s[i]).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let m = n.max(map.len()) + 1;
</span><span class="boring">    let mut sa: Vec&lt;usize&gt; = (0..n).collect();
</span><span class="boring">    let mut nr: Vec&lt;usize&gt; = vec![0; n * 2];
</span><span class="boring">    let mut cnt: Vec&lt;usize&gt; = vec![0; m];
</span><span class="boring">    let mut idx: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">
</span><span class="boring">    for d in (0..).map(|x| 1 &lt;&lt; x).take_while(|&amp;d| d &lt; n) {
</span><span class="boring">        macro_rules! key {
</span><span class="boring">            ($i:expr) =&gt; {
</span><span class="boring">                if $i + d &gt;= n {
</span><span class="boring">                    (r[$i], 0)
</span><span class="boring">                } else {
</span><span class="boring">                    (r[$i], r[$i + d])
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        (0..m).for_each(|i| cnt[i] = 0);
</span><span class="boring">        (0..n).for_each(|i| cnt[r[i + d]] += 1);
</span><span class="boring">        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
</span><span class="boring">        for i in (0..n).rev() {
</span><span class="boring">            cnt[r[i + d]] -= 1;
</span><span class="boring">            idx[cnt[r[i + d]]] = i;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        (0..m).for_each(|i| cnt[i] = 0);
</span><span class="boring">        (0..n).for_each(|i| cnt[r[i]] += 1);
</span><span class="boring">        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
</span><span class="boring">        for i in (0..n).rev() {
</span><span class="boring">            cnt[r[idx[i]]] -= 1;
</span><span class="boring">            sa[cnt[r[idx[i]]]] = idx[i];
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        nr[sa[0]] = 1;
</span><span class="boring">        for i in 1..n {
</span><span class="boring">            nr[sa[i]] = nr[sa[i - 1]] + if key!(sa[i - 1]) &lt; key!(sa[i]) { 1 } else { 0 };
</span><span class="boring">        }
</span><span class="boring">        std::mem::swap(&amp;mut r, &amp;mut nr);
</span><span class="boring">
</span><span class="boring">        if r[sa[n - 1]] == n {
</span><span class="boring">            break;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    sa
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn sa_lcp&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
</span><span class="boring">    let n = arr.len();
</span><span class="boring">    let sa = suffix_array(arr);
</span><span class="boring">    let mut lcp: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">    let mut isa: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        isa[sa[i]] = i;
</span><span class="boring">    }
</span><span class="boring">    let mut k = 0;
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        if isa[i] != 0 {
</span><span class="boring">            let j = sa[isa[i] - 1];
</span><span class="boring">            while i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; arr[i + k] == arr[j + k] {
</span><span class="boring">                k += 1;
</span><span class="boring">            }
</span><span class="boring">            lcp[isa[i]] = if k != 0 {
</span><span class="boring">                k -= 1;
</span><span class="boring">                k + 1
</span><span class="boring">            } else {
</span><span class="boring">                0
</span><span class="boring">            };
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    (sa, lcp)
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-16"><a class="header" href="#code-16">Code</a></h2>
<pre><code class="language-rust noplayground">// Suffix array and LCP array
// Reference: http://www.secmem.org/blog/2021/07/18/suffix-array-and-lcp/

fn suffix_array&lt;T: Ord&gt;(s: &amp;[T]) -&gt; Vec&lt;usize&gt; {
    use std::collections::*;

    if s.len() == 0 {
        return vec![];
    } else if s.len() == 1 {
        return vec![0];
    }

    let n = s.len();

    let mut r: Vec&lt;usize&gt; = vec![0; n * 2];
    let map: BTreeMap&lt;_, _&gt; = {
        let mut sorted: Vec&lt;_&gt; = s.iter().collect();
        sorted.sort_unstable();
        sorted
            .into_iter()
            .enumerate()
            .map(|x| (x.1, x.0 + 1))
            .collect()
    };
    for i in 0..n {
        r[i] = *map.get(&amp;s[i]).unwrap();
    }

    let m = n.max(map.len()) + 1;
    let mut sa: Vec&lt;usize&gt; = (0..n).collect();
    let mut nr: Vec&lt;usize&gt; = vec![0; n * 2];
    let mut cnt: Vec&lt;usize&gt; = vec![0; m];
    let mut idx: Vec&lt;usize&gt; = vec![0; n];

    for d in (0..).map(|x| 1 &lt;&lt; x).take_while(|&amp;d| d &lt; n) {
        macro_rules! key {
            ($i:expr) =&gt; {
                if $i + d &gt;= n {
                    (r[$i], 0)
                } else {
                    (r[$i], r[$i + d])
                }
            };
        }

        (0..m).for_each(|i| cnt[i] = 0);
        (0..n).for_each(|i| cnt[r[i + d]] += 1);
        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
        for i in (0..n).rev() {
            cnt[r[i + d]] -= 1;
            idx[cnt[r[i + d]]] = i;
        }

        (0..m).for_each(|i| cnt[i] = 0);
        (0..n).for_each(|i| cnt[r[i]] += 1);
        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
        for i in (0..n).rev() {
            cnt[r[idx[i]]] -= 1;
            sa[cnt[r[idx[i]]]] = idx[i];
        }

        nr[sa[0]] = 1;
        for i in 1..n {
            nr[sa[i]] = nr[sa[i - 1]] + if key!(sa[i - 1]) &lt; key!(sa[i]) { 1 } else { 0 };
        }
        std::mem::swap(&amp;mut r, &amp;mut nr);

        if r[sa[n - 1]] == n {
            break;
        }
    }

    sa
}

fn sa_lcp&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
    let n = arr.len();
    let sa = suffix_array(arr);
    let mut lcp: Vec&lt;usize&gt; = vec![0; n];
    let mut isa: Vec&lt;usize&gt; = vec![0; n];
    for i in 0..n {
        isa[sa[i]] = i;
    }
    let mut k = 0;
    for i in 0..n {
        if isa[i] != 0 {
            let j = sa[isa[i] - 1];
            while i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; arr[i + k] == arr[j + k] {
                k += 1;
            }
            lcp[isa[i]] = if k != 0 {
                k -= 1;
                k + 1
            } else {
                0
            };
        }
    }
    (sa, lcp)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convex-hull"><a class="header" href="#convex-hull">Convex Hull</a></h1>
<h2 id="graham-scan"><a class="header" href="#graham-scan">Graham Scan</a></h2>
<p>This snippet excludes every points on vertices from the convex hull, and only includes points of both ends.</p>
<h3 id="snippet"><a class="header" href="#snippet">Snippet</a></h3>
<pre><code class="language-rust noplayground">#[derive(Clone, Debug, Eq, PartialEq)]
struct Point {
    x: i64,
    y: i64,
}

impl Point {
    fn add(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
    fn sub(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
enum Turn {
    CW,
    CCW,
    Zero,
}

fn get_turn(v1: &amp;Point, v2: &amp;Point) -&gt; Turn {
    let prod = v1.x * v2.y - v1.y * v2.x;
    if prod &gt; 0 {
        Turn::CCW
    } else if prod &lt; 0 {
        Turn::CW
    } else {
        Turn::Zero
    }
}

fn compare_ccw(a: &amp;Point, b: &amp;Point) -&gt; std::cmp::Ordering {
    use std::cmp::Ordering;
    if a == b {
        return Ordering::Equal;
    }
    if a.x == 0 &amp;&amp; a.y == 0 {
        return Ordering::Less;
    } else if b.x == 0 &amp;&amp; b.y == 0 {
        return Ordering::Greater;
    }

    let turn = get_turn(a, b);
    if turn == Turn::CCW {
        return Ordering::Less;
    } else if turn == Turn::CW {
        return Ordering::Greater;
    }

    let a_dist = a.x * a.x + a.y * a.y;
    let b_dist = b.x * b.x + b.y * b.y;
    a_dist.cmp(&amp;b_dist)
}

fn convex_hull(arr: &amp;mut [Point]) -&gt; Vec&lt;Point&gt; {
    let pivot = {
        let mut pivot = Point {
            x: i64::MAX,
            y: i64::MAX,
        };
        for v in arr.iter() {
            if pivot.y &gt; v.y || (pivot.y == v.y &amp;&amp; pivot.x &gt; v.x) {
                pivot.x = v.x;
                pivot.y = v.y;
            }
        }
        pivot
    };

    for v in arr.iter_mut() {
        *v = v.sub(&amp;pivot);
    }

    arr.sort_unstable_by(compare_ccw);

    let mut stack = vec![arr[0].clone()];
    let mut i = 1;
    while i &lt; arr.len() {
        if stack.len() == 1 {
            if arr[i] != stack[0] {
                stack.push(arr[i].clone());
            }
            i += 1;
            continue;
        }

        let a = &amp;arr[i];
        let b = &amp;stack[stack.len() - 1];
        let c = &amp;stack[stack.len() - 2];
        match get_turn(&amp;b.sub(c), &amp;a.sub(b)) {
            Turn::CCW =&gt; {
                stack.push(a.clone());
                i += 1;
            }
            Turn::CW =&gt; {
                stack.pop();
            }
            _ =&gt; {
                stack.pop();
                stack.push(a.clone());
                i += 1;
            }
        }
    }

    for v in arr.iter_mut() {
        *v = v.add(&amp;pivot);
    }
    for v in stack.iter_mut() {
        *v = v.add(&amp;pivot);
    }

    stack
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-compression"><a class="header" href="#value-compression">Value Compression</a></h1>
<h2 id="example-17"><a class="header" href="#example-17">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let arr: Vec&lt;i32&gt; = vec![1, 2, 4, 7, 9, 7, 4, 2, 1];

let (compressor, reevaluator) = compress_value(&amp;arr);

let compr: Vec&lt;usize&gt; = arr.iter().map(|x| *compressor.get(x).unwrap()).collect();
println!(&quot;{:?}&quot;, compr);    // [0, 1, 2, 3, 4, 3, 2, 1, 0]

let original: Vec&lt;i32&gt; = compr.iter().map(|&amp;i| *reevaluator[i]).collect();
println!(&quot;{:?}&quot;, original); // [1, 2, 4, 7, 9, 7, 4, 2, 1]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">/// compressor[original_value] = compressed_value
</span><span class="boring">/// reevaluator[compressed_value] = original_value
</span><span class="boring">fn compress_value&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (std::collections::BTreeMap&lt;&amp;T, usize&gt;, Vec&lt;&amp;T&gt;) {
</span><span class="boring">    use std::collections::*;
</span><span class="boring">    let compressor: BTreeMap&lt;&amp;T, usize&gt; = {
</span><span class="boring">        let mut sorted: Vec&lt;_&gt; = arr.iter().collect();
</span><span class="boring">        sorted.sort_unstable();
</span><span class="boring">        sorted.dedup();
</span><span class="boring">        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()
</span><span class="boring">    };
</span><span class="boring">    let reevaluator: Vec&lt;&amp;T&gt; = compressor.iter().map(|x| *x.0).collect();
</span><span class="boring">    (compressor, reevaluator)
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-17"><a class="header" href="#code-17">Code</a></h2>
<h3 id="w-hashmap"><a class="header" href="#w-hashmap">w/ HashMap</a></h3>
<pre><code class="language-rust noplayground">/// compressor[original_value] = compressed_value
/// reevaluator[compressed_value] = original_value
fn compress_value&lt;T: Ord + std::hash::Hash&gt;(
    arr: &amp;[T],
) -&gt; (std::collections::HashMap&lt;&amp;T, usize&gt;, Vec&lt;&amp;T&gt;) {
    use std::collections::*;
    let compressor: HashMap&lt;&amp;T, usize&gt; = {
        let mut sorted: Vec&lt;_&gt; = arr.iter().collect();
        sorted.sort_unstable();
        sorted.dedup();
        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()
    };
    let reevaluator: Vec&lt;&amp;T&gt; = compressor.iter().map(|x| *x.0).collect();
    (compressor, reevaluator)
}</code></pre>
<h3 id="wo-hashmap"><a class="header" href="#wo-hashmap">w/o HashMap</a></h3>
<pre><code class="language-rust noplayground">/// compressor[original_value] = compressed_value
/// reevaluator[compressed_value] = original_value
fn compress_value&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (std::collections::BTreeMap&lt;&amp;T, usize&gt;, Vec&lt;&amp;T&gt;) {
    use std::collections::*;
    let compressor: BTreeMap&lt;&amp;T, usize&gt; = {
        let mut sorted: Vec&lt;_&gt; = arr.iter().collect();
        sorted.sort_unstable();
        sorted.dedup();
        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()
    };
    let reevaluator: Vec&lt;&amp;T&gt; = compressor.iter().map(|x| *x.0).collect();
    (compressor, reevaluator)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-increasing-subsequence"><a class="header" href="#longest-increasing-subsequence">Longest Increasing Subsequence</a></h1>
<h2 id="length"><a class="header" href="#length">Length</a></h2>
<pre><code class="language-rust noplayground">fn lis_len(arr: &amp;[i64]) -&gt; usize {
    let mut table: Vec&lt;i64&gt; = vec![arr[0]];
    for &amp;v in arr[1..].iter() {
        let p = table.partition_point(|&amp;x| x &lt; v);
        if p == table.len() {
            table.push(v);
        } else {
            table[p] = v;
        }
    }
    table.len()
}</code></pre>
<h2 id="sequence"><a class="header" href="#sequence">Sequence</a></h2>
<pre><code class="language-rust noplayground">fn lis(arr: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
    let n = arr.len();
    let mut seq: Vec&lt;i64&gt; = Vec::with_capacity(n + 1);
    seq.push(i64::MIN);
    seq.extend(arr.iter().copied());

    let mut back = vec![0usize; n + 1];
    let mut table = vec![0usize];

    for (i, &amp;v) in seq.iter().enumerate().skip(1) {
        let p = table.partition_point(|&amp;x| seq[x] &lt; v);
        if p == table.len() {
            table.push(i);
        } else {
            table[p] = i;
        }
        back[i] = table[p - 1];
    }

    let mut ptr = *table.last().unwrap();
    let mut ans: Vec&lt;i64&gt; = Vec::with_capacity(table.len() - 1);
    while ptr != 0 {
        ans.push(seq[ptr]);
        ptr = back[ptr];
    }

    ans.reverse();
    ans
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mos"><a class="header" href="#mos">Mo's</a></h1>
<h2 id="mos-with-hilbert-curve-optimization"><a class="header" href="#mos-with-hilbert-curve-optimization">Mo's with Hilbert Curve Optimization</a></h2>
<p>Reference: <a href="https://codeforces.com/blog/entry/61203">https://codeforces.com/blog/entry/61203</a></p>
<pre><code class="language-rust noplayground">/// max_n: maximum number of l and r
/// queries: Vec&lt;(id, l, r)&gt;
fn mos_sort(max_n: u32, queries: &amp;[(u32, u32, u32)]) -&gt; Vec&lt;&amp;(u32, u32, u32)&gt; {
    let n_bit = ceil_pow_2(max_n + 1).trailing_zeros();
    let mut arr: Vec&lt;(u64, &amp;(u32, u32, u32))&gt; = queries.iter().map(|q| (0, q)).collect();
    for q in arr.iter_mut() {
        q.0 = hilbert_order(q.1 .1, q.1 .2, n_bit, 0);
    }
    arr.sort_unstable_by_key(|q| q.0);
    arr.into_iter().map(|x| x.1).collect()
}

#[inline(always)]
fn hilbert_order(x: u32, y: u32, pow: u32, rotate: u32) -&gt; u64 {
    if pow == 0 {
        return 0;
    }
    let hpow: u32 = 1 &lt;&lt; (pow - 1);
    let mut seg: u32 = if x &lt; hpow {
        if y &lt; hpow {
            0
        } else {
            3
        }
    } else {
        if y &lt; hpow {
            1
        } else {
            2
        }
    };
    seg = (seg + rotate) &amp; 3;

    let (nx, ny) = (x &amp; (x ^ hpow), y &amp; (y ^ hpow));
    let nrot = rotate + ROTATE_DELTA[seg as usize] &amp; 3;
    let sub_square_size = 1u64 &lt;&lt; (2 * pow - 2);
    let ans = seg as u64 * sub_square_size;
    let add = hilbert_order(nx, ny, pow - 1, nrot);
    if seg == 1 || seg == 2 {
        ans + add
    } else {
        ans + sub_square_size - add - 1
    }
}

const ROTATE_DELTA: [u32; 4] = [3, 0, 0, 1];

#[inline(always)]
fn ceil_pow_2(y: u32) -&gt; u32 {
    let mut x = y;
    while x != (x &amp; ((!x) + 1)) {
        x -= x &amp; ((!x) + 1);
    }
    if x == y {
        x
    } else {
        x &lt;&lt; 1
    }
}</code></pre>
<h2 id="standard-mos"><a class="header" href="#standard-mos">Standard Mo's</a></h2>
<pre><code class="language-rust noplayground">/// queries: Vec&lt;(id, l, r)&gt;
fn mos_sort(queries: &amp;mut [(u32, u32, u32)]) {
    let nsq = isqrt(queries.len() as u32);
    queries.sort_unstable_by(|&amp;(_, l1, r1), &amp;(_, l2, r2)| {
        if l1 / nsq == l2 / nsq {
            r1.cmp(&amp;r2)
        } else {
            (l1 / nsq).cmp(&amp;(l2 / nsq))
        }
    });
}

fn isqrt(s: u32) -&gt; u32 {
    let mut x0 = s / 2;
    if x0 != 0 {
        let mut x1 = (x0 + s / x0) / 2;
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) / 2;
        }
        x0
    } else {
        s
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arbitrary-precision-integer"><a class="header" href="#arbitrary-precision-integer">Arbitrary-Precision Integer</a></h1>
<h2 id="example-18"><a class="header" href="#example-18">Example</a></h2>
<pre><code class="language-rust noplayground">use bigint::*;

let _a = Int::from(0i8);
let b = Int::from(4i16);
let c = Int::from(11i32);

let mut x = Int::from(30i64);
x *= &amp;b;
println!(&quot;{}&quot;, x);

let mut y = Int::from_str(&quot;123456789123456789123456789123456789&quot;).unwrap();
let z = &amp;y * &amp;c;
println!(&quot;{}&quot;, y);</code></pre>
<h2 id="code-18"><a class="header" href="#code-18">Code</a></h2>
<pre><code class="language-rust noplayground">mod bigint {
    use core::{
        fmt::Display,
        num::ParseIntError,
        ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign},
        str::FromStr,
    };

    const CHUNK: usize = 5;
    const TENS: i64 = 100000;

    #[derive(Clone, Default, Debug, PartialEq, Eq)]
    pub struct Uint(Vec&lt;i64&gt;);

    macro_rules! flatten {
        ($uint:expr) =&gt; {
            let mut carry: i64 = 0;
            for i in 0..$uint.0.len() {
                $uint.0[i] += carry;
                carry = $uint.0[i].div_euclid(TENS);
                $uint.0[i] -= carry * TENS;
            }
            while carry != 0 {
                $uint.0.push(carry.rem_euclid(TENS));
                carry = carry.div_euclid(TENS);
            }
            while let Some(&amp;x) = $uint.0.last() {
                if x != 0 {
                    break;
                }
                $uint.0.pop();
            }
        };
    }

    macro_rules! impl_from_for_uint {
        ($($t:ty),*) =&gt; {
            $(
                impl From&lt;$t&gt; for Uint {
                    fn from(x: $t) -&gt; Self {
                        let mut x = Self(vec![x as i64]);
                        flatten!(x);
                        x
                    }
                }
            )*
        };
    }
    impl_from_for_uint!(u8, u16, u32, u64, u128, usize);

    impl FromStr for Uint {
        type Err = ParseIntError;
        fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
            let s = s.trim_start_matches(&quot;0&quot;);
            if s.is_empty() {
                return Ok(Self(vec![]));
            }
            let mut arr: Vec&lt;i64&gt; = Vec::with_capacity(s.len() / CHUNK + 2);
            let mut s = s;
            while s.len() &gt; CHUNK {
                let (l, r) = s.split_at(s.len() - CHUNK);
                arr.push(r.parse()?);
                s = l;
            }
            arr.push(s.parse()?);
            Ok(Self(arr))
        }
    }

    impl Display for Uint {
        fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
            write!(f, &quot;{}&quot;, *self.0.last().unwrap_or(&amp;0))?;
            for &amp;v in self.0.iter().rev().skip(1) {
                write!(f, &quot;{:0CHUNK$}&quot;, v)?;
            }
            Ok(())
        }
    }

    impl PartialOrd for Uint {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;core::cmp::Ordering&gt; {
            use core::cmp::Ordering;
            match self.0.len().cmp(&amp;other.0.len()) {
                Ordering::Equal =&gt; {
                    for i in (0..self.0.len()).rev() {
                        let x = self.0[i].cmp(&amp;other.0[i]);
                        if x != Ordering::Equal {
                            return Some(x);
                        }
                    }
                    Some(Ordering::Equal)
                }
                x =&gt; Some(x),
            }
        }
    }

    impl Ord for Uint {
        fn cmp(&amp;self, other: &amp;Self) -&gt; core::cmp::Ordering {
            use core::cmp::Ordering;
            match self.0.len().cmp(&amp;other.0.len()) {
                Ordering::Equal =&gt; {
                    for i in (0..self.0.len()).rev() {
                        let x = self.0[i].cmp(&amp;other.0[i]);
                        if x != Ordering::Equal {
                            return x;
                        }
                    }
                    Ordering::Equal
                }
                x =&gt; x,
            }
        }
    }

    impl AddAssign&lt;&amp;Uint&gt; for Uint {
        fn add_assign(&amp;mut self, rhs: &amp;Uint) {
            if self.0.len() &lt; rhs.0.len() {
                for i in 0..self.0.len() {
                    self.0[i] += rhs.0[i];
                }
                self.0.extend_from_slice(&amp;rhs.0[self.0.len()..]);
            } else {
                for i in 0..rhs.0.len() {
                    self.0[i] += rhs.0[i];
                }
            }

            flatten!(self);
        }
    }

    impl Add for &amp;Uint {
        type Output = Uint;
        fn add(self, rhs: Self) -&gt; Self::Output {
            let mut c = self.clone();
            c += rhs;
            c
        }
    }

    impl SubAssign&lt;&amp;Uint&gt; for Uint {
        fn sub_assign(&amp;mut self, rhs: &amp;Uint) {
            // Panics if self.len() &lt; rhs.len(): Think it as a underflow error
            for (i, &amp;v) in rhs.0.iter().enumerate() {
                self.0[i] -= v;
            }

            flatten!(self);
        }
    }

    impl Sub for &amp;Uint {
        type Output = Uint;
        fn sub(self, rhs: Self) -&gt; Self::Output {
            let mut c = self.clone();
            c -= rhs;
            c
        }
    }

    const NTT_THRES: usize = 5000;
    const KARAT_THRES: usize = 30;

    impl Mul for &amp;Uint {
        type Output = Uint;
        fn mul(self, rhs: Self) -&gt; Self::Output {
            let max_len = self.0.len().max(rhs.0.len());
            let max_2len = polymul::ceil_pow2(max_len);

            // For performance reasons regarding vector copying, we determine whether to use
            // NTT or not here.
            let mut ans = Uint(if max_2len &gt; NTT_THRES {
                polymul::convolute(&amp;self.0, &amp;rhs.0)
            } else {
                let f: Vec&lt;i64&gt; = self
                    .0
                    .iter()
                    .copied()
                    .chain(core::iter::repeat(0))
                    .take(max_2len)
                    .collect();

                let g: Vec&lt;i64&gt; = rhs
                    .0
                    .iter()
                    .copied()
                    .chain(core::iter::repeat(0))
                    .take(max_2len)
                    .collect();

                polymul::mult_2pow(&amp;f, &amp;g)
            });

            flatten!(ans);
            ans
        }
    }

    impl MulAssign&lt;&amp;Uint&gt; for Uint {
        fn mul_assign(&amp;mut self, rhs: &amp;Uint) {
            let x = &amp;*self * rhs;
            *self = x;
        }
    }

    mod polymul {
        pub fn ceil_pow2(n: usize) -&gt; usize {
            if n == 0 {
                return 0;
            }
            let mut m = n;
            while m != m &amp; (!m + 1) {
                m -= m &amp; (!m + 1);
            }
            if n == m {
                n
            } else {
                m * 2
            }
        }

        pub fn mult_2pow(f: &amp;[i64], g: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
            if f.len() &gt; super::KARAT_THRES {
                return karatsuba(f, g);
            }

            let mut ans = vec![0; 2 * f.len()];
            for (i, &amp;a) in f.iter().enumerate() {
                for (j, &amp;b) in g.iter().enumerate() {
                    ans[i + j] += a * b;
                }
            }

            ans
        }

        // Length of f = Length of g = 2n = 2^(k+1)
        fn karatsuba(f: &amp;[i64], g: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
            if f.len() == 1 {
                return vec![f[0] * g[0]];
            }
            let n = f.len() / 2;
            let k = n.trailing_zeros();
            debug_assert_eq!(n, 1 &lt;&lt; k);

            let (fl, fr) = (&amp;f[..n], &amp;f[n..]);
            let (gl, gr) = (&amp;g[..n], &amp;g[n..]);

            let flgl = mult_2pow(fl, gl);
            let frgr = mult_2pow(fr, gr);

            let fsum: Vec&lt;_&gt; = fl.iter().zip(fr.iter()).map(|(&amp;a, &amp;b)| (a + b)).collect();
            let gsum: Vec&lt;_&gt; = gl.iter().zip(gr.iter()).map(|(&amp;a, &amp;b)| (a + b)).collect();
            let fsgs = mult_2pow(&amp;fsum, &amp;gsum);

            let mut ans: Vec&lt;_&gt; = flgl.iter().copied().chain(frgr.iter().copied()).collect();
            for i in 0..fsgs.len() {
                ans[i + n] += fsgs[i];
            }
            for (i, v) in flgl
                .iter()
                .zip(frgr.iter())
                .map(|(&amp;a, &amp;b)| (a + b))
                .enumerate()
            {
                ans[i + n] -= v;
            }

            ans
        }

        const P2INV: i64 = 253522377;

        pub fn convolute(a: &amp;[i64], b: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
            let c1 = ntt1::convolute(a, b);
            let c2 = ntt2::convolute(a, b);

            c1.into_iter()
                .zip(c2.into_iter())
                .map(|(a1, a2)| {
                    let j = ((a1 + ntt1::NTT_P as i64 - a2) * P2INV) % ntt1::NTT_P as i64;
                    ntt2::NTT_P as i64 * j + a2
                })
                .collect()
        }

        // FFT_constname convention following https://algoshitpo.github.io/2020/05/20/fft-ntt/
        macro_rules! impl_ntt {
            ($modname:ident, $nttp:expr, $ntta:expr, $nttb:expr, $nttw:expr) =&gt; {
                mod $modname {
                    pub const NTT_P: u64 = $nttp;
                    const NTT_A: u64 = $ntta;
                    const NTT_B: u32 = $nttb;
                    const NTT_W: u64 = $nttw;

                    fn ceil_pow2(n: usize) -&gt; usize {
                        let mut x: usize = 0;
                        while (1 &lt;&lt; x) &lt; n {
                            x += 1;
                        }
                        x
                    }

                    pub fn convolute(a: &amp;[i64], b: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
                        let nlen = 1 &lt;&lt; ceil_pow2(a.len() + b.len());
                        let mut arr = vec![0; nlen];
                        let mut brr = vec![0; nlen];
                        for (i, &amp;a) in a.iter().enumerate() {
                            arr[i] = a as u64;
                        }
                        for (i, &amp;b) in b.iter().enumerate() {
                            brr[i] = b as u64;
                        }

                        inplace_ntt(&amp;mut arr);
                        inplace_ntt(&amp;mut brr);
                        let mut crr: Vec&lt;_&gt; =
                            arr.iter().zip(brr.iter()).map(|(&amp;a, &amp;b)| a * b).collect();
                        inplace_intt(&amp;mut crr);
                        crr.iter().map(|&amp;x| x as i64).collect()
                    }

                    #[inline(always)]
                    fn rem_pow(mut base: u64, exp: u64) -&gt; u64 {
                        let mut result = 1u64;
                        for exp in core::iter::successors(Some(exp), |x| Some(x &gt;&gt; 1))
                            .take_while(|&amp;v| v != 0)
                        {
                            if exp &amp; 1 != 0 {
                                result *= base;
                                result %= NTT_P;
                            }
                            base *= base;
                            base %= NTT_P;
                        }
                        result
                    }

                    // unity(n, 1) ** (1&lt;&lt;n) = 1
                    fn unity(n: u32, k: u64) -&gt; u64 {
                        rem_pow(rem_pow(NTT_W, NTT_A), k &lt;&lt; (NTT_B - n))
                    }

                    fn recip(x: u64) -&gt; u64 {
                        rem_pow(x, NTT_P - 2)
                    }

                    // Reverses k trailing bits of n
                    fn reverse_trailing_bits(n: usize, k: u32) -&gt; usize {
                        let mut r: usize = 0;
                        for i in 0..k {
                            r |= ((n &gt;&gt; i) &amp; 1) &lt;&lt; (k - i - 1);
                        }
                        r
                    }

                    fn inplace_ntt(arr: &amp;mut [u64]) {
                        let n: usize = arr.len();
                        let k = n.trailing_zeros();
                        assert_eq!(n, 1 &lt;&lt; k);

                        for i in 0..n {
                            let j = reverse_trailing_bits(i, k);
                            if i &lt; j {
                                arr.swap(i, j);
                            }
                        }

                        for x in 0..k {
                            let base: u64 = unity(x + 1, 1);
                            let s = 1 &lt;&lt; x;
                            for i in (0..n).step_by(s &lt;&lt; 1) {
                                let mut mult: u64 = 1;
                                for j in 0..s {
                                    let tmp = (arr[i + j + s] * mult) % NTT_P;
                                    arr[i + j + s] = (arr[i + j] + NTT_P - tmp) % NTT_P;
                                    arr[i + j] = (arr[i + j] + tmp) % NTT_P;
                                    mult *= base;
                                    mult %= NTT_P;
                                }
                            }
                        }
                    }

                    fn inplace_intt(arr: &amp;mut [u64]) {
                        let n: usize = arr.len();
                        let k = n.trailing_zeros();
                        assert_eq!(n, 1 &lt;&lt; k);

                        for i in 0..n {
                            let j = reverse_trailing_bits(i, k);
                            if i &lt; j {
                                arr.swap(i, j);
                            }
                        }

                        for x in 0..k {
                            let base: u64 = recip(unity(x + 1, 1));
                            let s = 1 &lt;&lt; x;
                            for i in (0..n).step_by(s &lt;&lt; 1) {
                                let mut mult: u64 = 1;
                                for j in 0..s {
                                    let tmp = (arr[i + j + s] * mult) % NTT_P;
                                    arr[i + j + s] = (arr[i + j] + NTT_P - tmp) % NTT_P;
                                    arr[i + j] = (arr[i + j] + tmp) % NTT_P;
                                    mult *= base;
                                    mult %= NTT_P;
                                }
                            }
                        }

                        let r = recip(n as u64);
                        for f in arr.iter_mut() {
                            *f *= r;
                            *f %= NTT_P;
                        }
                    }
                }
            };
        }

        impl_ntt!(ntt1, 2281701377, 17, 27, 3);
        impl_ntt!(ntt2, 998244353, 119, 23, 3);
    }

    #[derive(Clone, Copy, PartialEq, Eq, Debug)]
    enum Sign {
        Neg,
        Pos, // Includes 0
    }
    use Sign::*;

    #[derive(Clone, Debug, PartialEq, Eq)]
    pub struct Int {
        sign: Sign,
        nat: Uint,
    }

    macro_rules! impl_from_for_int {
        ($($u:ty, $s:ty);*) =&gt; {
            $(
                impl From&lt;$u&gt; for Int {
                    fn from(x: $u) -&gt; Self {
                        Self { sign: Pos, nat: x.into() }
                    }
                }
                impl From&lt;$s&gt; for Int {
                    fn from(x: $s) -&gt; Self {
                        if x &lt; 0 {
                            Self { sign: Neg, nat: ((-x) as $u).into() }
                        } else {
                            Self { sign: Pos, nat: (x as $u).into() }
                        }
                    }
                }
            )*
        };
    }

    impl_from_for_int!(u8, i8; u16, i16; u32, i32; u64, i64; u128, i128; usize, isize);

    impl FromStr for Int {
        type Err = ParseIntError;
        fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
            if s.len() == 0 {
                panic!(&quot;Empty string - TODO: Add a proper error propagation&quot;);
            }
            let mut x = match s.strip_prefix(&quot;-&quot;) {
                Some(t) =&gt; Self {
                    sign: Neg,
                    nat: t.parse()?,
                },
                None =&gt; Self {
                    sign: Pos,
                    nat: s.parse()?,
                },
            };
            if x.sign == Neg &amp;&amp; x.nat.0.len() == 0 {
                x.sign = Pos;
            }
            Ok(x)
        }
    }

    impl Display for Int {
        fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
            if let Neg = self.sign {
                write!(f, &quot;-&quot;)?;
            }
            write!(f, &quot;{}&quot;, self.nat)
        }
    }

    impl PartialOrd for Int {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;core::cmp::Ordering&gt; {
            use core::cmp::Ordering;
            match (self.sign, other.sign) {
                (Neg, Neg) =&gt; other.nat.partial_cmp(&amp;self.nat),
                (Neg, Pos) =&gt; Some(Ordering::Less),
                (Pos, Neg) =&gt; Some(Ordering::Greater),
                (Pos, Pos) =&gt; self.nat.partial_cmp(&amp;other.nat),
            }
        }
    }

    impl Ord for Int {
        fn cmp(&amp;self, other: &amp;Self) -&gt; core::cmp::Ordering {
            use core::cmp::Ordering;
            match (self.sign, other.sign) {
                (Neg, Neg) =&gt; other.nat.cmp(&amp;self.nat),
                (Neg, Pos) =&gt; Ordering::Less,
                (Pos, Neg) =&gt; Ordering::Greater,
                (Pos, Pos) =&gt; self.nat.cmp(&amp;other.nat),
            }
        }
    }

    impl AddAssign&lt;&amp;Int&gt; for Int {
        fn add_assign(&amp;mut self, rhs: &amp;Int) {
            match (self.sign, rhs.sign) {
                (Neg, Neg) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
                (Neg, Pos) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Pos;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Neg) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Neg;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Pos) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
            }
        }
    }

    impl Add for &amp;Int {
        type Output = Int;
        fn add(self, rhs: Self) -&gt; Self::Output {
            let mut ans = self.clone();
            ans += rhs;
            ans
        }
    }

    impl SubAssign&lt;&amp;Int&gt; for Int {
        fn sub_assign(&amp;mut self, rhs: &amp;Int) {
            match (self.sign, rhs.sign) {
                (Neg, Pos) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
                (Neg, Neg) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Pos;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Pos) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Neg;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Neg) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
            }
        }
    }

    impl Sub for &amp;Int {
        type Output = Int;
        fn sub(self, rhs: Self) -&gt; Self::Output {
            let mut ans = self.clone();
            ans -= &amp;rhs;
            ans
        }
    }

    impl Mul for &amp;Int {
        type Output = Int;
        fn mul(self, rhs: Self) -&gt; Self::Output {
            let x = &amp;self.nat * &amp;rhs.nat;
            if x.0.len() == 0 || self.sign == rhs.sign {
                Int { sign: Pos, nat: x }
            } else {
                Int { sign: Neg, nat: x }
            }
        }
    }

    impl MulAssign&lt;&amp;Int&gt; for Int {
        fn mul_assign(&amp;mut self, rhs: &amp;Int) {
            let x = &amp;self.nat * &amp;rhs.nat;
            self.nat = x;
            if self.nat.0.len() == 0 || self.sign == rhs.sign {
                self.sign = Pos;
            } else {
                self.sign = Neg;
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-io"><a class="header" href="#fast-io">Fast IO</a></h1>
<p><code>get_input()</code> returns every text read from the standard input, using <code>mmap</code>. Because of this, the input must be read by file redirection as <code>cargo run --release &lt; input.txt</code>. THIS FUNCTION DOESN'T WORK ON WINDOWS. THE FUNCTION MUST BE REWRITTEN MANUALLY TO BE USED FOR <u><strong>CODEFORCES</strong></u>, WHICH RUNS CODES ON WINDOWS.</p>
<p><code>Scanner</code> is a structure which can read either lines or tokens out of a string. <code>Scanner::tokenize(str)</code> tokenizes <code>str</code> by whitespaces, such as <code> </code> spaces, <code>\t</code> tabs, and <code>\n</code> newlines.</p>
<p><code>sc</code> in <code>main()</code> function is a scanner instance, which splits <code>input_str</code> by whitespaces. <code>sc.next_str()</code> returns the next token as <code>&amp;str</code>. If the input has been exhausted, the program panics. <code>sc.next::&lt;T&gt;()</code> reads the next token, parses it into a type <code>T</code>, and returns it. If the input has been exhausted or the parse fails, the program panics.</p>
<p>Both function has its &quot;Option&quot; equivalents. <code>sc.next_str_option()</code> returns the next token as <code>Some(&amp;str)</code>. This function returns <code>None</code> instead of panicing the whole program, compared to <code>sc.next_str()</code>. <code>sc.next_option()</code> works just like <code>sc.next()</code> except that it returns <code>Option&lt;T&gt;</code> so that the function returns <code>None</code> instead of panicing. These functions are useful when the code needs to detect <code>EOF</code>.</p>
<p><code>next!</code> macros are for easy-typing for inputs. <code>next!()</code> is equivalent to <code>sc.next()</code>. You can specify the return type of it by using <code>next!(T)</code>. Multiple types can also be used as arguments, delimited by spaces: <code>next!(T U V)</code> returns a tuple <code>(T, U, V)</code>. Lastly, <code>next!(str)</code> is equivalent to <code>sc.next_str()</code>.</p>
<p><code>out!</code> and <code>outln!</code> are just the same with <code>print!</code> and <code>println!</code>, but the stdout flush is buffered for faster output.</p>
<h3 id="example-19"><a class="header" href="#example-19">Example</a></h3>
<pre><code class="language-rust noplayground">// Main
let n: usize = next!();      // Identical to `let n: usize = sc.next();`
let m = next!(usize);        // Identical to `let m = sc.next::&lt;usize&gt;();`
let (a, b) = next!(u32 i64); // Identical to `let (a, b): (u32, i64) = (sc.next(), sc.next());`
let arr: Vec&lt;u64&gt; = (0..n).map(|_| next!()).collect();

let word = next!(str);

out!(&quot;{} &quot;, a);
outln!(&quot;{}&quot;, b);
outln!(&quot;{:?}&quot;, [n, m]);</code></pre>
<h2 id="code-19"><a class="header" href="#code-19">Code</a></h2>
<h3 id="for-linux-almost-every-ojs-including-atcoder"><a class="header" href="#for-linux-almost-every-ojs-including-atcoder">For Linux (Almost every OJs including AtCoder)</a></h3>
<pre><code class="language-rust noplayground">#![no_main]

#[no_mangle]
fn main() -&gt; i32 {
    // FastIO
    use fastio::*;
    let input_str = get_input();
    let mut sc: Splitter&lt;_&gt; = Splitter::new(input_str, |s| s.split_ascii_whitespace());
    use std::io::*;
    let stdout = stdout();
    let wr = &amp;mut BufWriter::new(stdout.lock());

    // FastIO Macros
    macro_rules! next {
        () =&gt; { sc.next() };
        ($($t:ty) +) =&gt; { ($(sc.next::&lt;$t&gt;()),+) };
    }
    macro_rules! out { ($($arg:tt)*) =&gt; { write!(wr, $($arg)*).ok(); }; }
    macro_rules! outln { ($($arg:tt)*) =&gt; { writeln!(wr, $($arg)*).ok(); }; }

    // Main

    wr.flush().unwrap();
    0
}

mod fastio {
    use core::{slice::*, str::*};

    #[link(name = &quot;c&quot;)]
    extern &quot;C&quot; {
        fn mmap(addr: usize, len: usize, p: i32, f: i32, fd: i32, o: i64) -&gt; *mut u8;
        fn fstat(fd: i32, stat: *mut usize) -&gt; i32;
    }

    pub fn get_input() -&gt; &amp;'static str {
        let mut stat = [0; 20];
        unsafe { fstat(0, stat.as_mut_ptr()) };
        let buffer = unsafe { mmap(0, stat[6], 1, 2, 0, 0) };
        unsafe { from_utf8_unchecked(from_raw_parts(buffer, stat[6])) }
    }

    pub struct Splitter&lt;I: Iterator&gt; {
        it: I,
    }

    impl&lt;'a, 'b: 'a, T: Iterator&gt; Splitter&lt;T&gt; {
        pub fn new(s: &amp;'b str, split: impl FnOnce(&amp;'a str) -&gt; T) -&gt; Self {
            Self { it: split(s) }
        }
    }

    impl&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; Splitter&lt;I&gt; {
        pub fn next&lt;T: FromStr&gt;(&amp;mut self) -&gt; T {
            self.it.next().unwrap().parse().ok().unwrap()
        }
        pub fn next_str(&amp;mut self) -&gt; &amp;'a str {
            self.it.next().unwrap()
        }
        pub fn next_opt&lt;T: FromStr&gt;(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.it.next().and_then(|s| s.parse().ok())
        }
        pub fn next_str_opt(&amp;mut self) -&gt; Option&lt;&amp;'a str&gt; {
            self.it.next()
        }
    }
}</code></pre>
<h3 id="for-windows-codeforces"><a class="header" href="#for-windows-codeforces">For Windows (Codeforces)</a></h3>
<pre><code class="language-rust noplayground">#![no_main]

#[no_mangle]
fn main() -&gt; i32 {
    // FastIO
    use fastio::*;
    let input_str = get_input();
    let mut sc: Splitter&lt;_&gt; = Splitter::new(&amp;input_str, |s| s.split_ascii_whitespace());
    use std::io::*;
    let stdout = stdout();
    let wr = &amp;mut BufWriter::new(stdout.lock());

    // FastIO Macros
    macro_rules! next {
        () =&gt; { sc.next() };
        ($($t:ty) +) =&gt; { ($(sc.next::&lt;$t&gt;()),+) };
    }
    macro_rules! out { ($($arg:tt)*) =&gt; { write!(wr, $($arg)*).ok(); }; }
    macro_rules! outln { ($($arg:tt)*) =&gt; { writeln!(wr, $($arg)*).ok(); }; }

    // Main

    wr.flush().unwrap();
    0
}

mod fastio {
    use std::{io::*, str::*};

    pub fn get_input() -&gt; String {
        let mut buf = String::new();
        stdin().read_to_string(&amp;mut buf).unwrap();
        buf
    }

    pub struct Splitter&lt;I: Iterator&gt; {
        it: I,
    }

    impl&lt;'a, 'b: 'a, T: Iterator&gt; Splitter&lt;T&gt; {
        pub fn new(s: &amp;'b str, split: impl FnOnce(&amp;'a str) -&gt; T) -&gt; Self {
            Self { it: split(s) }
        }
    }

    impl&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; Splitter&lt;I&gt; {
        pub fn next&lt;T: FromStr&gt;(&amp;mut self) -&gt; T {
            self.it.next().unwrap().parse().ok().unwrap()
        }
        pub fn next_str(&amp;mut self) -&gt; &amp;'a str {
            self.it.next().unwrap()
        }
        pub fn next_opt&lt;T: FromStr&gt;(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.it.next().and_then(|s| s.parse().ok())
        }
        pub fn next_str_opt(&amp;mut self) -&gt; Option&lt;&amp;'a str&gt; {
            self.it.next()
        }
    }
}</code></pre>
<h3 id="with-faster-print-old"><a class="header" href="#with-faster-print-old">With faster print (Old)</a></h3>
<pre><code class="language-rust noplayground">fn main() {
    // FastIO
    use fastio::*;
    let input_str = get_input();
    let mut sc: Scanner&lt;_&gt; = Scanner::tokenize(input_str);
    let mut out = Flusher::with_capacity(1 &lt;&lt; 18);

    // FastIO Macros
    macro_rules! next {
        () =&gt; { sc.next() };
        (str) =&gt; { sc.next_str() };
        ($($t:ty) +) =&gt; { ($(sc.next::&lt;$t&gt;()),+) };
    }
    macro_rules! out { ($($arg:tt),*) =&gt; {$( $arg.push_num(&amp;mut out); out.buf.push(b' '); )*}; }
    macro_rules! outln { ($($arg:tt),*) =&gt; { out!($($arg),*); out.buf.push(b'\n'); } }

    // Main
    let n: usize = next!();
    outln!(n);
}

mod fastio {
    use std::io::{stdout, Write};

    extern &quot;C&quot; {
        fn mmap(addr: usize, len: usize, p: i32, f: i32, fd: i32, o: i64) -&gt; *mut u8;
        fn fstat(fd: i32, stat: *mut usize) -&gt; i32;
    }

    pub fn get_input() -&gt; &amp;'static str {
        let mut stat = [0; 20];
        unsafe { fstat(0, (&amp;mut stat).as_mut_ptr()) };
        let buffer = unsafe { mmap(0, stat[6], 1, 2, 0, 0) };
        unsafe { std::str::from_utf8_unchecked(std::slice::from_raw_parts(buffer, stat[6])) }
    }

    pub struct Scanner&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; {
        it: I,
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::SplitAsciiWhitespace&lt;'a&gt;&gt; {
        pub fn tokenize(s: &amp;'a str) -&gt; Self {
            Self {
                it: s.split_ascii_whitespace(),
            }
        }
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::Lines&lt;'a&gt;&gt; {
        pub fn lines(s: &amp;'a str) -&gt; Self {
            Self { it: s.lines() }
        }
    }

    impl&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; Scanner&lt;'a, I&gt; {
        #[inline(always)]
        pub fn next&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; T {
            self.it.next().unwrap().parse().ok().unwrap()
        }
        #[inline(always)]
        pub fn next_str(&amp;mut self) -&gt; &amp;'a str {
            self.it.next().unwrap()
        }
        #[inline(always)]
        pub fn next_option&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.it.next().and_then(|s| s.parse().ok())
        }
        #[inline(always)]
        pub fn next_str_option(&amp;mut self) -&gt; Option&lt;&amp;'a str&gt; {
            self.it.next()
        }
    }

    pub struct Flusher {
        pub buf: Vec&lt;u8&gt;,
    }

    impl Flusher {
        pub fn with_capacity(cap: usize) -&gt; Self {
            Self {
                buf: Vec::with_capacity(cap),
            }
        }
    }

    impl Drop for Flusher {
        fn drop(&amp;mut self) {
            stdout().write_all(&amp;self.buf).ok();
        }
    }

    pub trait PushPrint {
        fn push_num(self, wr: &amp;mut Flusher);
    }

    impl PushPrint for &amp;str {
        fn push_num(self, wr: &amp;mut Flusher) {
            wr.buf.extend_from_slice(self.as_bytes());
        }
    }

    macro_rules! impl_pushprint {
        ($($i:ty;$u:ty) *) =&gt; {
            $(
                impl PushPrint for $i {
                    fn push_num(self, wr: &amp;mut Flusher) {
                        if self &lt; 0 {
                            wr.buf.push(b'-');
                            ((-self) as $u).push_num(wr);
                        } else {
                            (self as $u).push_num(wr);
                        }
                    }
                }

                impl PushPrint for $u {
                    fn push_num(self, wr: &amp;mut Flusher) {
                        if self &gt;= 10 {
                            (self / 10).push_num(wr);
                        }
                        wr.buf.push((self % 10) as u8 + b'0');
                    }
                }
            )*
        };
    }

    impl_pushprint!(i8;u8 i16;u16 i32;u32 i64;u64 i128;u128 isize;usize);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<pre><code class="language-rust noplayground">macro_rules! count_tts {
    () =&gt; { 0 };
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 };
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 };
}

// let map: HashMap&lt;i64, i64&gt; = hashmap![1,1; 2,2; 3,3];
macro_rules! hashmap {
    ($($k:expr,$v:expr);*) =&gt; {{
        let mut map = HashMap::with_capacity(count_tts![$($k )*]);
        $( map.insert($k, $v); )*
        map
    }}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zeroone-trait-deprecated"><a class="header" href="#zeroone-trait-deprecated">Zero/One Trait (Deprecated)</a></h1>
<p>This trait was used for representing numeric values, but the author has learned that <code>Into</code> and <code>From</code> traits exist, hence this trait is now deprecated. Any other templates which includes or requires to include this trait will be fixed soon.</p>
<pre><code class="language-rust noplayground">pub trait ZeroOne: Sized + Copy {
    fn zero() -&gt; Self;
    fn one() -&gt; Self;
}

macro_rules! impl_zero_one {
    ($($ty:ty) *) =&gt; { $(
        impl ZeroOne for $ty {
            #[inline(always)]
            fn one() -&gt; Self {1}
            #[inline(always)]
            fn zero() -&gt; Self {0}
        }
    )+ };
}

impl_zero_one!(isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128);</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
