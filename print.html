<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js nord_light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Snippets for Competitive Programming</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "nord_dark" : "nord_light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('nord_light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Algebra</li><li class="chapter-item expanded "><a href="algebra/gcd.html"><strong aria-hidden="true">1.</strong> GCD, LCM</a></li><li class="chapter-item expanded "><a href="algebra/extgcd.html"><strong aria-hidden="true">2.</strong> Extended Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="algebra/crt.html"><strong aria-hidden="true">3.</strong> Chinese Remainder Theorem</a></li><li class="chapter-item expanded "><a href="algebra/millerrabin.html"><strong aria-hidden="true">4.</strong> Deterministic Miller-Rabin Primality Test</a></li><li class="chapter-item expanded "><a href="algebra/pollardrho.html"><strong aria-hidden="true">5.</strong> Pollard's Rho Algorithm</a></li><li class="chapter-item expanded affix "><li class="part-title">Numerical Algorithms</li><li class="chapter-item expanded "><a href="numerical/isqrt.html"><strong aria-hidden="true">6.</strong> Integer Square Root</a></li><li class="chapter-item expanded "><a href="numerical/linrec/intro.html"><strong aria-hidden="true">7.</strong> Linear Recurrence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="numerical/linrec/berlekamp.html"><strong aria-hidden="true">7.1.</strong> Berlekamp-Massey</a></li><li class="chapter-item expanded "><a href="numerical/linrec/kitamasa.html"><strong aria-hidden="true">7.2.</strong> Kitamasa</a></li><li class="chapter-item expanded "><a href="numerical/linrec/bostanmori.html"><strong aria-hidden="true">7.3.</strong> Bostan-Mori</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Data Structures</li><li class="chapter-item expanded "><a href="datastructure/matrix.html"><strong aria-hidden="true">8.</strong> Fast n-dimensional Array</a></li><li class="chapter-item expanded "><a href="datastructure/bitarray.html"><strong aria-hidden="true">9.</strong> Bit Array</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/intro.html"><strong aria-hidden="true">10.</strong> Segment Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datastructure/segtree/segtree.html"><strong aria-hidden="true">10.1.</strong> Segment Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/fenwick.html"><strong aria-hidden="true">10.2.</strong> Fenwick Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/lazyseg.html"><strong aria-hidden="true">10.3.</strong> Lazy Segment Tree</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Graphs</li><li class="chapter-item expanded "><a href="graphs/adjlist.html"><strong aria-hidden="true">11.</strong> Adjacency List Graph Representation</a></li><li class="chapter-item expanded "><a href="graphs/dsu.html"><strong aria-hidden="true">12.</strong> Disjoint Set Union</a></li><li class="chapter-item expanded "><a href="graphs/scc.html"><strong aria-hidden="true">13.</strong> Strongly Connected Components</a></li><li class="chapter-item expanded "><a href="graphs/2sat.html"><strong aria-hidden="true">14.</strong> 2-SAT</a></li><li class="chapter-item expanded affix "><li class="part-title">Strings</li><li class="chapter-item expanded "><a href="strings/kmp.html"><strong aria-hidden="true">15.</strong> KMP</a></li><li class="chapter-item expanded "><a href="strings/manacher.html"><strong aria-hidden="true">16.</strong> Manacher</a></li><li class="chapter-item expanded "><a href="strings/salcp.html"><strong aria-hidden="true">17.</strong> Suffix Array and LCP Array</a></li><li class="chapter-item expanded affix "><li class="part-title">Geometry</li><li class="chapter-item expanded "><a href="geometry/convexhull.html"><strong aria-hidden="true">18.</strong> Convex Hull</a></li><li class="chapter-item expanded affix "><li class="part-title">Unclassified</li><li class="chapter-item expanded "><a href="unclass/valcomp.html"><strong aria-hidden="true">19.</strong> Value Compression</a></li><li class="chapter-item expanded "><a href="unclass/lis.html"><strong aria-hidden="true">20.</strong> Longest Increasing Subsequence</a></li><li class="chapter-item expanded "><a href="unclass/mos.html"><strong aria-hidden="true">21.</strong> Mo's</a></li><li class="chapter-item expanded affix "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="misc/fastio.html"><strong aria-hidden="true">22.</strong> Base Template</a></li><li class="chapter-item expanded "><a href="misc/macro.html"><strong aria-hidden="true">23.</strong> Macros</a></li><li class="chapter-item expanded "><a href="misc/zero_one_trait.html"><strong aria-hidden="true">24.</strong> Zero/One Trait (Deprecated)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="nord_light">Nord Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="nord_dark">Nord Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Snippets for Competitive Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BamgoeSN/rust-ps-md" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is a collection of snippets for competitive programming and problem solving with Rust. All you have to do for using snippets is simply copying snippets you need and pasting them into your code.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Each snippet can be easily copied by clicking on the copy icon <i class="fa fa-copy"></i> at the top right corner of a code block.</p>
<p>Clicking on the search icon <i class="fa fa-search"></i> in the menu bar, or pressing the <code>S</code> key on the keyboard will open an input box for entering search terms. Any keywords included in this book can be searched by typing it in the box.</p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other Resources</a></h2>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<ul>
<li><a href="https://blog.shahjalalshohag.com/topic-list/">The Ultimate Topic List by Shahjalal Shohag</a></li>
</ul>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<ul>
<li><a href="https://github.com/EbTech/rust-algorithms">Contest Algorithms in Rust by EbTech</a></li>
<li><a href="https://snippets.kiwiyou.dev/">kiwiyou's Snippets Collection</a></li>
</ul>
<h3 id="c"><a class="header" href="#c">C++</a></h3>
<ul>
<li><a href="https://github.com/Aeren1564/Algorithms">aeren1564 Bible</a></li>
<li>AtCoder Library: <a href="https://atcoder.github.io/ac-library/production/document_en/">Doc</a>, <a href="https://github.com/atcoder/ac-library">GitHub</a></li>
<li><a href="https://github.com/koosaga/olympiad/tree/master/Library">koosaga's Library</a></li>
<li><a href="https://github.com/justiceHui/icpc-teamnote">justiceHui's Teamnote</a></li>
</ul>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<ul>
<li><a href="https://github.com/cheran-senthil/PyRival">PyRival</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcd-lcm"><a class="header" href="#gcd-lcm">GCD, LCM</a></h1>
<p><code>gcd(x, y)</code> returns the greatest common divisor (GCD) of <code>x</code> and <code>y</code>. <br />
<code>lcm(x, y)</code> returns the least common multiple (LCM) of <code>x</code> and <code>y</code>.</p>
<p><code>gcd</code> is implemented using Euclidean algorithm, whose time complexity is \(O( \log _{\phi} x )\) where \(\phi\) is a golden ratio.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let (x, y) = (10, 25);

let g = gcd(x, y);
println!(&quot;{}&quot;, g); // 5

let l = lcm(x, y);
println!(&quot;{}&quot;, l); // 50
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gcd(x: u64, y: u64) -&gt; u64 {
</span><span class="boring">   if y == 0 {
</span><span class="boring">       x
</span><span class="boring">   } else {
</span><span class="boring">       gcd(y, x % y)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn lcm(x: u64, y: u64) -&gt; u64 {
</span><span class="boring">   x / gcd(x, y) * y
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-rust noplayground">fn gcd(x: u64, y: u64) -&gt; u64 {
    if y == 0 {
        x
    } else {
        gcd(y, x % y)
    }
}

fn lcm(x: u64, y: u64) -&gt; u64 {
    x / gcd(x, y) * y
}
</code></pre>
<h2 id="generic-version"><a class="header" href="#generic-version">Generic Version</a></h2>
<p>The function below works for any primitive unsigned integer types.</p>
<pre><code class="language-rust noplayground">pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy + PartialEq + PartialOrd + std::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
{
    if y == 0.into() {
        x
    } else {
        let v = x % y;
        gcd(y, v)
    }
}

pub fn lcm&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy
        + PartialEq
        + PartialOrd
        + std::ops::Rem&lt;Output = T&gt;
        + std::ops::Div&lt;Output = T&gt;
        + std::ops::Mul&lt;Output = T&gt;
        + From&lt;u8&gt;,
{
    x / gcd(x, y) * y
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extended-euclidean-algorithm"><a class="header" href="#extended-euclidean-algorithm">Extended Euclidean Algorithm</a></h1>
<p><code>ext_gcd(a, b)</code> returns \(g, s, t\) such that \(g = \gcd(a, b)\) and \(as+bt=g\).</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let (a, b) = (4, 11);
let (g, s, t) = ext_gcd(a, b);
println!(&quot;{} {} {}&quot;, g, s, t); // 1 3 -1
println!(&quot;{} == {}&quot;, g, a * s + b * t);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Extended Euclidean Algorithm
</span><span class="boring">// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/gcd.py
</span><span class="boring">
</span><span class="boring">fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
</span><span class="boring">    let (mut s, mut old_s) = (0, 1);
</span><span class="boring">    let (mut g, mut old_g) = (b, a);
</span><span class="boring">    while g != 0 {
</span><span class="boring">        let q = old_g / g;
</span><span class="boring">        let (new_r, new_s) = (old_g - q * g, old_s - q * s);
</span><span class="boring">        old_g = g; // Not using destructuring to support low version
</span><span class="boring">        g = new_r; // AtCoder is using 1.42.0
</span><span class="boring">        old_s = s;
</span><span class="boring">        s = new_s;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    (
</span><span class="boring">        old_g,
</span><span class="boring">        old_s,
</span><span class="boring">        if b != 0 { (old_g - old_s * a) / b } else { 0 },
</span><span class="boring">    )
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<pre><code class="language-rust noplayground">// Extended Euclidean Algorithm
// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/gcd.py

fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut g, mut old_g) = (b, a);
    while g != 0 {
        let q = old_g / g;
        let (new_r, new_s) = (old_g - q * g, old_s - q * s);
        old_g = g; // Not using destructuring to support low version
        g = new_r; // AtCoder is using 1.42.0
        old_s = s;
        s = new_s;
    }

    (
        old_g,
        old_s,
        if b != 0 { (old_g - old_s * a) / b } else { 0 },
    )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chinese-remainder-theorem"><a class="header" href="#chinese-remainder-theorem">Chinese Remainder Theorem</a></h1>
<p><code>crt(r, m)</code> returns <code>Some(x)</code> such that \(x \equiv r_i \pmod {m_i}\) for all \(i\). If such \(x\) does not exist, then it returns <code>None</code>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let r: Vec&lt;i64&gt; = vec![1, 2, 3];
let m: Vec&lt;i64&gt; = vec![3, 5, 7];
let x = crt(&amp;r, &amp;m);
println!(&quot;{:?}&quot;, x); // Some(52)

let r: Vec&lt;i64&gt; = vec![2, 5];
let m: Vec&lt;i64&gt; = vec![10, 25];
let x = crt(&amp;r, &amp;m);
println!(&quot;{:?}&quot;, x); // None
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Chinese remainder theorem
</span><span class="boring">// Reference: PyRival &lt;https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py&gt;
</span><span class="boring">
</span><span class="boring">fn gcd(x: i64, y: i64) -&gt; i64 {
</span><span class="boring">    if y == 0 {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        gcd(y, x % y)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns gcd(a, b), s, r s.t. a*s + b*r = gcd(a, b)
</span><span class="boring">#[inline(always)]
</span><span class="boring">fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
</span><span class="boring">    let (mut s, mut old_s) = (0, 1);
</span><span class="boring">    let (mut r, mut old_r) = (b, a);
</span><span class="boring">    while r != 0 {
</span><span class="boring">        let q = old_r / r;
</span><span class="boring">        let (new_r, new_s) = (old_r - q * r, old_s - q * s);
</span><span class="boring">        old_r = r; // Not using destructuring to support low version
</span><span class="boring">        r = new_r; // AtCoder is using 1.42.0
</span><span class="boring">        old_s = s;
</span><span class="boring">        s = new_s;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    (
</span><span class="boring">        old_r,
</span><span class="boring">        old_s,
</span><span class="boring">        if b != 0 { (old_r - old_s * a) / b } else { 0 },
</span><span class="boring">    )
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns $x$ s.t. $x=r_i (mod m_i)$ for all $i$
</span><span class="boring">fn crt(r: &amp;[i64], m: &amp;[i64]) -&gt; Option&lt;i64&gt; {
</span><span class="boring">    let (mut x, mut m_prod) = (0, 1);
</span><span class="boring">    for (bi, mi) in r.iter().zip(m.iter()) {
</span><span class="boring">        let (g, s, _) = ext_gcd(m_prod, *mi);
</span><span class="boring">        if ((bi - x) % mi).rem_euclid(g) != 0 {
</span><span class="boring">            return None;
</span><span class="boring">        }
</span><span class="boring">        x += m_prod * ((s * ((bi - x).rem_euclid(*mi))).div_euclid(g));
</span><span class="boring">        m_prod = (m_prod * mi).div_euclid(gcd(m_prod, *mi));
</span><span class="boring">    }
</span><span class="boring">    Some(x.rem_euclid(m_prod))
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code-2"><a class="header" href="#code-2">Code</a></h2>
<pre><code class="language-rust noplayground">// Chinese remainder theorem
// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py

fn gcd(x: i64, y: i64) -&gt; i64 {
    if y == 0 {
        x
    } else {
        gcd(y, x % y)
    }
}

/// Returns gcd(a, b), s, t s.t. a*s + b*t = gcd(a, b)
#[inline(always)]
fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut r, mut old_r) = (b, a);
    while r != 0 {
        let q = old_r / r;
        let (new_r, new_s) = (old_r - q * r, old_s - q * s);
        old_r = r; // Not using destructuring to support low version
        r = new_r; // AtCoder is using 1.42.0
        old_s = s;
        s = new_s;
    }

    (
        old_r,
        old_s,
        if b != 0 { (old_r - old_s * a) / b } else { 0 },
    )
}

/// Returns x s.t. x=r_i (mod m_i) for all i
fn crt(r: &amp;[i64], m: &amp;[i64]) -&gt; Option&lt;i64&gt; {
    let (mut x, mut m_prod) = (0, 1);
    for (bi, mi) in r.iter().zip(m.iter()) {
        let (g, s, _) = ext_gcd(m_prod, *mi);
        if ((bi - x) % mi).rem_euclid(g) != 0 {
            return None;
        }
        x += m_prod * ((s * ((bi - x).rem_euclid(*mi))).div_euclid(g));
        m_prod = (m_prod * mi).div_euclid(gcd(m_prod, *mi));
    }
    Some(x.rem_euclid(m_prod))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deterministic-miller-rabin-primality-test"><a class="header" href="#deterministic-miller-rabin-primality-test">Deterministic Miller-Rabin Primality Test</a></h1>
<p>Deterministic Miller-Rabin primality test determines whether a certain unsigned integer is a prime in a time complexity of \(O(\log{n})\). This test only works for integers under \(2^{64}\).</p>
<p><code>x.is_prime()</code> chooses a roughly faster algorithm among naive primality test and Miller-Rabin test, and returns <code>true</code> if <code>x</code> is a prime, <code>false</code> if not.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, 3284729387909u64.is_prime()); // true
println!(&quot;{}&quot;, 3284729387911u64.is_prime()); // false 53×61976026187
<span class="boring">}
</span><span class="boring">
</span><span class="boring">trait MillerRabin: From&lt;u8&gt; + PartialOrd {
</span><span class="boring">    const MR_THRES: Self;
</span><span class="boring">    fn naive_primality(self) -&gt; bool;
</span><span class="boring">    fn miller_rabin_test(self, a: Self) -&gt; bool;
</span><span class="boring">    fn miller_primality(self) -&gt; bool;
</span><span class="boring">    fn is_prime(self) -&gt; bool {
</span><span class="boring">        if self &lt;= 1.into() {
</span><span class="boring">            false
</span><span class="boring">        } else if self &lt;= Self::MR_THRES {
</span><span class="boring">            self.naive_primality()
</span><span class="boring">        } else {
</span><span class="boring">            self.miller_primality()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! impl_millerrabin {
</span><span class="boring">    ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
</span><span class="boring">        impl MillerRabin for $t {
</span><span class="boring">            const MR_THRES: Self = $thres;
</span><span class="boring">
</span><span class="boring">            #[inline(always)]
</span><span class="boring">            fn naive_primality(self) -&gt; bool {
</span><span class="boring">                for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
</span><span class="boring">                    if self % i == 0 {
</span><span class="boring">                        return false;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                true
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">               #[inline(always)]
</span><span class="boring">               fn miller_rabin_test(self, a: Self) -&gt; bool {
</span><span class="boring">                   let d = self - 1;
</span><span class="boring">                   let mut p = d &gt;&gt; (d.trailing_zeros());
</span><span class="boring">
</span><span class="boring">                   let mut t = {
</span><span class="boring">                       let mut base = a as $u;
</span><span class="boring">                       let mut exp = p as $u;
</span><span class="boring">                       let rem = self as $u;
</span><span class="boring">                       let mut ret: $u = 1;
</span><span class="boring">                       while exp != 0 {
</span><span class="boring">                           if exp &amp; 1 != 0 {
</span><span class="boring">                               ret = ret * base % rem;
</span><span class="boring">                           }
</span><span class="boring">                           base = base*base%rem;
</span><span class="boring">                           exp &gt;&gt;= 1;
</span><span class="boring">                       }
</span><span class="boring">                       ret as $t
</span><span class="boring">                   };
</span><span class="boring">
</span><span class="boring">                   let at_last = t == d || t == 1;
</span><span class="boring">
</span><span class="boring">                   while p != d {
</span><span class="boring">                       p &lt;&lt;= 1;
</span><span class="boring">                       t = ((t as $u * t as $u) % self as $u) as $t;
</span><span class="boring">                       if t == self - 1 {
</span><span class="boring">                           return true;
</span><span class="boring">                       }
</span><span class="boring">                   }
</span><span class="boring">                   at_last
</span><span class="boring">               }
</span><span class="boring">
</span><span class="boring">            fn miller_primality(self) -&gt; bool {
</span><span class="boring">                $(
</span><span class="boring">                    if !self.miller_rabin_test($x) {
</span><span class="boring">                        return false;
</span><span class="boring">                    }
</span><span class="boring">                )*
</span><span class="boring">                true
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl_millerrabin!(u8, u16, 254, 2);
</span><span class="boring">impl_millerrabin!(u16, u32, 2000, 2, 3);
</span><span class="boring">impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
</span><span class="boring">impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
</span></code></pre></pre>
<h2 id="code-3"><a class="header" href="#code-3">Code</a></h2>
<pre><code class="language-rust noplayground">trait MillerRabin: From&lt;u8&gt; + PartialOrd {
    const MR_THRES: Self;
    fn naive_primality(self) -&gt; bool;
    fn miller_rabin_test(self, a: Self) -&gt; bool;
    fn miller_primality(self) -&gt; bool;
    fn is_prime(self) -&gt; bool {
        if self &lt;= 1.into() {
            false
        } else if self &lt;= Self::MR_THRES {
            self.naive_primality()
        } else {
            self.miller_primality()
        }
    }
}

macro_rules! impl_millerrabin {
        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
            impl MillerRabin for $t {
                const MR_THRES: Self = $thres;

                #[inline(always)]
                fn naive_primality(self) -&gt; bool {
                    for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
                        if self % i == 0 {
                            return false;
                        }
                    }
                    true
                }

                #[inline(always)]
                fn miller_rabin_test(self, a: Self) -&gt; bool {
                    let d = self - 1;
                    let mut p = d &gt;&gt; (d.trailing_zeros());

                    let mut t = {
                        let mut base = a as $u;
                        let mut exp = p as $u;
                        let rem = self as $u;
                        let mut ret: $u = 1;
                        while exp != 0 {
                            if exp &amp; 1 != 0 {
                                ret = ret * base % rem;
                            }
                            base = base*base%rem;
                            exp &gt;&gt;= 1;
                        }
                        ret as $t
                    };

                    let at_last = t == d || t == 1;

                    while p != d {
                        p &lt;&lt;= 1;
                        t = ((t as $u * t as $u) % self as $u) as $t;
                        if t == self - 1 {
                            return true;
                        }
                    }
                    at_last
                }

                fn miller_primality(self) -&gt; bool {
                    $(
                        if !self.miller_rabin_test($x) {
                            return false;
                        }
                    )*
                    true
                }
            }
        };
    }

impl_millerrabin!(u8, u16, 254, 2);
impl_millerrabin!(u16, u32, 2000, 2, 3);
impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pollards-rho-algorithm"><a class="header" href="#pollards-rho-algorithm">Pollard's Rho Algorithm</a></h1>
<p>Pollard rho algorithm is a randomized algorithm which factorizes a number in an average time complexity of \(O(n^{1/4})\).</p>
<p><code>x.factorize()</code> factorizes <code>x</code> and returns a vector with the factors. The order of factors in the vector is undefined.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut rng = rng::RNG::new(15163487);
let a: u32 = 1237172;
let mut factors = a.factorize(&amp;mut rng);
factors.sort_unstable();
println!(&quot;{:?}&quot;, factors); // [2, 2, 309293]
println!(&quot;{}&quot;, factors.iter().product::&lt;u32&gt;()); // 1237172
<span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PollardRho: MillerRabin + std::ops::ShrAssign + std::ops::BitAnd&lt;Output = Self&gt; + Clone {
</span><span class="boring">    fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG);
</span><span class="boring">    fn factorize(mut self, rng: &amp;mut rng::RNG) -&gt; Vec&lt;Self&gt; {
</span><span class="boring">        let mut arr: Vec&lt;Self&gt; = Vec::new();
</span><span class="boring">        if self &lt;= 1.into() {
</span><span class="boring">            return arr;
</span><span class="boring">        }
</span><span class="boring">        while self.clone() &amp; 1.into() == 0.into() {
</span><span class="boring">            self &gt;&gt;= 1.into();
</span><span class="boring">            arr.push(2.into());
</span><span class="boring">        }
</span><span class="boring">        self.rho(&amp;mut arr, rng);
</span><span class="boring">        arr
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! impl_pollardrho {
</span><span class="boring">    ($t:ty, $u:ty, $reset:expr) =&gt; {
</span><span class="boring">        impl PollardRho for $t {
</span><span class="boring">            fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG) {
</span><span class="boring">                if self &lt;= 1 {
</span><span class="boring">                    return;
</span><span class="boring">                } else if self.is_prime() {
</span><span class="boring">                    arr.push(self);
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                let mut i: u64 = 0;
</span><span class="boring">                let mut x: $t = (rng.next_u64() % self as u64) as $t;
</span><span class="boring">                let mut y: $t = x;
</span><span class="boring">                let mut k: u64 = 2;
</span><span class="boring">                let mut d: $t;
</span><span class="boring">                let mut reset_limit: u64 = $reset;
</span><span class="boring">
</span><span class="boring">                loop {
</span><span class="boring">                    i += 1;
</span><span class="boring">                    x = (((x as $u * x as $u % self as $u) + (self - 1) as $u) % self as $u) as $t;
</span><span class="boring">                    d = gcd(y.abs_diff(x), self);
</span><span class="boring">                    if d == self || i &gt;= reset_limit {
</span><span class="boring">                        // Reset
</span><span class="boring">                        reset_limit = reset_limit * 3 / 2;
</span><span class="boring">                        i = 0;
</span><span class="boring">                        x = (rng.next_u64() % self as u64) as $t;
</span><span class="boring">                        y = x;
</span><span class="boring">                    }
</span><span class="boring">                    if d != 1 {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                    if i == k {
</span><span class="boring">                        y = x;
</span><span class="boring">                        k &lt;&lt;= 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                if d != self {
</span><span class="boring">                    d.rho(arr, rng);
</span><span class="boring">                    (self / d).rho(arr, rng);
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                let mut i = 3;
</span><span class="boring">                while i * i &lt;= self {
</span><span class="boring">                    if self % i == 0 {
</span><span class="boring">                        i.rho(arr, rng);
</span><span class="boring">                        (d / i).rho(arr, rng);
</span><span class="boring">                        return;
</span><span class="boring">                    }
</span><span class="boring">                    i += 2;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl_pollardrho!(u8, u16, 100000);
</span><span class="boring">impl_pollardrho!(u16, u32, 100000);
</span><span class="boring">impl_pollardrho!(u32, u64, 100000);
</span><span class="boring">impl_pollardrho!(u64, u128, 100000);
</span><span class="boring">
</span><span class="boring">trait MillerRabin: From&lt;u8&gt; + PartialOrd {
</span><span class="boring">    const MR_THRES: Self;
</span><span class="boring">    fn naive_primality(self) -&gt; bool;
</span><span class="boring">    fn miller_rabin_test(self, a: Self) -&gt; bool;
</span><span class="boring">    fn miller_primality(self) -&gt; bool;
</span><span class="boring">    fn is_prime(self) -&gt; bool {
</span><span class="boring">        if self &lt;= 1.into() {
</span><span class="boring">            false
</span><span class="boring">        } else if self &lt;= Self::MR_THRES {
</span><span class="boring">            self.naive_primality()
</span><span class="boring">        } else {
</span><span class="boring">            self.miller_primality()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! impl_millerrabin {
</span><span class="boring">        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
</span><span class="boring">            impl MillerRabin for $t {
</span><span class="boring">                const MR_THRES: Self = $thres;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn naive_primality(self) -&gt; bool {
</span><span class="boring">                    for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
</span><span class="boring">                        if self % i == 0 {
</span><span class="boring">                            return false;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    true
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn miller_rabin_test(self, a: Self) -&gt; bool {
</span><span class="boring">                    let d = self - 1;
</span><span class="boring">                    let mut p = d &gt;&gt; (d.trailing_zeros());
</span><span class="boring">
</span><span class="boring">                    let mut t = {
</span><span class="boring">                        let mut base = a as $u;
</span><span class="boring">                        let mut exp = p as $u;
</span><span class="boring">                        let rem = self as $u;
</span><span class="boring">                        let mut ret: $u = 1;
</span><span class="boring">                        while exp != 0 {
</span><span class="boring">                            if exp &amp; 1 != 0 {
</span><span class="boring">                                ret = ret * base % rem;
</span><span class="boring">                            }
</span><span class="boring">                            base = base*base%rem;
</span><span class="boring">                            exp &gt;&gt;= 1;
</span><span class="boring">                        }
</span><span class="boring">                        ret as $t
</span><span class="boring">                    };
</span><span class="boring">
</span><span class="boring">                    let at_last = t == d || t == 1;
</span><span class="boring">
</span><span class="boring">                    while p != d {
</span><span class="boring">                        p &lt;&lt;= 1;
</span><span class="boring">                        t = ((t as $u * t as $u) % self as $u) as $t;
</span><span class="boring">                        if t == self - 1 {
</span><span class="boring">                            return true;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    at_last
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                fn miller_primality(self) -&gt; bool {
</span><span class="boring">                    $(
</span><span class="boring">                        if !self.miller_rabin_test($x) {
</span><span class="boring">                            return false;
</span><span class="boring">                        }
</span><span class="boring">                    )*
</span><span class="boring">                    true
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl_millerrabin!(u8, u16, 254, 2);
</span><span class="boring">impl_millerrabin!(u16, u32, 2000, 2, 3);
</span><span class="boring">impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
</span><span class="boring">impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
</span><span class="boring">
</span><span class="boring">pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
</span><span class="boring">where
</span><span class="boring">    T: Copy + PartialEq + PartialOrd + std::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
</span><span class="boring">{
</span><span class="boring">    if y == 0.into() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        let v = x % y;
</span><span class="boring">        gcd(y, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod rng {
</span><span class="boring">    pub struct RNG {
</span><span class="boring">        val: u64,
</span><span class="boring">    }
</span><span class="boring">    impl RNG {
</span><span class="boring">        pub fn new(seed: u64) -&gt; Self {
</span><span class="boring">            Self { val: seed }
</span><span class="boring">        }
</span><span class="boring">        pub fn next_u64(&amp;mut self) -&gt; u64 {
</span><span class="boring">            let mut x = self.val;
</span><span class="boring">            x ^= x &lt;&lt; 13;
</span><span class="boring">            x ^= x &gt;&gt; 7;
</span><span class="boring">            x ^= x &lt;&lt; 17;
</span><span class="boring">            self.val = x;
</span><span class="boring">            x
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code-4"><a class="header" href="#code-4">Code</a></h2>
<pre><code class="language-rust noplayground">trait PollardRho: MillerRabin + std::ops::ShrAssign + std::ops::BitAnd&lt;Output = Self&gt; + Clone {
    fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG);
    fn factorize(mut self, rng: &amp;mut rng::RNG) -&gt; Vec&lt;Self&gt; {
        let mut arr: Vec&lt;Self&gt; = Vec::new();
        if self &lt;= 1.into() {
            return arr;
        }
        while self.clone() &amp; 1.into() == 0.into() {
            self &gt;&gt;= 1.into();
            arr.push(2.into());
        }
        self.rho(&amp;mut arr, rng);
        arr
    }
}

macro_rules! impl_pollardrho {
    ($t:ty, $u:ty, $reset:expr) =&gt; {
        impl PollardRho for $t {
            fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG) {
                if self &lt;= 1 {
                    return;
                } else if self.is_prime() {
                    arr.push(self);
                    return;
                }

                let mut i: u64 = 0;
                let mut x: $t = (rng.next_u64() % self as u64) as $t;
                let mut y: $t = x;
                let mut k: u64 = 2;
                let mut d: $t;
                let mut reset_limit: u64 = $reset;

                loop {
                    i += 1;
                    x = (((x as $u * x as $u % self as $u) + (self - 1) as $u) % self as $u) as $t;
                    d = gcd(y.abs_diff(x), self);
                    if d == self || i &gt;= reset_limit {
                        // Reset
                        reset_limit = reset_limit * 3 / 2;
                        i = 0;
                        x = (rng.next_u64() % self as u64) as $t;
                        y = x;
                    }
                    if d != 1 {
                        break;
                    }
                    if i == k {
                        y = x;
                        k &lt;&lt;= 1;
                    }
                }

                if d != self {
                    d.rho(arr, rng);
                    (self / d).rho(arr, rng);
                    return;
                }

                let mut i = 3;
                while i * i &lt;= self {
                    if self % i == 0 {
                        i.rho(arr, rng);
                        (d / i).rho(arr, rng);
                        return;
                    }
                    i += 2;
                }
            }
        }
    };
}

impl_pollardrho!(u8, u16, 100000);
impl_pollardrho!(u16, u32, 100000);
impl_pollardrho!(u32, u64, 100000);
impl_pollardrho!(u64, u128, 100000);

trait MillerRabin: From&lt;u8&gt; + PartialOrd {
    const MR_THRES: Self;
    fn naive_primality(self) -&gt; bool;
    fn miller_rabin_test(self, a: Self) -&gt; bool;
    fn miller_primality(self) -&gt; bool;
    fn is_prime(self) -&gt; bool {
        if self &lt;= 1.into() {
            false
        } else if self &lt;= Self::MR_THRES {
            self.naive_primality()
        } else {
            self.miller_primality()
        }
    }
}

macro_rules! impl_millerrabin {
        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
            impl MillerRabin for $t {
                const MR_THRES: Self = $thres;

                #[inline(always)]
                fn naive_primality(self) -&gt; bool {
                    for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
                        if self % i == 0 {
                            return false;
                        }
                    }
                    true
                }

                #[inline(always)]
                fn miller_rabin_test(self, a: Self) -&gt; bool {
                    let d = self - 1;
                    let mut p = d &gt;&gt; (d.trailing_zeros());

                    let mut t = {
                        let mut base = a as $u;
                        let mut exp = p as $u;
                        let rem = self as $u;
                        let mut ret: $u = 1;
                        while exp != 0 {
                            if exp &amp; 1 != 0 {
                                ret = ret * base % rem;
                            }
                            base = base*base%rem;
                            exp &gt;&gt;= 1;
                        }
                        ret as $t
                    };

                    let at_last = t == d || t == 1;

                    while p != d {
                        p &lt;&lt;= 1;
                        t = ((t as $u * t as $u) % self as $u) as $t;
                        if t == self - 1 {
                            return true;
                        }
                    }
                    at_last
                }

                fn miller_primality(self) -&gt; bool {
                    $(
                        if !self.miller_rabin_test($x) {
                            return false;
                        }
                    )*
                    true
                }
            }
        };
    }

impl_millerrabin!(u8, u16, 254, 2);
impl_millerrabin!(u16, u32, 2000, 2, 3);
impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);

pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy + PartialEq + PartialOrd + std::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
{
    if y == 0.into() {
        x
    } else {
        let v = x % y;
        gcd(y, v)
    }
}

mod rng {
    pub struct RNG {
        val: u64,
    }
    impl RNG {
        pub fn new(seed: u64) -&gt; Self {
            Self { val: seed }
        }
        pub fn next_u64(&amp;mut self) -&gt; u64 {
            let mut x = self.val;
            x ^= x &lt;&lt; 13;
            x ^= x &gt;&gt; 7;
            x ^= x &lt;&lt; 17;
            self.val = x;
            x
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-square-root"><a class="header" href="#integer-square-root">Integer Square Root</a></h1>
<p><code>isqrt(s)</code> returns \( \left\lfloor \sqrt{s} \right\rfloor \). It runs much faster than the typical binary search method.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let x: u64 = 10002;
let sq = isqrt(x);
println!(&quot;{}&quot;, sq); // 100
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn isqrt(s: u64) -&gt; u64 {
</span><span class="boring">    let mut x0 = s &gt;&gt; 1;
</span><span class="boring">    if x0 != 0 {
</span><span class="boring">        let mut x1 = (x0 + s / x0) &gt;&gt; 1;
</span><span class="boring">        while x1 &lt; x0 {
</span><span class="boring">            x0 = x1;
</span><span class="boring">            x1 = (x0 + s / x0) &gt;&gt; 1
</span><span class="boring">        }
</span><span class="boring">        x0
</span><span class="boring">    } else {
</span><span class="boring">        s
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code-5"><a class="header" href="#code-5">Code</a></h2>
<pre><code class="language-rust noplayground">fn isqrt(s: u64) -&gt; u64 {
    let mut x0 = s &gt;&gt; 1;
    if x0 != 0 {
        let mut x1 = (x0 + s / x0) &gt;&gt; 1;
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) &gt;&gt; 1
        }
        x0
    } else {
        s
    }
}
</code></pre>
<h2 id="generic-version-1"><a class="header" href="#generic-version-1">Generic Version</a></h2>
<p>The function below works for any primitive unsigned integer types.</p>
<pre><code class="language-rust noplayground">fn isqrt&lt;T&gt;(s: T) -&gt; T
where
    T: Copy
        + std::ops::Shr&lt;Output = T&gt;
        + std::ops::Add&lt;Output = T&gt;
        + std::ops::Div&lt;Output = T&gt;
        + PartialOrd
        + From&lt;u8&gt;,
{
    let mut x0 = s &gt;&gt; 1.into();
    if x0 != 0.into() {
        let mut x1 = (x0 + s / x0) &gt;&gt; 1.into();
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) &gt;&gt; 1.into();
        }
        x0
    } else {
        s
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-recurrence"><a class="header" href="#linear-recurrence">Linear Recurrence</a></h1>
<p>Algorithms related to linear recurrences</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="berlekamp-massey"><a class="header" href="#berlekamp-massey">Berlekamp-Massey</a></h1>
<p><code>berlekamp_massey(A, m)</code> returns a vector <code>C</code> of length \(n\) which satisfies
\[ \begin{aligned}
A_x &amp;= \sum_{i=0}^{i=k-1} {C_i A_{x-k+i}} \\
&amp;= C_0 A_{x-k} + C_1 A_{x-k+1} + \cdots + C_{k-1} A_{x-1}
\end{aligned} \]
with minimum \(n\) under <strong>prime</strong> modulo \(m\). It is safe to have the length of <code>vals</code> as at least \(3n\).</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>// vals[x] = vals[x-3] + 2*vals[x-2] + 3*vals[x-1]
let m: u64 = 1000000007;
let mut vals: Vec&lt;u64&gt; = vec![1, 2, 3];
for x in 3..20 {
    vals.push((vals[x - 3] + 2 * vals[x - 2] + 3 * vals[x - 1]) % m);
}

let rec = berlekamp_massey(&amp;vals, m);
println!(&quot;{:?}&quot;, rec); // [1, 2, 3]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Berlekamp-Massey
</span><span class="boring">// References
</span><span class="boring">// https://blog.naver.com/jinhan814/222140081932
</span><span class="boring">// https://koosaga.com/231
</span><span class="boring">
</span><span class="boring">fn rem_pow(mut base: i64, mut exp: i64, m: i64) -&gt; i64 {
</span><span class="boring">    let mut result = 1;
</span><span class="boring">    while exp != 0 {
</span><span class="boring">        if exp &amp; 1 != 0 {
</span><span class="boring">            result = (result * base) % m;
</span><span class="boring">        }
</span><span class="boring">        exp &gt;&gt;= 1;
</span><span class="boring">        base = (base * base) % m;
</span><span class="boring">    }
</span><span class="boring">    result
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Finds rec[n] which satisfies
</span><span class="boring">/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rec[d-1]vals[d-1]
</span><span class="boring">/// with minimum n.
</span><span class="boring">fn berlekamp_massey(vals: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">    let m = m as i64;
</span><span class="boring">    let mut cur: Vec&lt;i64&gt; = Vec::new();
</span><span class="boring">    let (mut lf, mut ld) = (0, 0);
</span><span class="boring">    let mut ls: Vec&lt;i64&gt; = Vec::new();
</span><span class="boring">    for i in 0..vals.len() {
</span><span class="boring">        let mut t = 0;
</span><span class="boring">        for (j, v) in cur.iter().enumerate() {
</span><span class="boring">            t = (t + vals[i - j - 1] as i64 * v) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if (t - vals[i] as i64) % m == 0 {
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if cur.len() == 0 {
</span><span class="boring">            cur = vec![0; i + 1];
</span><span class="boring">            lf = i;
</span><span class="boring">            ld = (t - vals[i] as i64) % m;
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;
</span><span class="boring">        let mut c: Vec&lt;i64&gt; = vec![0; i - lf + ls.len()];
</span><span class="boring">        c[i - lf - 1] = k as i64;
</span><span class="boring">        for (p, j) in ls.iter().enumerate() {
</span><span class="boring">            c[i - lf + p] = -j * k % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if c.len() &lt; cur.len() {
</span><span class="boring">            c.extend((0..(cur.len() - c.len())).map(|_| 0));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        for j in 0..cur.len() {
</span><span class="boring">            c[j] = (c[j] + cur[j]) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if i - lf + ls.len() &gt;= cur.len() {
</span><span class="boring">            ls = cur;
</span><span class="boring">            lf = i;
</span><span class="boring">            ld = (t - vals[i] as i64) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        cur = c;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    for i in 0..cur.len() {
</span><span class="boring">        cur[i] = (cur[i] % m + m) % m;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    cur.into_iter().rev().map(|x| x as u64).collect()
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code-6"><a class="header" href="#code-6">Code</a></h2>
<pre><code class="language-rust noplayground">// Berlekamp-Massey
// References
// https://blog.naver.com/jinhan814/222140081932
// https://koosaga.com/231

fn rem_pow(mut base: i64, mut exp: i64, m: i64) -&gt; i64 {
    let mut result = 1;
    while exp != 0 {
        if exp &amp; 1 != 0 {
            result = (result * base) % m;
        }
        exp &gt;&gt;= 1;
        base = (base * base) % m;
    }
    result
}

/// Finds rec[n] which satisfies
/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rec[d-1]vals[d-1]
/// with minimum n.
fn berlekamp_massey(vals: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let m = m as i64;
    let mut cur: Vec&lt;i64&gt; = Vec::new();
    let (mut lf, mut ld) = (0, 0);
    let mut ls: Vec&lt;i64&gt; = Vec::new();
    for i in 0..vals.len() {
        let mut t = 0;
        for (j, v) in cur.iter().enumerate() {
            t = (t + vals[i - j - 1] as i64 * v) % m;
        }

        if (t - vals[i] as i64) % m == 0 {
            continue;
        }

        if cur.len() == 0 {
            cur = vec![0; i + 1];
            lf = i;
            ld = (t - vals[i] as i64) % m;
            continue;
        }

        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;
        let mut c: Vec&lt;i64&gt; = vec![0; i - lf + ls.len()];
        c[i - lf - 1] = k as i64;
        for (p, j) in ls.iter().enumerate() {
            c[i - lf + p] = -j * k % m;
        }

        if c.len() &lt; cur.len() {
            c.extend((0..(cur.len() - c.len())).map(|_| 0));
        }

        for j in 0..cur.len() {
            c[j] = (c[j] + cur[j]) % m;
        }

        if i - lf + ls.len() &gt;= cur.len() {
            ls = cur;
            lf = i;
            ld = (t - vals[i] as i64) % m;
        }

        cur = c;
    }

    for i in 0..cur.len() {
        cur[i] = (cur[i] % m + m) % m;
    }

    cur.into_iter().rev().map(|x| x as u64).collect()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kitamasa"><a class="header" href="#kitamasa">Kitamasa</a></h1>
<p><code>kitamasa(C, A, n, m)</code> returns \(A_n\) where
\[ \begin{aligned}
A_x &amp;= \sum_{i=0}^{i=k-1} {C_i A_{x-k+i}} \\
&amp;= C_0 A_{x-k} + C_1 A_{x-k+1} + \cdots + C_{k-1} A_{x-1}
\end{aligned} \]
in a time complexity of \( O(T(k) \log{n}) \), where \(O(T(k))\) is a time complexity taken for multiplying two polynomials of order \(k\), and \(k\) is a length of \(C\).</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>// vals[x] = vals[x-3] + 2*vals[x-2] + 3*vals[x-1]
// 1, 2, 3, 14, 50, 181, 657, 2383, 8644, 31355, 113736, 412562, 1496513, 5428399, 19690785, 71425666, ...
let m: u64 = 1000000007;
let vals: Vec&lt;u64&gt; = vec![1, 2, 3];
let rec: Vec&lt;u64&gt; = vec![1, 2, 3];

let v = kitamasa(&amp;rec, &amp;vals, 15, m);
println!(&quot;{}&quot;, v); // 71425666
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Kitamasas
</span><span class="boring">// Reference: https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/
</span><span class="boring">
</span><span class="boring">fn poly_mul(v: &amp;[u64], w: &amp;[u64], rec: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">    let mut t = vec![0; 2 * v.len()];
</span><span class="boring">
</span><span class="boring">    for j in 0..v.len() {
</span><span class="boring">        for k in 0..w.len() {
</span><span class="boring">            t[j + k] += v[j] * w[k] % m;
</span><span class="boring">            if t[j + k] &gt;= m {
</span><span class="boring">                t[j + k] -= m;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    for j in (v.len()..2 * v.len()).rev() {
</span><span class="boring">        for k in 1..=v.len() {
</span><span class="boring">            t[j - k] += t[j] * rec[k - 1] % m;
</span><span class="boring">            if t[j - k] &gt;= m {
</span><span class="boring">                t[j - k] -= m;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    t[..v.len()].iter().map(|x| *x).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Finds arr[n] where
</span><span class="boring">/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
</span><span class="boring">/// under modulo m where d=rec.len()=arr.len()
</span><span class="boring">fn kitamasa(rec: &amp;[u64], vals: &amp;[u64], mut n: u64, m: u64) -&gt; u64 {
</span><span class="boring">    let recurr: Vec&lt;_&gt; = rec.iter().rev().copied().collect();
</span><span class="boring">    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);
</span><span class="boring">    s[0] = 1;
</span><span class="boring">    if recurr.len() != 1 {
</span><span class="boring">        t[1] = 1;
</span><span class="boring">    } else {
</span><span class="boring">        t[0] = recurr[0];
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    while n != 0 {
</span><span class="boring">        if n &amp; 1 != 0 {
</span><span class="boring">            s = poly_mul(&amp;s, &amp;t, &amp;recurr, m);
</span><span class="boring">        }
</span><span class="boring">        t = poly_mul(&amp;t, &amp;t, &amp;recurr, m);
</span><span class="boring">        n &gt;&gt;= 1;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mut ret = 0u64;
</span><span class="boring">    for i in 0..recurr.len() {
</span><span class="boring">        ret += s[i] * vals[i] % m;
</span><span class="boring">        if ret &gt;= m {
</span><span class="boring">            ret -= m;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    ret
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="ok2-logn-implementation"><a class="header" href="#ok2-logn-implementation">\(O(k^2 \log{n})\) Implementation</a></h2>
<p>The implementation below uses naive polynomial multiplication.</p>
<pre><code class="language-rust noplayground">// Kitamasa
// Reference: JusticeHui's Blog: &lt;https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/&gt;

fn poly_mul(v: &amp;[u64], w: &amp;[u64], rec: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut t = vec![0; 2 * v.len()];

    for j in 0..v.len() {
        for k in 0..w.len() {
            t[j + k] += v[j] * w[k] % m;
            if t[j + k] &gt;= m {
                t[j + k] -= m;
            }
        }
    }

    for j in (v.len()..2 * v.len()).rev() {
        for k in 1..=v.len() {
            t[j - k] += t[j] * rec[k - 1] % m;
            if t[j - k] &gt;= m {
                t[j - k] -= m;
            }
        }
    }

    t[..v.len()].iter().map(|x| *x).collect()
}

/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under modulo m where d=rec.len()=arr.len()
fn kitamasa(rec: &amp;[u64], vals: &amp;[u64], mut n: u64, m: u64) -&gt; u64 {
    let recurr: Vec&lt;_&gt; = rec.iter().rev().copied().collect();
    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);
    s[0] = 1;
    if recurr.len() != 1 {
        t[1] = 1;
    } else {
        t[0] = recurr[0];
    }

    while n != 0 {
        if n &amp; 1 != 0 {
            s = poly_mul(&amp;s, &amp;t, &amp;recurr, m);
        }
        t = poly_mul(&amp;t, &amp;t, &amp;recurr, m);
        n &gt;&gt;= 1;
    }

    let mut ret = 0u64;
    for i in 0..recurr.len() {
        ret += s[i] * vals[i] % m;
        if ret &gt;= m {
            ret -= m;
        }
    }
    ret
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bostan-mori"><a class="header" href="#bostan-mori">Bostan-Mori</a></h1>
<p>Reference - <a href="https://hal.inria.fr/hal-02917827v2/document">Alin Bostan, Ryuhei Mori. A Simple and Fast Algorithm for Computing the N-th Term of a Linearly Recurrent Sequence. SOSA’21 (SIAM Symposium on Simplicity in Algorithms), Jan 2021, Alexandria, United States. ffhal-02917827v2f</a></p>
<h2 id="calculating-one-value-of-the-sequence"><a class="header" href="#calculating-one-value-of-the-sequence">Calculating one value of the sequence</a></h2>
<h3 id="naive-multiplication-under-prime-modulo"><a class="header" href="#naive-multiplication-under-prime-modulo">Naive multiplication, under prime modulo</a></h3>
<pre><code class="language-rust noplayground">/// Returns g, s, t s.t. g=gcd(a,b) and as+bt=r
#[inline(always)]
fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut r, mut old_r) = (b, a);
    while r != 0 {
        let q = old_r / r;

        let new_r = old_r - q * r;
        old_r = r;
        r = new_r;

        let new_s = old_s - q * s;
        old_s = s;
        s = new_s;
    }

    (
        old_r,
        old_s,
        if b != 0 { (old_r - old_s * a) / b } else { 0 },
    )
}

fn mod_inv(a: u64, m: u64) -&gt; u64 {
    let (_, mut x, _) = ext_gcd((a % m) as i64, m as i64);
    if x &lt; 0 {
        x += m as i64;
    }
    x as u64 % m
}

/// f = f[0] + f[1]x + f[2]x2 + ...
#[inline(always)]
fn poly_mul(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; f.len() + g.len() - 1];
    for (i, &amp;u) in f.iter().enumerate() {
        // u*x**i
        for (j, &amp;v) in g.iter().enumerate() {
            // v*x**j
            h[i + j] += u * v;
            h[i + j] %= m;
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

#[inline(always)]
fn poly_mul_even_order(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; (f.len() + g.len()) / 2 + 2];
    for (i, &amp;u) in f.iter().enumerate() {
        if i &amp; 1 == 0 {
            for (j, &amp;v) in g.iter().enumerate().step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        } else {
            for (j, &amp;v) in g.iter().enumerate().skip(1).step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

#[inline(always)]
fn poly_mul_odd_order(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; (f.len() + g.len()) / 2 + 2];
    for (i, &amp;u) in f.iter().enumerate() {
        if i &amp; 1 != 0 {
            for (j, &amp;v) in g.iter().enumerate().step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        } else {
            for (j, &amp;v) in g.iter().enumerate().skip(1).step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

/// f(x) -&gt; f(-x)
#[inline(always)]
fn get_neg_x(f: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    f.iter()
        .enumerate()
        .map(|(i, &amp;v)| if i &amp; 1 == 0 { v } else { m - v })
        .collect()
}

/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under modulo m where d=rec.len()=arr.len()
fn bostan_mori(rec: &amp;[u64], vals: &amp;[u64], n: u64, m: u64) -&gt; u64 {
    if vals.len() as u64 &gt; n {
        return vals[n as usize];
    }
    let d = rec.len();

    let mut q: Vec&lt;u64&gt; = Vec::with_capacity(d + 1);
    q.push(1);
    q.extend(rec.iter().map(|&amp;v| m - v).rev());

    let mut p = poly_mul(vals, &amp;q, m);
    p.truncate(d);

    let mut n = n;
    while n &gt;= 1 {
        let mq = get_neg_x(&amp;q, m);
        if n &amp; 1 == 0 {
            p = poly_mul_even_order(&amp;p, &amp;mq, m);
        } else {
            p = poly_mul_odd_order(&amp;p, &amp;mq, m);
        }
        q = poly_mul_even_order(&amp;q, &amp;mq, m);
        n &gt;&gt;= 1;
    }
    p[0] * mod_inv(q[0], m) // Requires GCD(q[0], m) = 1, it's safe to have m as a prime
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-n-dimensional-array"><a class="header" href="#fast-n-dimensional-array">Fast n-dimensional Array</a></h1>
<pre><code class="language-rust noplayground">struct Matrix&lt;T&gt;(Vec&lt;T&gt;, usize); // colnum

impl&lt;T&gt; Matrix&lt;T&gt; {
    fn new(arr: Vec&lt;T&gt;, r: usize, c: usize) -&gt; Self {
        assert_eq!(arr.len(), r * c);
        Self(arr, c)
    }
}

impl&lt;T&gt; std::ops::Index&lt;usize&gt; for Matrix&lt;T&gt; {
    type Output = [T];

    fn index(&amp;self, i: usize) -&gt; &amp;Self::Output {
        &amp;self.0[self.1 * i..self.1 * (i + 1)]
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for Matrix&lt;T&gt; {
    fn index_mut(&amp;mut self, i: usize) -&gt; &amp;mut Self::Output {
        &amp;mut self.0[self.1 * i..self.1 * (i + 1)]
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-array"><a class="header" href="#bit-array">Bit Array</a></h1>
<pre><code class="language-rust noplayground">struct BitArray {
    bytes: Vec&lt;u8&gt;,
}

impl BitArray {
    #[inline(always)]
    fn new(size: usize) -&gt; Self {
        Self {
            bytes: vec![0; (size &gt;&gt; 3) + 1],
        }
    }

    #[inline(always)]
    fn get(&amp;self, idx: usize) -&gt; bool {
        (self.bytes[idx &gt;&gt; 3] &gt;&gt; (idx &amp; 0b111)) &amp; 1 == 1
    }

    #[inline(always)]
    fn set_true(&amp;mut self, idx: usize) {
        self.bytes[idx &gt;&gt; 3] |= 1 &lt;&lt; (idx &amp; 0b111);
    }

    #[inline(always)]
    fn set_false(&amp;mut self, idx: usize) {
        self.bytes[idx &gt;&gt; 3] &amp;= !(1 &lt;&lt; (idx &amp; 0b111));
    }

    #[inline(always)]
    fn set(&amp;mut self, idx: usize, to: bool) {
        if to {
            self.set_true(idx);
        } else {
            self.set_false(idx);
        }
    }

    #[inline(always)]
    fn toggle(&amp;mut self, idx: usize) {
        self.bytes[idx &gt;&gt; 3] ^= 1 &lt;&lt; (idx &amp; 0b111);
    }

    #[inline(always)]
    fn fill(&amp;mut self, with: u8) {
        for v in self.bytes.iter_mut() {
            *v = with;
        }
    }

    #[inline(always)]
    fn fill_range(&amp;mut self, chunk_start: usize, chunk_end: usize, with: u8) {
        for v in self.bytes[chunk_start..chunk_end].iter_mut() {
            *v = with;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-trees"><a class="header" href="#segment-trees">Segment Trees</a></h1>
<p>Segment trees are a category of data structures which can handle range queries efficiently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A segment tree is a data structure for monoids \( (S, \cdot : S \times S \rightarrow S, e \in S) \). A monoid is an algebraic structure which follows the following conditions:</p>
<ul>
<li>\(\cdot\) is associative. That is, \( (a \cdot b) \cdot c = a \cdot (b \cdot c) \) for all \( a, b, c \in S \).</li>
<li>There is the identity element \(e\) such that \( a \cdot e = e \cdot a = a \) for all \( a \in S \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(S\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Update an element</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<pre><code class="language-rust noplayground">use std::ops::Index;

fn ceil_pow2(n: usize) -&gt; usize {
    let mut x: usize = 0;
    while (1 &lt;&lt; x) &lt; n {
        x += 1;
    }
    x
}

/// Represents each element of a segment tree, which should be a monoid $(S, \cdot)$.
trait Monoid {
    fn opr(&amp;self, other: &amp;Self) -&gt; Self;
    fn e() -&gt; Self;
}

/// Segment tree.
struct SegTree&lt;S: Monoid&gt; {
    n: usize,
    size: usize,
    log: usize,
    data: Vec&lt;S&gt;,
}

impl&lt;S: Monoid + Clone&gt; SegTree&lt;S&gt; {
    fn update(&amp;mut self, k: usize) {
        self.data[k] = self.data[k &lt;&lt; 1].opr(&amp;self.data[(k &lt;&lt; 1) + 1])
    }

    /// Initializes a segment tree from an array.
    fn new(arr: &amp;Vec&lt;S&gt;) -&gt; Self {
        let log = ceil_pow2(arr.len());
        let mut st: Self = SegTree {
            n: arr.len(),
            log,
            size: 1 &lt;&lt; log,
            data: vec![S::e(); 1 &lt;&lt; (log + 1)],
        };
        for (i, v) in arr.into_iter().enumerate() {
            st.data[st.size + i] = (*v).clone();
        }
        for i in (1..st.size).rev() {
            st.update(i);
        }
        st
    }

    /// Sets a value at index `i` to a value `v`.
    fn set(&amp;mut self, i: usize, v: &amp;S) {
        let i = i + self.size;
        self.data[i] = v.clone();
        for j in 1..=self.log {
            self.update(i &gt;&gt; j);
        }
    }

    /// Gets a reference of a value at index `i`.
    fn get(&amp;self, i: usize) -&gt; &amp;S {
        &amp;self[i]
    }

    /// Returns $A_l \cdot A_{l+1} \cdot \cdots \cdot A_{r-1}$. If $l=r$, then returns $e$.
    fn prod(&amp;self, l: usize, r: usize) -&gt; S {
        let (mut sml, mut smr) = (S::e(), S::e());
        let (mut l, mut r) = (l + self.size, r + self.size);

        while l &lt; r {
            if l &amp; 1 == 1 {
                sml = sml.opr(&amp;self.data[l]);
                l += 1;
            }
            if r &amp; 1 == 1 {
                r -= 1;
                smr = self.data[r].opr(&amp;smr);
            }
            l &gt;&gt;= 1;
            r &gt;&gt;= 1;
        }
        sml.opr(&amp;smr)
    }

    /// Returns $A_0 \cdot A_1 \cdot \cdots A_{n-1}$.
    fn all_prod(&amp;self) -&gt; S {
        self.data[1].clone()
    }

    fn max_right&lt;C: Fn(&amp;S) -&gt; bool&gt;(&amp;self, l: usize, f: C) -&gt; usize {
        if l == self.n {
            return self.n;
        }

        let mut l = l + self.size;
        let mut sm = S::e();

        loop {
            while l &amp; 1 == 0 {
                l &gt;&gt;= 1;
            }
            if !f(&amp;sm.opr(&amp;self.data[l])) {
                while l &lt; self.size {
                    l &lt;&lt;= 1;
                    if f(&amp;sm.opr(&amp;self.data[l])) {
                        sm = sm.opr(&amp;self.data[l]);
                        l += 1;
                    }
                }
                return l - self.size;
            }
            sm = sm.opr(&amp;self.data[l]);
            l += 1;
            if l &amp; ((!l) + 1) == l {
                break;
            }
        }
        self.n
    }
    
    fn min_left&lt;C: Fn(&amp;S) -&gt; bool&gt;(&amp;self, r: usize, f: C) -&gt; usize {
        if r == 0 {
            return 0;
        }

        let mut r = r + self.size;
        let mut sm = S::e();

        loop {
            r -= 1;
            while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                r &gt;&gt;= 1;
            }
            if !f(&amp;self.data[r].opr(&amp;sm)) {
                while r &lt; self.size {
                    r = (r &lt;&lt; 1) + 1;
                    if f(&amp;self.data[r].opr(&amp;sm)) {
                        sm = self.data[r].opr(&amp;sm);
                        r -= 1;
                    }
                }
                return r + 1 - self.size;
            }
            sm = self.data[r].opr(&amp;sm);

            if r &amp; ((!r) + 1) == r {
                break;
            }
        }
        0
    }
}

impl&lt;T: Monoid + Clone&gt; Index&lt;usize&gt; for SegTree&lt;T&gt; {
    type Output = T;

    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self.data[index + self.size]
    }
}
</code></pre>
<h2 id="using-max_right-and-min_left"><a class="header" href="#using-max_right-and-min_left">Using max_right and min_left</a></h2>
<h3 id="max_right"><a class="header" href="#max_right">max_right</a></h3>
<p>Given an index \(l\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(r=l\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(r=n\) or \( f \left( A_l \cdot A_{l+1} \cdots A_r \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the maximum \(r\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq l \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(r\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<h3 id="min_left"><a class="header" href="#min_left">min_left</a></h3>
<p>Given an index \(r\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(l=r\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(l=0\) or \( f \left( A_{l-1} \cdot A_l \cdots A_{r-1} \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the minimum \(l\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq r \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(l\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fenwick-tree"><a class="header" href="#fenwick-tree">Fenwick Tree</a></h1>
<p>Given an integer array \(A\) of length \(n\), a Fenwick tree processes the following queries in \(O(\log{n})\) time:</p>
<ul>
<li>Add a certain amount to an element</li>
<li>Calculate the sum of the elements of an interval</li>
</ul>
<p>A Fenwick tree uses half the memory of a segment tree, but the performance in terms of time is just about the same.</p>
<p>A type of elements of \(A\) must be a primitive signed integer type, such as <code>i32</code> and <code>i64</code>, and floats such as <code>f64</code>. Unsigned integer types like <code>u64</code> do not work.</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut fw: Fenwick&lt;i32&gt; = Fenwick::new(10);
for i in 0..10 {
    print!(&quot;{} &quot;, fw.get(i));
}
println!(); // 0 0 0 0 0 0 0 0 0 0

fw.add(2, 10);
fw.add(5, 100);
fw.add(3, -1);
for i in 0..10 {
    print!(&quot;{} &quot;, fw.get(i));
}
println!(); // 0 0 10 -1 0 100 0 0 0 0
<span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">struct Fenwick&lt;T&gt; {
</span><span class="boring">    n: usize,
</span><span class="boring">    data: Vec&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Copy + From&lt;i8&gt; + std::ops::AddAssign + std::ops::Sub&lt;Output = T&gt;&gt; Fenwick&lt;T&gt; {
</span><span class="boring">    fn new(n: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            data: vec![0.into(); n],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add(&amp;mut self, idx: usize, val: T) {
</span><span class="boring">        let mut idx = idx + 1;
</span><span class="boring">        while idx &lt;= self.n {
</span><span class="boring">            self.data[idx - 1] += val;
</span><span class="boring">            idx += idx &amp; (!idx + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self, idx: usize) -&gt; T {
</span><span class="boring">        self.sum(idx, idx + 1)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn sum(&amp;self, l: usize, r: usize) -&gt; T {
</span><span class="boring">        self.inner_sum(r) - self.inner_sum(l)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn inner_sum(&amp;self, mut r: usize) -&gt; T {
</span><span class="boring">        let mut s: T = 0.into();
</span><span class="boring">        while r &gt; 0 {
</span><span class="boring">            s += self.data[r - 1];
</span><span class="boring">            r -= r &amp; (!r + 1);
</span><span class="boring">        }
</span><span class="boring">        s
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code-7"><a class="header" href="#code-7">Code</a></h2>
<pre><code class="language-rust noplayground#[derive(Clone  Debug)]">struct Fenwick&lt;T&gt; {
    n: usize,
    data: Vec&lt;T&gt;,
}

impl&lt;T: Copy + From&lt;i8&gt; + std::ops::AddAssign + std::ops::Sub&lt;Output = T&gt;&gt; Fenwick&lt;T&gt; {
    fn new(n: usize) -&gt; Self {
        Self {
            n,
            data: vec![0.into(); n],
        }
    }

    fn add(&amp;mut self, idx: usize, val: T) {
        let mut idx = idx + 1;
        while idx &lt;= self.n {
            self.data[idx - 1] += val;
            idx += idx &amp; (!idx + 1);
        }
    }

    fn get(&amp;self, idx: usize) -&gt; T {
        self.sum(idx, idx + 1)
    }

    fn sum(&amp;self, l: usize, r: usize) -&gt; T {
        self.inner_sum(r) - self.inner_sum(l)
    }

    fn inner_sum(&amp;self, mut r: usize) -&gt; T {
        let mut s: T = 0.into();
        while r &gt; 0 {
            s += self.data[r - 1];
            r -= r &amp; (!r + 1);
        }
        s
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-segment-tree"><a class="header" href="#lazy-segment-tree">Lazy Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A lazy segment tree is a data struture for a pair of a monoid \( (S, \cdot : S \times S \rightarrow S, e \in S) \) and a set \(F\) of \(S \rightarrow S\) mappings that satisfies the following properties:</p>
<ul>
<li>\(F\) contains the identity mapping \(Id\) such that \( Id(x) = x \) for all \(x\in S\).</li>
<li>\(F\) is closed under composition. That is, \( f \circ g \in F \) for all \( f, g \in F \).</li>
<li>\( f (x \cdot y) = f(x) \cdot f(y) \) hold for all \(f \in F \) and \( x, y \in S \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(S\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Apply the mapping \( f \in F \) on all the elements of an interval</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<pre><code class="language-rust noplayground">fn ceil_pow2(n: usize) -&gt; usize {
    let mut x: usize = 0;
    while (1 &lt;&lt; x) &lt; n {
        x += 1;
    }
    x
}

/// Represents a monoid in a lazy segment tree $(S, \cdot)$.
trait Monoid {
    fn opr(&amp;self, other: &amp;Self) -&gt; Self;
    fn e() -&gt; Self;
}

/// Represents a map $F$ acting on the monoid $(S, \cdot)$.
trait Mapping&lt;T: Monoid&gt; {
    fn map(&amp;self, apply: &amp;T) -&gt; T;
    fn compos(&amp;self, other: &amp;Self) -&gt; Self;
    fn id() -&gt; Self;
}

/// Lazy segment tree for the monoid $(S, \cdot)$ and the map $F$.
struct LazySeg&lt;S: Monoid, F: Mapping&lt;S&gt;&gt; {
    n: usize,
    size: usize,
    log: usize,
    data: Vec&lt;S&gt;,
    lazy: Vec&lt;F&gt;,
}

impl&lt;S, F&gt; LazySeg&lt;S, F&gt;
where
    S: Monoid + Clone,
    F: Mapping&lt;S&gt; + Clone,
{
    fn update(&amp;mut self, k: usize) {
        self.data[k] = self.data[k &lt;&lt; 1].opr(&amp;self.data[(k &lt;&lt; 1) + 1]);
    }

    fn all_apply(&amp;mut self, k: usize, f: &amp;F) {
        self.data[k] = f.map(&amp;self.data[k]);
        if k &lt; self.size {
            self.lazy[k] = f.compos(&amp;self.lazy[k]);
        }
    }

    fn push(&amp;mut self, k: usize) {
        self.all_apply(k &lt;&lt; 1, &amp;self.lazy[k].clone());
        self.all_apply((k &lt;&lt; 1) + 1, &amp;self.lazy[k].clone());
        self.lazy[k] = F::id();
    }

    /// Initializes the lazy segment tree from the given array.
    fn new(arr: &amp;Vec&lt;S&gt;) -&gt; Self {
        let log = ceil_pow2(arr.len());
        let mut ls: Self = LazySeg {
            n: arr.len(),
            log,
            size: 1 &lt;&lt; log,
            data: vec![S::e(); 1 &lt;&lt; (log + 1)],
            lazy: vec![F::id(); 1 &lt;&lt; log],
        };
        for (i, v) in arr.into_iter().enumerate() {
            ls.data[ls.size + i] = (*v).clone();
        }
        for i in (1..ls.size).rev() {
            ls.update(i);
        }
        ls
    }

    /// Sets a value at the index `i` to `v`.
    fn set(&amp;mut self, i: usize, v: &amp;S) {
        let i = i + self.size;
        for j in (1..=self.log).rev() {
            self.push(i &gt;&gt; j);
        }
        self.data[i] = v.clone();
        for j in 1..=self.log {
            self.update(i &gt;&gt; j);
        }
    }

    /// Returns a reference to the value at the index `i`.
    fn get(&amp;mut self, i: usize) -&gt; &amp;S {
        let i = i + self.size;
        for j in (1..=self.log).rev() {
            self.push(i &gt;&gt; j);
        }
        &amp;self.data[i]
    }

    /// Returns a product of elements in [l, r).
    fn prod(&amp;mut self, l: usize, r: usize) -&gt; S {
        if l == r {
            return S::e();
        }

        let (mut l, mut r) = (l + self.size, r + self.size);

        for i in (1..=self.log).rev() {
            if ((l &gt;&gt; i) &lt;&lt; i) != l {
                self.push(l &gt;&gt; i);
            }
            if ((r &gt;&gt; i) &lt;&lt; i) != r {
                self.push((r - 1) &gt;&gt; i);
            }
        }

        let (mut sml, mut smr) = (S::e(), S::e());
        while l &lt; r {
            if l &amp; 1 == 1 {
                sml = sml.opr(&amp;self.data[l]);
                l += 1;
            }
            if r &amp; 1 == 1 {
                r -= 1;
                smr = self.data[r].opr(&amp;smr);
            }
            l &gt;&gt;= 1;
            r &gt;&gt;= 1;
        }

        sml.opr(&amp;smr)
    }

    /// Returns the product of every elements.
    fn all_prod(&amp;self) -&gt; S {
        self.data[1].clone()
    }

    /// Apply a map `f` to the element at `i`.
    fn apply(&amp;mut self, i: usize, f: &amp;F) {
        let i = i + self.size;
        for j in (1..=self.log).rev() {
            self.push(i &gt;&gt; j);
        }
        self.data[i] = f.map(&amp;self.data[i]);
        for j in 1..=self.log {
            self.update(i &gt;&gt; j);
        }
    }

    /// Apply a map `f` to the element in an interval [l, r).
    fn apply_range(&amp;mut self, l: usize, r: usize, f: &amp;F) {
        if l == r {
            return;
        }

        let (mut l, mut r) = (l + self.size, r + self.size);

        for i in (1..=self.log).rev() {
            if ((l &gt;&gt; i) &lt;&lt; i) != l {
                self.push(l &gt;&gt; i);
            }
            if ((r &gt;&gt; i) &lt;&lt; i) != r {
                self.push((r - 1) &gt;&gt; i);
            }
        }

        let (l2, r2) = (l, r);
        while l &lt; r {
            if l &amp; 1 == 1 {
                self.all_apply(l, f);
                l += 1;
            }
            if r &amp; 1 == 1 {
                r -= 1;
                self.all_apply(r, f);
            }
            l &gt;&gt;= 1;
            r &gt;&gt;= 1;
        }
        l = l2;
        r = r2;

        for i in 1..=self.log {
            if ((l &gt;&gt; i) &lt;&lt; i) != l {
                self.update(l &gt;&gt; i);
            }
            if ((r &gt;&gt; i) &lt;&lt; i) != r {
                self.update((r - 1) &gt;&gt; i);
            }
        }
    }
    
    fn max_right&lt;C: Fn(&amp;S) -&gt; bool&gt;(&amp;mut self, l: usize, g: C) -&gt; usize {
        if l == self.n {
            return self.n;
        }

        let mut l = l + self.size;
        for i in (1..=self.log).rev() {
            self.push(l &gt;&gt; i);
        }

        let mut sm = S::e();
        loop {
            while l &amp; 1 == 0 {
                l &gt;&gt;= 1;
            }
            if !g(&amp;sm.opr(&amp;self.data[l])) {
                while l &lt; self.size {
                    self.push(l);
                    l &lt;&lt;= 1;
                    if g(&amp;sm.opr(&amp;self.data[l])) {
                        sm = sm.opr(&amp;self.data[l]);
                        l += 1;
                    }
                }
                return l - self.size;
            }
            sm = sm.opr(&amp;self.data[l]);
            l += 1;

            if l &amp; ((!l) + 1) != l {
                break;
            }
        }
        self.n
    }
    
    fn min_left&lt;C: Fn(&amp;S) -&gt; bool&gt;(&amp;mut self, r: usize, g: C) -&gt; usize {
        if r == 0 {
            return 0;
        }

        let mut r = r + self.size;
        for i in (1..=self.log).rev() {
            self.push((r - 1) &gt;&gt; i);
        }

        let mut sm = S::e();
        loop {
            r -= 1;
            while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                r &gt;&gt;= 1;
            }
            if !g(&amp;self.data[r].opr(&amp;sm)) {
                while r &lt; self.size {
                    self.push(r);
                    r = (r &lt;&lt; 1) + 1;
                    if g(&amp;self.data[r].opr(&amp;sm)) {
                        sm = self.data[r].opr(&amp;sm);
                        r -= 1;
                    }
                }
                return r + 1 - self.size;
            }
            sm = self.data[r].opr(&amp;sm);

            if r &amp; ((!r) + 1) == r {
                break;
            }
        }
        0
    }
}
</code></pre>
<h2 id="using-max_right-and-min_left-1"><a class="header" href="#using-max_right-and-min_left-1">Using max_right and min_left</a></h2>
<h3 id="max_right-1"><a class="header" href="#max_right-1">max_right</a></h3>
<p>Given an index \(l\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(r=l\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(r=n\) or \( f \left( A_l \cdot A_{l+1} \cdots A_r \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the maximum \(r\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq l \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(r\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<h3 id="min_left-1"><a class="header" href="#min_left-1">min_left</a></h3>
<p>Given an index \(r\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(l=r\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(l=0\) or \( f \left( A_{l-1} \cdot A_l \cdots A_{r-1} \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the minimum \(l\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq r \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(l\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<h2 id="examples-of-monoid-and-mapping-implementation"><a class="header" href="#examples-of-monoid-and-mapping-implementation">Examples of monoid and mapping implementation</a></h2>
<h3 id="axb-lazy-segment-tree"><a class="header" href="#axb-lazy-segment-tree">\(ax+b\) lazy segment tree</a></h3>
<pre><code class="language-rust noplayground">#[derive(Clone)]
struct Elm {
    len: i128,
    sum: i128,
}

impl Monoid for Elm {
    fn opr(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            len: self.len + other.len,
            sum: self.sum + other.sum,
        }
    }
    fn e() -&gt; Self {
        Self { len: 0, sum: 0 }
    }
}

#[derive(Clone)]
struct Map {
    mul: i128,
    add: i128,
}

impl Mapping&lt;Elm&gt; for Map {
    fn map(&amp;self, apply: &amp;Elm) -&gt; Elm {
        Elm {
            len: apply.len,
            sum: self.mul * apply.sum + self.add * apply.len,
        }
    }
    fn compos(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            mul: self.mul * other.mul,
            add: self.mul * other.add + self.add,
        }
    }
    fn id() -&gt; Self {
        Self { mul: 1, add: 0 }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adjacency-list-graph-representation"><a class="header" href="#adjacency-list-graph-representation">Adjacency List Graph Representation</a></h1>
<p>Credits to kiwiyou</p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Graph&lt;T&gt; {
    n: usize,
    first: Vec&lt;usize&gt;,
    edge: Vec&lt;(usize, usize, T)&gt;, // (to, prev, data)
}

impl&lt;T&gt; Graph&lt;T&gt; {
    fn new(n: usize, e: usize) -&gt; Self {
        Self {
            n,
            first: vec![usize::MAX; n],
            edge: Vec::with_capacity(e),
        }
    }

    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len());
        self.edge.push((to, prev, data));
    }

    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
        Neighbor {
            graph: self,
            next_edge: self.first[of],
        }
    }
}

struct Neighbor&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    next_edge: usize,
}

impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
    type Item = (usize, &amp;'g T);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (to, next_edge, data) = self.graph.edge.get(self.next_edge)?;
        self.next_edge = *next_edge;
        Some((*to, data))
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disjoint-set-union"><a class="header" href="#disjoint-set-union">Disjoint Set Union</a></h1>
<p>Disjoint set union (a.k.a Union-Find) processes the following queries on a graph with \(n\) nodes without any edges:</p>
<ul>
<li>Add an undirected edge between two nodes (<code>union</code>)</li>
<li>Determine if there exist a path between two nodes (<code>is_reachable</code>)</li>
</ul>
<pre><code class="language-rust noplayground">struct UnionFind {
    size: usize,
    parents: Vec&lt;usize&gt;,
    group_size: Vec&lt;usize&gt;,
    group_num: usize,
}

impl UnionFind {
    /// Returns a new UnionFind instance where `size` number of elements are in their own disjoint set.
    fn new(size: usize) -&gt; Self {
        Self {
            size,
            parents: vec![size; size],
            group_size: vec![1; size],
            group_num: size,
        }
    }

    /// Returns the number of nodes which can be reached from x.
    fn get_group_size(&amp;mut self, x: usize) -&gt; usize {
        let root = self.find_root(x);
        self.group_size[root]
    }

    /// Returns the number of connected components.
    fn get_group_num(&amp;self) -&gt; usize {
        self.group_num
    }

    fn find_root(&amp;mut self, x: usize) -&gt; usize {
        if self.parents[x] == self.size {
            return x;
        }
        let root = self.find_root(self.parents[x]);
        self.parents[x] = root;
        root
    }

    /// Returns true if there exists a path from a to b.
    fn is_reachable(&amp;mut self, a: usize, b: usize) -&gt; bool {
        self.find_root(a) == self.find_root(b)
    }

    /// Add an edge between a and b.
    fn union(&amp;mut self, a: usize, b: usize) {
        let a_root = self.find_root(a);
        let b_root = self.find_root(b);

        if a_root != b_root {
            self.group_num -= 1;
            let a_size = self.group_size[a_root];
            let b_size = self.group_size[b_root];
            if a_size &lt; b_size {
                self.parents[a_root] = b_root;
                self.group_size[b_root] += a_size;
            } else {
                self.parents[b_root] = a_root;
                self.group_size[a_root] += b_size;
            }
        }
    }
}
</code></pre>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<pre><code class="language-rust noplayground">let mut uf = UnionFind::new(10);
assert_eq!(uf.is_reachable(2, 6), false);
uf.union(2, 6);
assert_eq!(uf.is_reachable(2, 6), true);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strongly-connected-components"><a class="header" href="#strongly-connected-components">Strongly Connected Components</a></h1>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Graph&lt;T&gt; {
    n: u32,
    first: Vec&lt;u32&gt;,
    edge: Vec&lt;(u32, u32, T)&gt;, // (to, prev, data)
}

impl&lt;T&gt; Graph&lt;T&gt; {
    fn new(n: u32, e: u32) -&gt; Self {
        Self {
            n,
            first: vec![u32::MAX; n as usize],
            edge: Vec::with_capacity(e as usize),
        }
    }

    fn add_edge(&amp;mut self, from: u32, to: u32, data: T) {
        let prev = std::mem::replace(&amp;mut self.first[from as usize], self.edge.len() as u32);
        self.edge.push((to, prev, data));
    }

    fn neighbor(&amp;self, of: u32) -&gt; Neighbor&lt;T&gt; {
        Neighbor {
            graph: self,
            next_edge: self.first[of as usize],
        }
    }
}

struct Neighbor&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    next_edge: u32,
}

impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
    type Item = (u32, &amp;'g T);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (to, next_edge, data) = self.graph.edge.get(self.next_edge as usize)?;
        self.next_edge = *next_edge;
        Some((*to, data))
    }
}

struct SccStack {
    stack: Vec&lt;u32&gt;,
    check: Vec&lt;bool&gt;,
}

impl SccStack {
    fn new(cap: u32) -&gt; Self {
        Self {
            stack: vec![0; cap as usize],
            check: vec![false; cap as usize],
        }
    }

    fn len(&amp;self) -&gt; u32 {
        self.stack.len() as u32
    }

    fn push(&amp;mut self, n: u32) {
        self.stack.push(n);
        self.check[n as usize] = true;
    }

    fn get(&amp;self) -&gt; u32 {
        self.stack[self.len() as usize - 1]
    }

    fn pop(&amp;mut self) -&gt; u32 {
        let tmp = self.stack.pop().unwrap();
        self.check[tmp as usize] = false;
        tmp
    }

    fn is_in(&amp;self, n: u32) -&gt; bool {
        self.check[n as usize]
    }
}

struct SCC&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    scc_list: Vec&lt;Vec&lt;u32&gt;&gt;,
    scc_ids: Vec&lt;u32&gt;,
}

impl&lt;'g, T: 'g&gt; SCC&lt;'g, T&gt; {
    fn new(graph: &amp;'g Graph&lt;T&gt;) -&gt; Self {
        let mut st = SccStack::new(graph.n);
        let mut list: Vec&lt;Vec&lt;u32&gt;&gt; = Vec::new();
        let mut gid: u32 = 0;
        let mut id = vec![graph.n; graph.n as usize];
        let mut low = vec![u32::MAX; graph.n as usize];

        for x in 0..graph.n {
            if id[x as usize] != graph.n {
                continue;
            }
            Self::dfs(graph, x, &amp;mut gid, &amp;mut id, &amp;mut low, &amp;mut st, &amp;mut list)
        }
        list.reverse();

        let mut ids = vec![0u32; graph.n as usize];
        for (i, l) in list.iter().enumerate() {
            for &amp;v in l.iter() {
                ids[v as usize] = i as u32;
            }
        }

        Self {
            graph,
            scc_list: list,
            scc_ids: ids,
        }
    }

    fn dfs(
        graph: &amp;Graph&lt;T&gt;,
        curr: u32,
        gid: &amp;mut u32,
        id: &amp;mut Vec&lt;u32&gt;,
        low: &amp;mut Vec&lt;u32&gt;,
        st: &amp;mut SccStack,
        list: &amp;mut Vec&lt;Vec&lt;u32&gt;&gt;,
    ) {
        st.push(curr);
        id[curr as usize] = *gid;
        low[curr as usize] = *gid;
        (*gid) += 1;

        for (next, _) in graph.neighbor(curr) {
            if id[next as usize] == graph.n {
                Self::dfs(graph, next, gid, id, low, st, list);
            }
        }

        for (next, _) in graph.neighbor(curr) {
            if st.is_in(next) {
                low[curr as usize] = low[curr as usize].min(low[next as usize]);
            }
        }

        if id[curr as usize] == low[curr as usize] {
            let p = list.len();
            list.push(Vec::new());
            while st.len() != 0 &amp;&amp; st.get() != curr {
                list[p].push(st.pop());
            }
            st.pop();
            list[p].push(curr);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sat"><a class="header" href="#2-sat">2-SAT</a></h1>
<p>Required snippets: <a href="graphs/./scc.html#strongly-connected-components">SCC</a></p>
<pre><code class="language-rust noplayground">struct TwoSat {
    n: u32,
    graph: Graph&lt;()&gt;,
}

impl TwoSat {
    fn new(n: u32, clause_num: u32) -&gt; Self {
        Self {
            n,
            graph: Graph::new(n &lt;&lt; 1, clause_num &lt;&lt; 1),
        }
    }

    fn judge(f: bool, a: u32, b: u32) -&gt; u32 {
        if f {
            a
        } else {
            b
        }
    }

    fn add_clause(&amp;mut self, i: u32, f: bool, j: u32, g: bool) {
        self.graph.add_edge(
            (i &lt;&lt; 1) + Self::judge(f, 0, 1),
            (j &lt;&lt; 1) + Self::judge(g, 1, 0),
            (),
        );
        self.graph.add_edge(
            (j &lt;&lt; 1) + Self::judge(g, 0, 1),
            (i &lt;&lt; 1) + Self::judge(f, 1, 0),
            (),
        );
    }

    fn solve(self) -&gt; Option&lt;Vec&lt;bool&gt;&gt; {
        let mut answer = vec![false; self.n as usize];

        let scc = SCC::new(&amp;self.graph);
        let ids = &amp;scc.scc_ids;

        for i in 0..self.n {
            if ids[(i as usize) &lt;&lt; 1] == ids[((i as usize) &lt;&lt; 1) + 1] {
                return None;
            }
            answer[i as usize] = ids[(i as usize) &lt;&lt; 1] &lt; ids[((i as usize) &lt;&lt; 1) + 1];
        }
        Some(answer)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<p>Given an array \(P\), <code>KMPNeedle::new(P)</code> returns a <code>KMPNeedle</code> instance for searching \(P\) in any array, using <code>KMPMatcher</code>.</p>
<p>Given a <code>KMPNeedle</code> instance <code>p</code> and an array target \(T\), <code>KMPMatcher::new(&amp;p, T)</code> returns an iterator yielding indicies where \(P\) appears within \(T\). Even if some ranges where \(P\) exists within \(T\) overlap with each other, they are still all yielded as shown in the second string from the example <code>&quot;ABCDABCDABCD&quot;</code>.</p>
<p><code>KMPNeedle::new(P)</code> runs in a time complexity of \(O(\left| P \right|)\) and <code>KMPMatcher::new(T)</code> takes a time complexity of \(O(\left| T \right|)\) to be consumed. <code>KMPMatcher</code> searches for a pattern lazily, so it only takes time of total searched length in \(T\).</p>
<p>A single <code>KMPNeedle</code> instance can be used to search \(P\) in multiple arrays as shown in the example.</p>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let pattern = &quot;ABCDABC&quot;;
let targets = vec![&quot;ABDABCDABCE&quot;, &quot;ABCDABCDABCD&quot;, &quot;ABBCCABCDABDABCDABC&quot;];

let needle = KMPNeedle::new(pattern.as_bytes());
for &amp;t in targets.iter() {
    let kmp = KMPMatcher::new(&amp;needle, t.as_bytes());
    for v in kmp {
        print!(&quot;{} &quot;, v);
    }
    println!();
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KMPNeedle&lt;'a, T: PartialEq&gt; {
</span><span class="boring">    p: &amp;'a [T],
</span><span class="boring">    c: Vec&lt;usize&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T: PartialEq&gt; KMPNeedle&lt;'a, T&gt; {
</span><span class="boring">    fn new(p: &amp;'a [T]) -&gt; Self {
</span><span class="boring">        let mut c: Vec&lt;usize&gt; = vec![0; p.len() + 1];
</span><span class="boring">
</span><span class="boring">        let mut l = 0;
</span><span class="boring">        for (r, v) in p.iter().enumerate().skip(1) {
</span><span class="boring">            while l &gt; 0 &amp;&amp; p[l] != *v {
</span><span class="boring">                l = c[l];
</span><span class="boring">            }
</span><span class="boring">            if p[l] == *v {
</span><span class="boring">                c[r + 1] = l + 1;
</span><span class="boring">                l += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Self { p, c }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KMPMatcher&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; {
</span><span class="boring">    needle: &amp;'c KMPNeedle&lt;'b, T&gt;,
</span><span class="boring">    t: &amp;'a [T],
</span><span class="boring">    i: usize,
</span><span class="boring">    j: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; KMPMatcher&lt;'a, 'b, 'c, T&gt; {
</span><span class="boring">    fn new(needle: &amp;'c KMPNeedle&lt;'b, T&gt;, t: &amp;'a [T]) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            needle,
</span><span class="boring">            t,
</span><span class="boring">            i: 0,
</span><span class="boring">            j: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; Iterator for KMPMatcher&lt;'a, 'b, 'c, T&gt; {
</span><span class="boring">    type Item = usize;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        while self.i &lt; self.t.len() {
</span><span class="boring">            while self.j &gt; 0 &amp;&amp; self.t[self.i] != self.needle.p[self.j] {
</span><span class="boring">                self.j = self.needle.c[self.j];
</span><span class="boring">            }
</span><span class="boring">            if self.t[self.i] == self.needle.p[self.j] {
</span><span class="boring">                if self.j == self.needle.p.len() - 1 {
</span><span class="boring">                    self.j = self.needle.c[self.j + 1];
</span><span class="boring">                    self.i += 1;
</span><span class="boring">                    return Some(self.i - self.needle.p.len());
</span><span class="boring">                } else {
</span><span class="boring">                    self.j += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            self.i += 1;
</span><span class="boring">        }
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code-8"><a class="header" href="#code-8">Code</a></h2>
<pre><code class="language-rust noplayground">struct KMPNeedle&lt;'a, T: PartialEq&gt; {
    p: &amp;'a [T],
    c: Vec&lt;usize&gt;,
}

impl&lt;'a, T: PartialEq&gt; KMPNeedle&lt;'a, T&gt; {
    fn new(p: &amp;'a [T]) -&gt; Self {
        let mut c: Vec&lt;usize&gt; = vec![0; p.len() + 1];

        let mut l = 0;
        for (r, v) in p.iter().enumerate().skip(1) {
            while l &gt; 0 &amp;&amp; p[l] != *v {
                l = c[l];
            }
            if p[l] == *v {
                c[r + 1] = l + 1;
                l += 1;
            }
        }

        Self { p, c }
    }
}

struct KMPMatcher&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; {
    needle: &amp;'c KMPNeedle&lt;'b, T&gt;,
    t: &amp;'a [T],
    i: usize,
    j: usize,
}

impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; KMPMatcher&lt;'a, 'b, 'c, T&gt; {
    fn new(needle: &amp;'c KMPNeedle&lt;'b, T&gt;, t: &amp;'a [T]) -&gt; Self {
        Self {
            needle,
            t,
            i: 0,
            j: 0,
        }
    }
}

impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; Iterator for KMPMatcher&lt;'a, 'b, 'c, T&gt; {
    type Item = usize;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        while self.i &lt; self.t.len() {
            while self.j &gt; 0 &amp;&amp; self.t[self.i] != self.needle.p[self.j] {
                self.j = self.needle.c[self.j];
            }
            if self.t[self.i] == self.needle.p[self.j] {
                if self.j == self.needle.p.len() - 1 {
                    self.j = self.needle.c[self.j + 1];
                    self.i += 1;
                    return Some(self.i - self.needle.p.len());
                } else {
                    self.j += 1;
                }
            }
            self.i += 1;
        }
        None
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<p>For an array \(A\) of length \(n\), <code>manacher(A)</code> returns a vector \(M\) where, for every \(i \in \left[0, n\right)\), \(A_{i-j} = A_{i+j}\) holds for every \(j \in \left[0, M_i \right)\).</p>
<p>Additional modification should be added by a user to use this function for finding every palindromes among subsequences of a string.</p>
<h2 id="example-11"><a class="header" href="#example-11">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = &quot;abracadacabra&quot;.as_bytes();
let man = manacher(s);
println!(&quot;{:?}&quot;, man); // [1, 1, 1, 1, 2, 1, 4, 1, 2, 1, 1, 1, 1]

for i in 0..s.len() {
    println!(
        &quot;{}&quot;,
        std::str::from_utf8(&amp;s[i + 1 - man[i]..i + man[i]]).unwrap()
    );
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn manacher&lt;T: Eq&gt;(arr: &amp;[T]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    let n = arr.len();
</span><span class="boring">    let mut mana: Vec&lt;usize&gt; = vec![1; n];
</span><span class="boring">    let mut r: usize = 1;
</span><span class="boring">    let mut p: usize = 0;
</span><span class="boring">
</span><span class="boring">    for i in 1..arr.len() {
</span><span class="boring">        if i + 1 &gt;= r {
</span><span class="boring">            mana[i] = 1;
</span><span class="boring">        } else {
</span><span class="boring">            let j = 2 * p - i;
</span><span class="boring">            mana[i] = mana[j].min(r - i);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        while mana[i] &lt;= i &amp;&amp; i + mana[i] &lt; n {
</span><span class="boring">            if arr[(i - mana[i])] != arr[(i + mana[i])] {
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">            mana[i] += 1;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if r &lt; mana[i] + i {
</span><span class="boring">            r = mana[i] + i;
</span><span class="boring">            p = i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    mana
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code-9"><a class="header" href="#code-9">Code</a></h2>
<pre><code class="language-rust noplayground">fn manacher&lt;T: Eq&gt;(arr: &amp;[T]) -&gt; Vec&lt;usize&gt; {
    let n = arr.len();
    let mut mana: Vec&lt;usize&gt; = vec![1; n];
    let mut r: usize = 1;
    let mut p: usize = 0;

    for i in 1..arr.len() {
        if i + 1 &gt;= r {
            mana[i] = 1;
        } else {
            let j = 2 * p - i;
            mana[i] = mana[j].min(r - i);
        }

        while mana[i] &lt;= i &amp;&amp; i + mana[i] &lt; n {
            if arr[(i - mana[i])] != arr[(i + mana[i])] {
                break;
            }
            mana[i] += 1;
        }

        if r &lt; mana[i] + i {
            r = mana[i] + i;
            p = i;
        }
    }

    mana
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suffix-array-and-lcp-array"><a class="header" href="#suffix-array-and-lcp-array">Suffix Array and LCP Array</a></h1>
<p>For an array \(A\) of length \(n\), <code>sa_lcp(A)</code> returns two vectors \(SA\) and \(LCP\) where,</p>
<ul>
<li>\(A[SA[i] \dots]\) is the \(i\)-th suffix in lexicographical order for every \(i \in \left[0, n\right)\)</li>
</ul>
<p>and</p>
<ul>
<li>\(LCP[i]\) is the length of the longest common prefix between \(A[SA[i-1] \dots]\) and \(A[SA[i] \dots]\) for every \(i \in \left[1, n \right)\). Also, \(LCP[0] = 0\).</li>
</ul>
<p>\(SA\) and \(LCP\) are called &quot;suffix array&quot; and &quot;LCP array&quot; of \(A\) respectively.</p>
<p>For finding SA, Manber-Myers algorithm combined with counting sort is used, hence the time complexity is \(O(n\log{n})\). For LCP array, Kasai's algorithm is used, hence the time complexity is \(O(n)\). The total time complexity is \(O(n\log{n})\).</p>
<h2 id="example-12"><a class="header" href="#example-12">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = &quot;asdsdasd&quot;;
let (sa, lcp) = sa_lcp(s.as_bytes());
println!(&quot;{:?}&quot;, sa);  // [5, 0, 7, 4, 2, 6, 3, 1]
println!(&quot;{:?}&quot;, lcp); // [x, 3, 0, 1, 1, 0, 2, 2]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Suffix array and LCP array
</span><span class="boring">// Reference: http://www.secmem.org/blog/2021/07/18/suffix-array-and-lcp/
</span><span class="boring">
</span><span class="boring">fn suffix_array&lt;T: Ord&gt;(s: &amp;[T]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    use std::collections::*;
</span><span class="boring">
</span><span class="boring">    if s.len() == 0 {
</span><span class="boring">        return vec![];
</span><span class="boring">    } else if s.len() == 1 {
</span><span class="boring">        return vec![0];
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let n = s.len();
</span><span class="boring">
</span><span class="boring">    let mut r: Vec&lt;usize&gt; = vec![0; n * 2];
</span><span class="boring">    let map: BTreeMap&lt;_, _&gt; = {
</span><span class="boring">        let mut sorted: Vec&lt;_&gt; = s.iter().collect();
</span><span class="boring">        sorted.sort_unstable();
</span><span class="boring">        sorted
</span><span class="boring">            .into_iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .map(|x| (x.1, x.0 + 1))
</span><span class="boring">            .collect()
</span><span class="boring">    };
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        r[i] = *map.get(&amp;s[i]).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let m = n.max(map.len()) + 1;
</span><span class="boring">    let mut sa: Vec&lt;usize&gt; = (0..n).collect();
</span><span class="boring">    let mut nr: Vec&lt;usize&gt; = vec![0; n * 2];
</span><span class="boring">    let mut cnt: Vec&lt;usize&gt; = vec![0; m];
</span><span class="boring">    let mut idx: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">
</span><span class="boring">    for d in (0..).map(|x| 1 &lt;&lt; x).take_while(|&amp;d| d &lt; n) {
</span><span class="boring">        macro_rules! key {
</span><span class="boring">            ($i:expr) =&gt; {
</span><span class="boring">                if $i + d &gt;= n {
</span><span class="boring">                    (r[$i], 0)
</span><span class="boring">                } else {
</span><span class="boring">                    (r[$i], r[$i + d])
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        (0..m).for_each(|i| cnt[i] = 0);
</span><span class="boring">        (0..n).for_each(|i| cnt[r[i + d]] += 1);
</span><span class="boring">        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
</span><span class="boring">        for i in (0..n).rev() {
</span><span class="boring">            cnt[r[i + d]] -= 1;
</span><span class="boring">            idx[cnt[r[i + d]]] = i;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        (0..m).for_each(|i| cnt[i] = 0);
</span><span class="boring">        (0..n).for_each(|i| cnt[r[i]] += 1);
</span><span class="boring">        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
</span><span class="boring">        for i in (0..n).rev() {
</span><span class="boring">            cnt[r[idx[i]]] -= 1;
</span><span class="boring">            sa[cnt[r[idx[i]]]] = idx[i];
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        nr[sa[0]] = 1;
</span><span class="boring">        for i in 1..n {
</span><span class="boring">            nr[sa[i]] = nr[sa[i - 1]] + if key!(sa[i - 1]) &lt; key!(sa[i]) { 1 } else { 0 };
</span><span class="boring">        }
</span><span class="boring">        std::mem::swap(&amp;mut r, &amp;mut nr);
</span><span class="boring">
</span><span class="boring">        if r[sa[n - 1]] == n {
</span><span class="boring">            break;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    sa
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn sa_lcp&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
</span><span class="boring">    let n = arr.len();
</span><span class="boring">    let sa = suffix_array(arr);
</span><span class="boring">    let mut lcp: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">    let mut isa: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        isa[sa[i]] = i;
</span><span class="boring">    }
</span><span class="boring">    let mut k = 0;
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        if isa[i] != 0 {
</span><span class="boring">            let j = sa[isa[i] - 1];
</span><span class="boring">            while i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; arr[i + k] == arr[j + k] {
</span><span class="boring">                k += 1;
</span><span class="boring">            }
</span><span class="boring">            lcp[isa[i]] = if k != 0 {
</span><span class="boring">                k -= 1;
</span><span class="boring">                k + 1
</span><span class="boring">            } else {
</span><span class="boring">                0
</span><span class="boring">            };
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    (sa, lcp)
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="code-10"><a class="header" href="#code-10">Code</a></h2>
<pre><code class="language-rust noplayground">// Suffix array and LCP array
// Reference: http://www.secmem.org/blog/2021/07/18/suffix-array-and-lcp/

fn suffix_array&lt;T: Ord&gt;(s: &amp;[T]) -&gt; Vec&lt;usize&gt; {
    use std::collections::*;

    if s.len() == 0 {
        return vec![];
    } else if s.len() == 1 {
        return vec![0];
    }

    let n = s.len();

    let mut r: Vec&lt;usize&gt; = vec![0; n * 2];
    let map: BTreeMap&lt;_, _&gt; = {
        let mut sorted: Vec&lt;_&gt; = s.iter().collect();
        sorted.sort_unstable();
        sorted
            .into_iter()
            .enumerate()
            .map(|x| (x.1, x.0 + 1))
            .collect()
    };
    for i in 0..n {
        r[i] = *map.get(&amp;s[i]).unwrap();
    }

    let m = n.max(map.len()) + 1;
    let mut sa: Vec&lt;usize&gt; = (0..n).collect();
    let mut nr: Vec&lt;usize&gt; = vec![0; n * 2];
    let mut cnt: Vec&lt;usize&gt; = vec![0; m];
    let mut idx: Vec&lt;usize&gt; = vec![0; n];

    for d in (0..).map(|x| 1 &lt;&lt; x).take_while(|&amp;d| d &lt; n) {
        macro_rules! key {
            ($i:expr) =&gt; {
                if $i + d &gt;= n {
                    (r[$i], 0)
                } else {
                    (r[$i], r[$i + d])
                }
            };
        }

        (0..m).for_each(|i| cnt[i] = 0);
        (0..n).for_each(|i| cnt[r[i + d]] += 1);
        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
        for i in (0..n).rev() {
            cnt[r[i + d]] -= 1;
            idx[cnt[r[i + d]]] = i;
        }

        (0..m).for_each(|i| cnt[i] = 0);
        (0..n).for_each(|i| cnt[r[i]] += 1);
        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
        for i in (0..n).rev() {
            cnt[r[idx[i]]] -= 1;
            sa[cnt[r[idx[i]]]] = idx[i];
        }

        nr[sa[0]] = 1;
        for i in 1..n {
            nr[sa[i]] = nr[sa[i - 1]] + if key!(sa[i - 1]) &lt; key!(sa[i]) { 1 } else { 0 };
        }
        std::mem::swap(&amp;mut r, &amp;mut nr);

        if r[sa[n - 1]] == n {
            break;
        }
    }

    sa
}

fn sa_lcp&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
    let n = arr.len();
    let sa = suffix_array(arr);
    let mut lcp: Vec&lt;usize&gt; = vec![0; n];
    let mut isa: Vec&lt;usize&gt; = vec![0; n];
    for i in 0..n {
        isa[sa[i]] = i;
    }
    let mut k = 0;
    for i in 0..n {
        if isa[i] != 0 {
            let j = sa[isa[i] - 1];
            while i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; arr[i + k] == arr[j + k] {
                k += 1;
            }
            lcp[isa[i]] = if k != 0 {
                k -= 1;
                k + 1
            } else {
                0
            };
        }
    }
    (sa, lcp)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convex-hull"><a class="header" href="#convex-hull">Convex Hull</a></h1>
<h2 id="graham-scan"><a class="header" href="#graham-scan">Graham Scan</a></h2>
<p>This snippet excludes every points on vertices from the convex hull, and only includes points of both ends.</p>
<h3 id="snippet"><a class="header" href="#snippet">Snippet</a></h3>
<pre><code class="language-rust noplayground">#[derive(Clone, Debug, Eq, PartialEq)]
struct Point {
    x: i64,
    y: i64,
}

impl Point {
    fn add(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
    fn sub(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
enum Turn {
    CW,
    CCW,
    Zero,
}

fn get_turn(v1: &amp;Point, v2: &amp;Point) -&gt; Turn {
    let prod = v1.x * v2.y - v1.y * v2.x;
    if prod &gt; 0 {
        Turn::CCW
    } else if prod &lt; 0 {
        Turn::CW
    } else {
        Turn::Zero
    }
}

fn compare_ccw(a: &amp;Point, b: &amp;Point) -&gt; std::cmp::Ordering {
    use std::cmp::Ordering;
    if a == b {
        return Ordering::Equal;
    }
    if a.x == 0 &amp;&amp; a.y == 0 {
        return Ordering::Less;
    } else if b.x == 0 &amp;&amp; b.y == 0 {
        return Ordering::Greater;
    }

    let turn = get_turn(a, b);
    if turn == Turn::CCW {
        return Ordering::Less;
    } else if turn == Turn::CW {
        return Ordering::Greater;
    }

    let a_dist = a.x * a.x + a.y * a.y;
    let b_dist = b.x * b.x + b.y * b.y;
    a_dist.cmp(&amp;b_dist)
}

fn convex_hull(arr: &amp;mut [Point]) -&gt; Vec&lt;Point&gt; {
    let pivot = {
        let mut pivot = Point {
            x: i64::MAX,
            y: i64::MAX,
        };
        for v in arr.iter() {
            if pivot.y &gt; v.y || (pivot.y == v.y &amp;&amp; pivot.x &gt; v.x) {
                pivot.x = v.x;
                pivot.y = v.y;
            }
        }
        pivot
    };

    for v in arr.iter_mut() {
        *v = v.sub(&amp;pivot);
    }

    arr.sort_unstable_by(compare_ccw);

    let mut stack = vec![arr[0].clone()];
    let mut i = 1;
    while i &lt; arr.len() {
        if stack.len() == 1 {
            if arr[i] != stack[0] {
                stack.push(arr[i].clone());
            }
            i += 1;
            continue;
        }

        let a = &amp;arr[i];
        let b = &amp;stack[stack.len() - 1];
        let c = &amp;stack[stack.len() - 2];
        match get_turn(&amp;b.sub(c), &amp;a.sub(b)) {
            Turn::CCW =&gt; {
                stack.push(a.clone());
                i += 1;
            }
            Turn::CW =&gt; {
                stack.pop();
            }
            _ =&gt; {
                stack.pop();
                stack.push(a.clone());
                i += 1;
            }
        }
    }

    for v in arr.iter_mut() {
        *v = v.add(&amp;pivot);
    }
    for v in stack.iter_mut() {
        *v = v.add(&amp;pivot);
    }

    stack
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-compression"><a class="header" href="#value-compression">Value Compression</a></h1>
<h2 id="w-hashmap"><a class="header" href="#w-hashmap">w/ HashMap</a></h2>
<pre><code class="language-rust noplayground">/// compressor[original_value] = compressed_value
/// reevaluator[compressed_value] = original_value
fn compress_value&lt;T: Ord + std::hash::Hash&gt;(
    arr: &amp;[T],
) -&gt; (std::collections::HashMap&lt;&amp;T, usize&gt;, Vec&lt;&amp;T&gt;) {
    use std::collections::*;
    let compressor: HashMap&lt;&amp;T, usize&gt; = {
        let mut sorted: Vec&lt;_&gt; = arr.iter().collect();
        sorted.sort_unstable();
        sorted.dedup();
        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()
    };
    let reevaluator: Vec&lt;&amp;T&gt; = compressor.iter().map(|x| *x.0).collect();
    (compressor, reevaluator)
}
</code></pre>
<h2 id="w0-hashmap"><a class="header" href="#w0-hashmap">w/0 HashMap</a></h2>
<pre><code class="language-rust noplayground">/// compressor[original_value] = compressed_value
/// reevaluator[compressed_value] = original_value
fn compress_value&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (std::collections::BTreeMap&lt;&amp;T, usize&gt;, Vec&lt;&amp;T&gt;) {
    use std::collections::*;
    let compressor: BTreeMap&lt;&amp;T, usize&gt; = {
        let mut sorted: Vec&lt;_&gt; = arr.iter().collect();
        sorted.sort_unstable();
        sorted.dedup();
        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()
    };
    let reevaluator: Vec&lt;&amp;T&gt; = compressor.iter().map(|x| *x.0).collect();
    (compressor, reevaluator)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-increasing-subsequence"><a class="header" href="#longest-increasing-subsequence">Longest Increasing Subsequence</a></h1>
<h2 id="length"><a class="header" href="#length">Length</a></h2>
<pre><code class="language-rust noplayground">fn lis_len(arr: &amp;[i64]) -&gt; usize {
    let mut table: Vec&lt;i64&gt; = vec![arr[0]];
    for &amp;v in arr[1..].iter() {
        let p = table.partition_point(|&amp;x| x &lt; v);
        if p == table.len() {
            table.push(v);
        } else {
            table[p] = v;
        }
    }
    table.len()
}
</code></pre>
<h2 id="sequence"><a class="header" href="#sequence">Sequence</a></h2>
<pre><code class="language-rust noplayground">fn lis(arr: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
    let n = arr.len();
    let mut seq: Vec&lt;i64&gt; = Vec::with_capacity(n + 1);
    seq.push(i64::MIN);
    seq.extend(arr.iter().copied());

    let mut back = vec![0usize; n + 1];
    let mut table = vec![0usize];

    for (i, &amp;v) in seq.iter().enumerate().skip(1) {
        let p = table.partition_point(|&amp;x| seq[x] &lt; v);
        if p == table.len() {
            table.push(i);
        } else {
            table[p] = i;
        }
        back[i] = table[p - 1];
    }

    let mut ptr = *table.last().unwrap();
    let mut ans: Vec&lt;i64&gt; = Vec::with_capacity(table.len() - 1);
    while ptr != 0 {
        ans.push(seq[ptr]);
        ptr = back[ptr];
    }

    ans.reverse();
    ans
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mos"><a class="header" href="#mos">Mo's</a></h1>
<h2 id="mos-with-hilbert-curve-optimization"><a class="header" href="#mos-with-hilbert-curve-optimization">Mo's with Hilbert Curve Optimization</a></h2>
<p>Reference: <a href="https://codeforces.com/blog/entry/61203">https://codeforces.com/blog/entry/61203</a></p>
<pre><code class="language-rust noplayground">/// max_n: maximum number of l and r
/// queries: Vec&lt;(id, l, r)&gt;
fn mos_sort(max_n: u32, queries: &amp;[(u32, u32, u32)]) -&gt; Vec&lt;&amp;(u32, u32, u32)&gt; {
    let n_bit = ceil_pow_2(max_n + 1).trailing_zeros();
    let mut arr: Vec&lt;(u64, &amp;(u32, u32, u32))&gt; = queries.iter().map(|q| (0, q)).collect();
    for q in arr.iter_mut() {
        q.0 = hilbert_order(q.1 .1, q.1 .2, n_bit, 0);
    }
    arr.sort_unstable_by_key(|q| q.0);
    arr.into_iter().map(|x| x.1).collect()
}

#[inline(always)]
fn hilbert_order(x: u32, y: u32, pow: u32, rotate: u32) -&gt; u64 {
    if pow == 0 {
        return 0;
    }
    let hpow: u32 = 1 &lt;&lt; (pow - 1);
    let mut seg: u32 = if x &lt; hpow {
        if y &lt; hpow {
            0
        } else {
            3
        }
    } else {
        if y &lt; hpow {
            1
        } else {
            2
        }
    };
    seg = (seg + rotate) &amp; 3;

    let (nx, ny) = (x &amp; (x ^ hpow), y &amp; (y ^ hpow));
    let nrot = rotate + ROTATE_DELTA[seg as usize] &amp; 3;
    let sub_square_size = 1u64 &lt;&lt; (2 * pow - 2);
    let ans = seg as u64 * sub_square_size;
    let add = hilbert_order(nx, ny, pow - 1, nrot);
    if seg == 1 || seg == 2 {
        ans + add
    } else {
        ans + sub_square_size - add - 1
    }
}

const ROTATE_DELTA: [u32; 4] = [3, 0, 0, 1];

#[inline(always)]
fn ceil_pow_2(y: u32) -&gt; u32 {
    let mut x = y;
    while x != (x &amp; ((!x) + 1)) {
        x -= x &amp; ((!x) + 1);
    }
    if x == y {
        x
    } else {
        x &lt;&lt; 1
    }
}
</code></pre>
<h2 id="standard-mos"><a class="header" href="#standard-mos">Standard Mo's</a></h2>
<pre><code class="language-rust noplayground">/// queries: Vec&lt;(id, l, r)&gt;
fn mos_sort(queries: &amp;mut [(u32, u32, u32)]) {
    let nsq = isqrt(queries.len() as u32);
    queries.sort_unstable_by(|&amp;(_, l1, r1), &amp;(_, l2, r2)| {
        if l1 / nsq == l2 / nsq {
            r1.cmp(&amp;r2)
        } else {
            (l1 / nsq).cmp(&amp;(l2 / nsq))
        }
    });
}

fn isqrt(s: u32) -&gt; u32 {
    let mut x0 = s / 2;
    if x0 != 0 {
        let mut x1 = (x0 + s / x0) / 2;
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) / 2;
        }
        x0
    } else {
        s
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-io"><a class="header" href="#fast-io">Fast IO</a></h1>
<h2 id="normal"><a class="header" href="#normal">Normal</a></h2>
<p><code>get_input()</code> returns every text read from the standard input, using <code>mmap</code>. Because of this, the input must be read by file redirection as <code>cargo run --release &lt; input.txt</code>. THIS FUNCTION DOESN'T WORK ON WINDOWS. THE FUNCTION MUST BE REWRITTEN MANUALLY TO BE USED FOR <u><strong>CODEFORCES</strong></u>, WHICH RUNS CODES ON WINDOWS.</p>
<p><code>Scanner</code> is a structure which can read either lines or tokens out of a string. <code>Scanner::tokenize(str)</code> tokenizes <code>str</code> by whitespaces, such as <code> </code> spaces, <code>\t</code> tabs, and <code>\n</code> newlines.</p>
<p><code>sc</code> in <code>main()</code> function is a scanner instance, which splits <code>input_str</code> by whitespaces. <code>sc.next_str()</code> returns the next token as <code>&amp;str</code>. If the input has been exhausted, the program panics. <code>sc.next::&lt;T&gt;()</code> reads the next token, parses it into a type <code>T</code>, and returns it. If the input has been exhausted or the parse fails, the program panics.</p>
<p>Both function has its &quot;Option&quot; equivalents. <code>sc.next_str_option()</code> returns the next token as <code>Some(&amp;str)</code>. This function returns <code>None</code> instead of panicing the whole program, compared to <code>sc.next_str()</code>. <code>sc.next_option()</code> works just like <code>sc.next()</code> except that it returns <code>Option&lt;T&gt;</code> so that the function returns <code>None</code> instead of panicing. These functions are useful when the code needs to detect <code>EOF</code>.</p>
<p><code>next!</code> macros are for easy-typing for inputs. <code>next!()</code> is equivalent to <code>sc.next()</code>. You can specify the return type of it by using <code>next!(T)</code>. Multiple types can also be used as arguments, delimited by spaces: <code>next!(T U V)</code> returns a tuple <code>(T, U, V)</code>. Lastly, <code>next!(str)</code> is equivalent to <code>sc.next_str()</code>.</p>
<p><code>out!</code> and <code>outln!</code> are just the same with <code>print!</code> and <code>println!</code>, but the stdout flush is buffered for faster output.</p>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<pre><code class="language-rust noplayground">// Main
let n: usize = next!();
let m = next!(usize);
let (a, b) = next!(u32 i64);
let arr: Vec&lt;u64&gt; = (0..n).map(|_| next!()).collect();

let word = next!(str);

out!(&quot;{} &quot;, a);
outln!(&quot;{}&quot;, b);
outln!(&quot;{:?}&quot;, [n, m]);
</code></pre>
<h3 id="code-11"><a class="header" href="#code-11">Code</a></h3>
<pre><code class="language-rust noplayground">fn main() {
    // FastIO
    use {fastio::*, std::io::*};
    let input_str = get_input();
    let mut sc: Scanner&lt;_&gt; = Scanner::tokenize(input_str);
    let stdout = stdout();
    let wr = &amp;mut BufWriter::new(stdout.lock());

    // FastIO Macros
    macro_rules! next {
        () =&gt; { sc.next() };
        (str) =&gt; { sc.next_str() };
        ($($t:ty) +) =&gt; { ($(sc.next::&lt;$t&gt;()),+) };
    }
    macro_rules! out { ($($arg:tt)*) =&gt; { write!(wr, $($arg)*).ok(); }; }
    macro_rules! outln { ($($arg:tt)*) =&gt; { writeln!(wr, $($arg)*).ok(); }; }

    // Main
}

mod fastio {
    extern &quot;C&quot; {
        fn mmap(addr: usize, len: usize, p: i32, f: i32, fd: i32, o: i64) -&gt; *mut u8;
        fn fstat(fd: i32, stat: *mut usize) -&gt; i32;
    }

    pub fn get_input() -&gt; &amp;'static str {
        let mut stat = [0; 20];
        unsafe { fstat(0, (&amp;mut stat).as_mut_ptr()) };
        let buffer = unsafe { mmap(0, stat[6], 1, 2, 0, 0) };
        unsafe { std::str::from_utf8_unchecked(std::slice::from_raw_parts(buffer, stat[6])) }
    }

    pub struct Scanner&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; {
        it: I,
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::SplitAsciiWhitespace&lt;'a&gt;&gt; {
        pub fn tokenize(s: &amp;'a str) -&gt; Self {
            Self {
                it: s.split_ascii_whitespace(),
            }
        }
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::Lines&lt;'a&gt;&gt; {
        pub fn lines(s: &amp;'a str) -&gt; Self {
            Self { it: s.lines() }
        }
    }

    impl&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; Scanner&lt;'a, I&gt; {
        #[inline(always)]
        pub fn next&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; T {
            self.it.next().unwrap().parse().ok().unwrap()
        }
        #[inline(always)]
        pub fn next_str(&amp;mut self) -&gt; &amp;'a str {
            self.it.next().unwrap()
        }
        #[inline(always)]
        pub fn next_option&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.it.next().and_then(|s| s.parse().ok())
        }
        #[inline(always)]
        pub fn next_str_option(&amp;mut self) -&gt; Option&lt;&amp;'a str&gt; {
            self.it.next()
        }
    }
}
</code></pre>
<h3 id="template-for-windowscodeforces"><a class="header" href="#template-for-windowscodeforces">Template for Windows(Codeforces)</a></h3>
<pre><code class="language-rust noplayground">fn main() {
    // FastIO
    use {fastio::*, std::io::*};
    let input_str = get_input();
    let mut sc: Scanner&lt;_&gt; = Scanner::tokenize(&amp;input_str);
    let stdout = stdout();
    let wr = &amp;mut BufWriter::new(stdout.lock());

    // FastIO Macros
    macro_rules! next {
        () =&gt; { sc.next() };
        (str) =&gt; { sc.next_str() };
        ($($t:ty) +) =&gt; { ($(sc.next::&lt;$t&gt;()),+) };
    }
    macro_rules! out { ($($arg:tt)*) =&gt; { write!(wr, $($arg)*).ok(); }; }
    macro_rules! outln { ($($arg:tt)*) =&gt; { writeln!(wr, $($arg)*).ok(); }; }

    // Main
}

mod fastio {
    use std::io::{stdin, Read};

    pub fn get_input() -&gt; String {
        let mut buf = String::new();
        stdin().read_to_string(&amp;mut buf).unwrap();
        buf
    }

    pub struct Scanner&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; {
        it: I,
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::SplitAsciiWhitespace&lt;'a&gt;&gt; {
        pub fn tokenize(s: &amp;'a str) -&gt; Self {
            Self {
                it: s.split_ascii_whitespace(),
            }
        }
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::Lines&lt;'a&gt;&gt; {
        pub fn lines(s: &amp;'a str) -&gt; Self {
            Self { it: s.lines() }
        }
    }

    impl&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; Scanner&lt;'a, I&gt; {
        #[inline(always)]
        pub fn next&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; T {
            self.it.next().unwrap().parse().ok().unwrap()
        }
        #[inline(always)]
        pub fn next_str(&amp;mut self) -&gt; &amp;'a str {
            self.it.next().unwrap()
        }
        #[inline(always)]
        pub fn next_option&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.it.next().and_then(|s| s.parse().ok())
        }
        #[inline(always)]
        pub fn next_str_option(&amp;mut self) -&gt; Option&lt;&amp;'a str&gt; {
            self.it.next()
        }
    }
}
</code></pre>
<h2 id="with-faster-print"><a class="header" href="#with-faster-print">With faster print</a></h2>
<pre><code class="language-rust noplayground">fn main() {
    // FastIO
    use fastio::*;
    let input_str = get_input();
    let mut sc: Scanner&lt;_&gt; = Scanner::tokenize(input_str);
    let mut out = Flusher::with_capacity(1 &lt;&lt; 18);

    // FastIO Macros
    macro_rules! next {
        () =&gt; { sc.next() };
        (str) =&gt; { sc.next_str() };
        ($($t:ty) +) =&gt; { ($(sc.next::&lt;$t&gt;()),+) };
    }
    macro_rules! out { ($($arg:tt),*) =&gt; {$( $arg.push_num(&amp;mut out); out.buf.push(b' '); )*}; }
    macro_rules! outln { ($($arg:tt),*) =&gt; { out!($($arg),*); out.buf.push(b'\n'); } }

    // Main
    let n: usize = next!();
    outln!(n);
}

mod fastio {
    use std::io::{stdout, Write};

    extern &quot;C&quot; {
        fn mmap(addr: usize, len: usize, p: i32, f: i32, fd: i32, o: i64) -&gt; *mut u8;
        fn fstat(fd: i32, stat: *mut usize) -&gt; i32;
    }

    pub fn get_input() -&gt; &amp;'static str {
        let mut stat = [0; 20];
        unsafe { fstat(0, (&amp;mut stat).as_mut_ptr()) };
        let buffer = unsafe { mmap(0, stat[6], 1, 2, 0, 0) };
        unsafe { std::str::from_utf8_unchecked(std::slice::from_raw_parts(buffer, stat[6])) }
    }

    pub struct Scanner&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; {
        it: I,
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::SplitAsciiWhitespace&lt;'a&gt;&gt; {
        pub fn tokenize(s: &amp;'a str) -&gt; Self {
            Self {
                it: s.split_ascii_whitespace(),
            }
        }
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::Lines&lt;'a&gt;&gt; {
        pub fn lines(s: &amp;'a str) -&gt; Self {
            Self { it: s.lines() }
        }
    }

    impl&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; Scanner&lt;'a, I&gt; {
        #[inline(always)]
        pub fn next&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; T {
            self.it.next().unwrap().parse().ok().unwrap()
        }
        #[inline(always)]
        pub fn next_str(&amp;mut self) -&gt; &amp;'a str {
            self.it.next().unwrap()
        }
        #[inline(always)]
        pub fn next_option&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.it.next().and_then(|s| s.parse().ok())
        }
        #[inline(always)]
        pub fn next_str_option(&amp;mut self) -&gt; Option&lt;&amp;'a str&gt; {
            self.it.next()
        }
    }

    pub struct Flusher {
        pub buf: Vec&lt;u8&gt;,
    }

    impl Flusher {
        pub fn with_capacity(cap: usize) -&gt; Self {
            Self {
                buf: Vec::with_capacity(cap),
            }
        }
    }

    impl Drop for Flusher {
        fn drop(&amp;mut self) {
            stdout().write_all(&amp;self.buf).ok();
        }
    }

    pub trait PushPrint {
        fn push_num(self, wr: &amp;mut Flusher);
    }

    impl PushPrint for &amp;str {
        fn push_num(self, wr: &amp;mut Flusher) {
            wr.buf.extend_from_slice(self.as_bytes());
        }
    }

    macro_rules! impl_pushprint {
        ($($i:ty;$u:ty) *) =&gt; {
            $(
                impl PushPrint for $i {
                    fn push_num(self, wr: &amp;mut Flusher) {
                        if self &lt; 0 {
                            wr.buf.push(b'-');
                            ((-self) as $u).push_num(wr);
                        } else {
                            (self as $u).push_num(wr);
                        }
                    }
                }

                impl PushPrint for $u {
                    fn push_num(self, wr: &amp;mut Flusher) {
                        if self &gt;= 10 {
                            (self / 10).push_num(wr);
                        }
                        wr.buf.push((self % 10) as u8 + b'0');
                    }
                }
            )*
        };
    }

    impl_pushprint!(i8;u8 i16;u16 i32;u32 i64;u64 i128;u128 isize;usize);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<pre><code class="language-rust noplayground">macro_rules! count_tts {
    () =&gt; { 0 };
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 };
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 };
}

// let map: HashMap&lt;i64, i64&gt; = hashmap![1,1; 2,2; 3,3];
macro_rules! hashmap {
    ($($k:expr,$v:expr);*) =&gt; {{
        let mut map = HashMap::with_capacity(count_tts![$($k )*]);
        $( map.insert($k, $v); )*
        map
    }}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zeroone-trait-deprecated"><a class="header" href="#zeroone-trait-deprecated">Zero/One Trait (Deprecated)</a></h1>
<p>This trait was used for representing numeric values, but the author has learned that <code>Into</code> and <code>From</code> traits exist, hence this trait is now deprecated. Any other templates which includes or requires to include this trait will be fixed soon.</p>
<pre><code class="language-rust noplayground">pub trait ZeroOne: Sized + Copy {
    fn zero() -&gt; Self;
    fn one() -&gt; Self;
}

macro_rules! impl_zero_one {
    ($($ty:ty) *) =&gt; { $(
        impl ZeroOne for $ty {
            #[inline(always)]
            fn one() -&gt; Self {1}
            #[inline(always)]
            fn zero() -&gt; Self {0}
        }
    )+ };
}

impl_zero_one!(isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
