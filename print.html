<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js nord_light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Snippets for Competitive Programming</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "nord_dark" : "nord_light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('nord_light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Math</li><li class="chapter-item expanded "><a href="math/sieve.html"><strong aria-hidden="true">1.</strong> Sieve</a></li><li class="chapter-item expanded "><a href="math/gcd.html"><strong aria-hidden="true">2.</strong> GCD, LCM</a></li><li class="chapter-item expanded "><a href="math/extgcd.html"><strong aria-hidden="true">3.</strong> Extended Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="math/crt.html"><strong aria-hidden="true">4.</strong> Chinese Remainder Theorem</a></li><li class="chapter-item expanded "><a href="math/millerrabin.html"><strong aria-hidden="true">5.</strong> Deterministic Miller-Rabin Primality Test</a></li><li class="chapter-item expanded "><a href="math/pollardrho.html"><strong aria-hidden="true">6.</strong> Pollard's Rho Algorithm</a></li><li class="chapter-item expanded "><a href="math/ntt.html"><strong aria-hidden="true">7.</strong> Number Theoretic Transform</a></li><li class="chapter-item expanded "><a href="math/linrec/intro.html"><strong aria-hidden="true">8.</strong> Linear Recurrence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="math/linrec/berlekamp.html"><strong aria-hidden="true">8.1.</strong> Berlekamp-Massey</a></li><li class="chapter-item expanded "><a href="math/linrec/kitamasa.html"><strong aria-hidden="true">8.2.</strong> Kitamasa</a></li><li class="chapter-item expanded "><a href="math/linrec/bostanmori.html"><strong aria-hidden="true">8.3.</strong> Bostan-Mori</a></li></ol></li><li class="chapter-item expanded "><a href="math/isqrt.html"><strong aria-hidden="true">9.</strong> Integer Square Root</a></li><li class="chapter-item expanded affix "><li class="part-title">Data Structures</li><li class="chapter-item expanded "><a href="datastructure/dsu.html"><strong aria-hidden="true">10.</strong> Disjoint Set Union</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datastructure/wdsu.html"><strong aria-hidden="true">10.1.</strong> Weighted DSU</a></li></ol></li><li class="chapter-item expanded "><a href="datastructure/segtree/intro.html"><strong aria-hidden="true">11.</strong> Segment Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datastructure/segtree/segtree.html"><strong aria-hidden="true">11.1.</strong> Segment Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/fenwick.html"><strong aria-hidden="true">11.2.</strong> Fenwick Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/lazyseg.html"><strong aria-hidden="true">11.3.</strong> Lazy Segment Tree</a></li></ol></li><li class="chapter-item expanded "><a href="datastructure/rope.html"><strong aria-hidden="true">12.</strong> Rope</a></li><li class="chapter-item expanded "><a href="datastructure/bitarray.html"><strong aria-hidden="true">13.</strong> Bitset</a></li><li class="chapter-item expanded affix "><li class="part-title">Graphs</li><li class="chapter-item expanded "><a href="graphs/dijkstra.html"><strong aria-hidden="true">14.</strong> Dijkstra</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphs/dial.html"><strong aria-hidden="true">14.1.</strong> Dial</a></li></ol></li><li class="chapter-item expanded "><a href="graphs/scc.html"><strong aria-hidden="true">15.</strong> Strongly Connected Components</a></li><li class="chapter-item expanded "><a href="graphs/2sat.html"><strong aria-hidden="true">16.</strong> 2-SAT</a></li><li class="chapter-item expanded "><a href="graphs/flow/intro.html"><strong aria-hidden="true">17.</strong> Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphs/flow/dinic.html"><strong aria-hidden="true">17.1.</strong> Dinic's Algorithm</a></li><li class="chapter-item expanded "><a href="graphs/flow/mcmf.html"><strong aria-hidden="true">17.2.</strong> MCMF</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Strings</li><li class="chapter-item expanded "><a href="strings/kmp.html"><strong aria-hidden="true">18.</strong> KMP</a></li><li class="chapter-item expanded "><a href="strings/manacher.html"><strong aria-hidden="true">19.</strong> Manacher</a></li><li class="chapter-item expanded "><a href="strings/salcp.html"><strong aria-hidden="true">20.</strong> Suffix Array and LCP Array</a></li><li class="chapter-item expanded affix "><li class="part-title">Geometry</li><li class="chapter-item expanded "><a href="geometry/convexhull.html"><strong aria-hidden="true">21.</strong> Convex Hull</a></li><li class="chapter-item expanded "><a href="geometry/line_intersection.html"><strong aria-hidden="true">22.</strong> Line Intersection</a></li><li class="chapter-item expanded "><a href="geometry/inside_polygon.html"><strong aria-hidden="true">23.</strong> Point in a Polygon</a></li><li class="chapter-item expanded affix "><li class="part-title">Unclassified</li><li class="chapter-item expanded "><a href="unclass/valcomp.html"><strong aria-hidden="true">24.</strong> Value Compression</a></li><li class="chapter-item expanded "><a href="unclass/lis.html"><strong aria-hidden="true">25.</strong> Longest Increasing Subsequence</a></li><li class="chapter-item expanded "><a href="unclass/mos.html"><strong aria-hidden="true">26.</strong> Mo's</a></li><li class="chapter-item expanded "><a href="unclass/bigint.html"><strong aria-hidden="true">27.</strong> Arbitrary-Precision Integer</a></li><li class="chapter-item expanded "><a href="unclass/fraction.html"><strong aria-hidden="true">28.</strong> Fraction</a></li><li class="chapter-item expanded affix "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="misc/fastio.html"><strong aria-hidden="true">29.</strong> Fast IO</a></li><li class="chapter-item expanded "><a href="misc/itertools.html"><strong aria-hidden="true">30.</strong> Iterator Tools</a></li><li class="chapter-item expanded "><a href="misc/macro.html"><strong aria-hidden="true">31.</strong> Macros</a></li><li class="chapter-item expanded affix "><li class="part-title">Deprecated</li><li class="chapter-item expanded "><a href="zdeprecated/adjlist.html"><strong aria-hidden="true">32.</strong> Adjacency List Graph Representation</a></li><li class="chapter-item expanded "><a href="zdeprecated/zero_one_trait.html"><strong aria-hidden="true">33.</strong> Zero/One Trait</a></li><li class="chapter-item expanded "><a href="zdeprecated/deprecated_macros.html"><strong aria-hidden="true">34.</strong> Deprecated Macros</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="nord_light">Nord Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="nord_dark">Nord Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Snippets for Competitive Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BamgoeSN/rust-ps-md" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is a collection of snippets for competitive programming and problem solving with Rust. All you have to do for using snippets is simply copying snippets you need and pasting them into your code.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Each snippet can be easily copied by clicking on the copy icon <i class="fa fa-copy"></i> at the top right corner of a code block.</p>
<p>Clicking on the search icon <i class="fa fa-search"></i> in the menu bar, or pressing the <code>S</code> key on the keyboard will open an input box for entering search terms. Any keywords included in this book can be searched by typing it in the box.</p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other Resources</a></h2>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<ul>
<li><a href="https://blog.shahjalalshohag.com/topic-list/">The Ultimate Topic List by Shahjalal Shohag</a></li>
</ul>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<ul>
<li><a href="https://github.com/EbTech/rust-algorithms">Contest Algorithms in Rust by EbTech</a></li>
<li><a href="https://snippets.kiwiyou.dev/">kiwiyou's Snippets Collection</a></li>
<li><a href="https://jh05013.github.io/ps-snippets/">jh05013's Snippets Collection</a></li>
</ul>
<h3 id="c"><a class="header" href="#c">C++</a></h3>
<ul>
<li><a href="https://github.com/Aeren1564/Algorithms">aeren1564 Bible</a></li>
<li>AtCoder Library: <a href="https://atcoder.github.io/ac-library/production/document_en/">Doc</a>, <a href="https://github.com/atcoder/ac-library">GitHub</a></li>
<li><a href="https://github.com/koosaga/olympiad/tree/master/Library">koosaga's Library</a></li>
<li><a href="https://github.com/justiceHui/icpc-teamnote">justiceHui's Teamnote</a></li>
</ul>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<ul>
<li><a href="https://github.com/cheran-senthil/PyRival">PyRival</a></li>
</ul>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p><strong>None of the codes from this document should be used in any other fields besides competitive programming!</strong> Every code here is strictly designed for CP, and none of these codes are for actual production codes.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Unless stated otherwise, or there is another license included in the code, every snippets here is under Unlicense.</p>
<blockquote>
<p>This is free and unencumbered software released into the public domain.</p>
<p>Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.</p>
<p>In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.</p>
<p>For more information, please refer to <a href="http://unlicense.org/">http://unlicense.org/</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sieve"><a class="header" href="#sieve">Sieve</a></h1>
<p>Sieve algorithms find all prime numbers below a specified integer. Additionally, they efficiently compute values of multiplicative functions for all integers up to that specified limit.</p>
<h2 id="finding-primes"><a class="header" href="#finding-primes">Finding primes</a></h2>
<p><code>sieve</code> returns a vector containing all prime numbers that are less than or equal to <code>max_val</code>.</p>
<p>This function runs with a time complexity of \(O(N)\) where \(N\) is the value of <code>max_val</code>. This efficiency is achieved with linear sieve.
This function is further optimized by excluding multiples of \(2\) and \(3\) in advance.</p>
<pre><code class="language-rust noplayground">fn sieve(max_val: usize) -&gt; Vec&lt;usize&gt; {
	let mut primes = vec![2, 3];
	let mut is_prime = vec![true; max_val / 3 + 1];

	for i in 0..is_prime.len() {
		let j = 6 * (i &gt;&gt; 1) + 5 + ((i &amp; 1) &lt;&lt; 1);
		if is_prime[i] {
			primes.push(j);
		}
		for &amp;p in primes[2..].iter() {
			let v = j * p;
			if v &gt; max_val {
				break;
			}
			is_prime[v / 3 - 1] = false;
			if j % p == 0 {
				break;
			}
		}
	}

	primes
}</code></pre>
<h2 id="with-euler-phi-function"><a class="header" href="#with-euler-phi-function">With Euler Phi Function</a></h2>
<pre><code class="language-rust noplayground">fn phi_sieve(max_val: usize) -&gt; (Vec&lt;bool&gt;, Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
    let mut primes = vec![];
    let mut is_prime = vec![true; max_val + 1];
    is_prime[0] = false;
    is_prime[1] = false;
    let mut phi = vec![0; max_val + 1];

    for i in 2..=max_val {
        if is_prime[i] {
            primes.push(i);
            phi[i] = i - 1;
        }
        for &amp;p in primes.iter() {
            let v = i * p;
            if v &gt; max_val {
                break;
            }
            is_prime[v] = false;
            if i % p == 0 {
                phi[v] = phi[i] * p;
                break;
            } else {
                phi[v] = phi[i] * phi[p]
            }
        }
    }

    (is_prime, phi, primes)
}</code></pre>
<h2 id="with-möbius-function"><a class="header" href="#with-möbius-function">With Möbius Function</a></h2>
<pre><code class="language-rust noplayground">fn mobius_sieve(max_val: usize) -&gt; (Vec&lt;i8&gt;, Vec&lt;usize&gt;) {
    let mut primes = vec![];
    let mut mu = vec![2i8; max_val + 1];
    (mu[0], mu[1]) = (0, 1);

    for i in 2..=max_val {
        if mu[i] == 2 {
            primes.push(i);
            mu[i] = -1;
        }
        for &amp;p in primes.iter() {
            let v = i * p;
            if v &gt; max_val {
                break;
            }
            if i % p == 0 {
                mu[v] = 0;
                break;
            } else {
                mu[v] = -mu[i];
            }
        }
    }

    (mu, primes)
}</code></pre>
<hr />
<p>Last modified on 231203.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcd-lcm"><a class="header" href="#gcd-lcm">GCD, LCM</a></h1>
<p><code>gcd(x, y)</code> returns the greatest common divisor (GCD) of <code>x</code> and <code>y</code>. <br />
<code>lcm(x, y)</code> returns the least common multiple (LCM) of <code>x</code> and <code>y</code>.</p>
<p><code>gcd</code> is implemented using Euclidean algorithm, whose time complexity is \(O( \log _{\phi} x )\) where \(\phi\) is a golden ratio.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let (x, y) = (10, 25);

let g = gcd(x, y);
println!(&quot;{}&quot;, g); // 5

let l = lcm(x, y);
println!(&quot;{}&quot;, l); // 50
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gcd(x: u64, y: u64) -&gt; u64 {
</span><span class="boring">   if y == 0 {
</span><span class="boring">       x
</span><span class="boring">   } else {
</span><span class="boring">       gcd(y, x % y)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn lcm(x: u64, y: u64) -&gt; u64 {
</span><span class="boring">   x / gcd(x, y) * y
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-rust noplayground">fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
where T: Copy + PartialEq + PartialOrd + Rem&lt;Output = T&gt; + From&lt;u8&gt; {
	if y == 0.into() {
		x
	} else {
		let v = x % y;
		gcd(y, v)
	}
}

fn lcm&lt;T&gt;(x: T, y: T) -&gt; T
where T: Copy + PartialEq + PartialOrd + Rem&lt;Output = T&gt; + Div&lt;Output = T&gt; + Mul&lt;Output = T&gt; + From&lt;u8&gt; {
	x / gcd(x, y) * y
}</code></pre>
<hr />
<p>Last modified on 231203.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extended-euclidean-algorithm"><a class="header" href="#extended-euclidean-algorithm">Extended Euclidean Algorithm</a></h1>
<p><code>egcd(a, b)</code> returns \(g, s, t\) such that \(g = \gcd(a, b)\) and \(as+bt=g\).</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>for (a, b) in [(2, 5), (11, 17), (20, 35)] {
    let (g, s, t) = egcd(a, b);
    println!(&quot;gcd({a}, {b}) = {g}&quot;);
    println!(&quot;{a}*({s}) + {b}*({t}) = {g}&quot;);
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns `(g, s, t)` such that `g == gcd(a, b)` and `a*s + t*b == g`.
</span><span class="boring">fn egcd(mut a: i64, mut b: i64) -&gt; (i64, i64, i64) {
</span><span class="boring">    let (mut sa, mut ta, mut sb, mut tb) = (1, 0, 0, 1);
</span><span class="boring">    while b != 0 {
</span><span class="boring">        let (q, r) = (a / b, a % b);
</span><span class="boring">        (sa, ta, sb, tb) = (sb, tb, sa - q * sb, ta - q * tb);
</span><span class="boring">        (a, b) = (b, r);
</span><span class="boring">    }
</span><span class="boring">    (a, sa, ta)
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<pre><code class="language-rust noplayground">/// Returns `(g, s, t)` such that `g == gcd(a, b)` and `a*s + t*b == g`.
fn egcd(mut a: i64, mut b: i64) -&gt; (i64, i64, i64) {
    let (mut sa, mut ta, mut sb, mut tb) = (1, 0, 0, 1);
    while b != 0 {
        let (q, r) = (a / b, a % b);
        (sa, ta, sb, tb) = (sb, tb, sa - q * sb, ta - q * tb);
        (a, b) = (b, r);
    }
    (a, sa, ta)
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chinese-remainder-theorem"><a class="header" href="#chinese-remainder-theorem">Chinese Remainder Theorem</a></h1>
<p><code>crt(r, m)</code> returns <code>Some(x)</code> such that \(x \equiv r_i \pmod {m_i}\) for all \(i\). If such \(x\) does not exist, then it returns <code>None</code>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let r = vec![1, 2, 3];
let m = vec![3, 5, 7];
let x = crt(&amp;r, &amp;m);
println!(&quot;{:?}&quot;, x); // Some(52)

let r = vec![2, 5];
let m = vec![10, 25];
let x = crt(&amp;r, &amp;m);
println!(&quot;{:?}&quot;, x); // None
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gcd(x: i64, y: i64) -&gt; i64 {
</span><span class="boring">    if y == 0 {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        gcd(y, x % y)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns `(g, s, t)` such that `g == gcd(a, b)` and `a*s + t*b == g`.
</span><span class="boring">fn egcd(mut a: i64, mut b: i64) -&gt; (i64, i64, i64) {
</span><span class="boring">    let (mut sa, mut ta, mut sb, mut tb) = (1, 0, 0, 1);
</span><span class="boring">    while b != 0 {
</span><span class="boring">        let (q, r) = (a / b, a % b);
</span><span class="boring">        (sa, ta, sb, tb) = (sb, tb, sa - q * sb, ta - q * tb);
</span><span class="boring">        (a, b) = (b, r);
</span><span class="boring">    }
</span><span class="boring">    (a, sa, ta)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns x s.t. x=a_i (mod m_i) for all i.
</span><span class="boring">/// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py
</span><span class="boring">fn crt(a: &amp;[i64], m: &amp;[i64]) -&gt; Option&lt;i64&gt; {
</span><span class="boring">    use std::iter::zip;
</span><span class="boring">    let (mut x, mut m_prod) = (0, 1);
</span><span class="boring">    for (&amp;ai, &amp;mi) in zip(a, m) {
</span><span class="boring">        let (g, s, _) = egcd(m_prod, mi);
</span><span class="boring">        if (ai - x).rem_euclid(g) != 0 {
</span><span class="boring">            return None;
</span><span class="boring">        }
</span><span class="boring">        x += m_prod * ((s * ((ai - x).rem_euclid(mi))).div_euclid(g));
</span><span class="boring">        m_prod = (m_prod * mi).div_euclid(gcd(m_prod, mi));
</span><span class="boring">    }
</span><span class="boring">    Some(x.rem_euclid(m_prod))
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-2"><a class="header" href="#code-2">Code</a></h2>
<pre><code class="language-rust noplayground">fn gcd(x: i64, y: i64) -&gt; i64 {
    if y == 0 {
        x
    } else {
        gcd(y, x % y)
    }
}

/// Returns `(g, s, t)` such that `g == gcd(a, b)` and `a*s + t*b == g`.
fn egcd(mut a: i64, mut b: i64) -&gt; (i64, i64, i64) {
    let (mut sa, mut ta, mut sb, mut tb) = (1, 0, 0, 1);
    while b != 0 {
        let (q, r) = (a / b, a % b);
        (sa, ta, sb, tb) = (sb, tb, sa - q * sb, ta - q * tb);
        (a, b) = (b, r);
    }
    (a, sa, ta)
}

/// Returns x s.t. x=a_i (mod m_i) for all i.
/// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py
fn crt(a: &amp;[i64], m: &amp;[i64]) -&gt; Option&lt;i64&gt; {
    use std::iter::zip;
    let (mut x, mut m_prod) = (0, 1);
    for (&amp;ai, &amp;mi) in zip(a, m) {
        let (g, s, _) = egcd(m_prod, mi);
        if (ai - x).rem_euclid(g) != 0 {
            return None;
        }
        x += m_prod * ((s * ((ai - x).rem_euclid(mi))).div_euclid(g));
        m_prod = (m_prod * mi).div_euclid(gcd(m_prod, mi));
    }
    Some(x.rem_euclid(m_prod))
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deterministic-miller-rabin-primality-test"><a class="header" href="#deterministic-miller-rabin-primality-test">Deterministic Miller-Rabin Primality Test</a></h1>
<p>Deterministic Miller-Rabin primality test determines whether a certain unsigned integer is a prime in a time complexity of \(O(\log{n})\). This test only works for integers under \(2^{64}\).</p>
<p><code>x.is_prime()</code> chooses a roughly faster algorithm among naive primality test and Miller-Rabin test, and returns <code>true</code> if <code>x</code> is a prime, <code>false</code> if not.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use millerrabin::*;

<span class="boring">fn main() {
</span>println!(&quot;{}&quot;, 407521u64.is_prime()); // true
println!(&quot;{}&quot;, 3284729387909u64.is_prime()); // true
println!(&quot;{}&quot;, 3284729387911u64.is_prime()); // false 53×61976026187
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod millerrabin {
</span><span class="boring">    pub trait Primality {
</span><span class="boring">        fn is_prime(self) -&gt; bool;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    macro_rules! impl_primality {
</span><span class="boring">        ($t:ty, $u:ty, $thres:expr, $bcnt:expr, $($basis:expr),+) =&gt; {
</span><span class="boring">            impl Primality for $t {
</span><span class="boring">                fn is_prime(self) -&gt; bool {
</span><span class="boring">                    if self &lt;= 1 {
</span><span class="boring">                        return false;
</span><span class="boring">                    } else if self &amp; 1 == 0 {
</span><span class="boring">                        return self == 2;
</span><span class="boring">                    }
</span><span class="boring">
</span><span class="boring">                    const THRES: $t = $thres;
</span><span class="boring">                    const TEST: [$t; $bcnt] = [$($basis,)+];
</span><span class="boring">
</span><span class="boring">                    if self &lt;= THRES {
</span><span class="boring">                        for p in (2..).take_while(|&amp;p| p * p &lt;= self) {
</span><span class="boring">                            if self % p == 0 {
</span><span class="boring">                                return false;
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">                        return true;
</span><span class="boring">                    }
</span><span class="boring">
</span><span class="boring">                    let pow = |base: $t, mut exp: $t| -&gt; $t {
</span><span class="boring">                        let mut base = base as $u;
</span><span class="boring">                        let mut ret = 1 as $u;
</span><span class="boring">                        while exp != 0 {
</span><span class="boring">                            if exp &amp; 1 != 0 {
</span><span class="boring">                                ret = (ret * base) % self as $u;
</span><span class="boring">                            }
</span><span class="boring">                            exp &gt;&gt;= 1;
</span><span class="boring">                            base = (base * base) % self as $u;
</span><span class="boring">                        }
</span><span class="boring">                        ret as $t
</span><span class="boring">                    };
</span><span class="boring">
</span><span class="boring">                    let s = (self - 1).trailing_zeros();
</span><span class="boring">                    let d = (self - 1) &gt;&gt; s;
</span><span class="boring">
</span><span class="boring">                    for &amp;a in TEST.iter().take_while(|&amp;&amp;a| a &lt; self - 1) {
</span><span class="boring">                        let mut x = pow(a, d);
</span><span class="boring">                        for _ in 0..s {
</span><span class="boring">                            let y = ((x as $u).pow(2) % self as $u) as $t;
</span><span class="boring">                            if y == 1 &amp;&amp; x != 1 &amp;&amp; x != self - 1 {
</span><span class="boring">                                return false;
</span><span class="boring">                            }
</span><span class="boring">                            x = y;
</span><span class="boring">                        }
</span><span class="boring">                        if x != 1 {
</span><span class="boring">                            return false;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">
</span><span class="boring">                    true
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl_primality!(u8, u16, 255, 1, 2);
</span><span class="boring">    impl_primality!(u16, u32, 2000, 2, 2, 3);
</span><span class="boring">    impl_primality!(u32, u64, 7000, 3, 2, 7, 61);
</span><span class="boring">    impl_primality!(u64, u128, 300000, 7, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-3"><a class="header" href="#code-3">Code</a></h2>
<pre><code class="language-rust noplayground">mod millerrabin {
    pub trait Primality {
        fn is_prime(self) -&gt; bool;
    }

    macro_rules! impl_primality {
        ($t:ty, $u:ty, $thres:expr, $bcnt:expr, $($basis:expr),+) =&gt; {
            impl Primality for $t {
                fn is_prime(self) -&gt; bool {
                    if self &lt;= 1 {
                        return false;
                    } else if self &amp; 1 == 0 {
                        return self == 2;
                    }

                    const THRES: $t = $thres;
                    const TEST: [$t; $bcnt] = [$($basis,)+];

                    if self &lt;= THRES {
                        for p in (2..).take_while(|&amp;p| p * p &lt;= self) {
                            if self % p == 0 {
                                return false;
                            }
                        }
                        return true;
                    }

                    let pow = |base: $t, mut exp: $t| -&gt; $t {
                        let mut base = base as $u;
                        let mut ret = 1 as $u;
                        while exp != 0 {
                            if exp &amp; 1 != 0 {
                                ret = (ret * base) % self as $u;
                            }
                            exp &gt;&gt;= 1;
                            base = (base * base) % self as $u;
                        }
                        ret as $t
                    };

                    let s = (self - 1).trailing_zeros();
                    let d = (self - 1) &gt;&gt; s;

                    for &amp;a in TEST.iter().take_while(|&amp;&amp;a| a &lt; self - 1) {
                        let mut x = pow(a, d);
                        for _ in 0..s {
                            let y = ((x as $u).pow(2) % self as $u) as $t;
                            if y == 1 &amp;&amp; x != 1 &amp;&amp; x != self - 1 {
                                return false;
                            }
                            x = y;
                        }
                        if x != 1 {
                            return false;
                        }
                    }

                    true
                }
            }
        };
    }

    impl_primality!(u8, u16, 255, 1, 2);
    impl_primality!(u16, u32, 2000, 2, 2, 3);
    impl_primality!(u32, u64, 7000, 3, 2, 7, 61);
    impl_primality!(u64, u128, 300000, 7, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pollards-rho-algorithm"><a class="header" href="#pollards-rho-algorithm">Pollard's Rho Algorithm</a></h1>
<p>Pollard rho algorithm is a randomized algorithm which factorizes a number in an average time complexity of \(O(n^{1/4})\).</p>
<p><code>x.factorize()</code> factorizes <code>x</code> and returns a vector with the factors. The order of factors in the vector is undefined.</p>
<p><a href="math/./millerrabin.html">Miller-Rabin primality test</a> should be with this snippet in the code.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use factorization::*;

<span class="boring">fn main() {
</span>let mut rng = RNG::new(15163487);
let a: u64 = 484387724796727379;
let mut factors = a.factorize(&amp;mut rng);
factors.sort_unstable();
println!(&quot;{:?}&quot;, factors); // [165551, 2925912406429]
println!(&quot;{}&quot;, factors.iter().product::&lt;u64&gt;()); // 484387724796727379
use millerrabin::Primality;
println!(&quot;{}&quot;, factors.iter().all(|&amp;x| x.is_prime()));
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod factorization {
</span><span class="boring">    use super::millerrabin::Primality;
</span><span class="boring">    use std::ops::*;
</span><span class="boring">
</span><span class="boring">    pub trait PollardRho: Primality + From&lt;u8&gt; + PartialOrd + ShrAssign + BitAnd&lt;Output = Self&gt; + Clone {
</span><span class="boring">        fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG);
</span><span class="boring">        fn factorize(mut self, rng: &amp;mut rng::RNG) -&gt; Vec&lt;Self&gt; {
</span><span class="boring">            let mut arr: Vec&lt;Self&gt; = Vec::new();
</span><span class="boring">            if self &lt;= 1.into() {
</span><span class="boring">                return arr;
</span><span class="boring">            }
</span><span class="boring">            while self.clone() &amp; 1.into() == 0.into() {
</span><span class="boring">                self &gt;&gt;= 1.into();
</span><span class="boring">                arr.push(2.into());
</span><span class="boring">            }
</span><span class="boring">            self.rho(&amp;mut arr, rng);
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    macro_rules! impl_pollardrho {
</span><span class="boring">        ($t:ty, $u:ty, $reset:expr) =&gt; {
</span><span class="boring">            impl PollardRho for $t {
</span><span class="boring">                fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG) {
</span><span class="boring">                    if self &lt;= 1 {
</span><span class="boring">                        return;
</span><span class="boring">                    } else if self.is_prime() {
</span><span class="boring">                        arr.push(self);
</span><span class="boring">                        return;
</span><span class="boring">                    }
</span><span class="boring">
</span><span class="boring">                    let mut i: u64 = 0;
</span><span class="boring">                    let mut x: $t = (rng.next_u64() % self as u64) as $t;
</span><span class="boring">                    let mut y: $t = x;
</span><span class="boring">                    let mut k: u64 = 2;
</span><span class="boring">                    let mut d: $t;
</span><span class="boring">                    let mut reset_limit: u64 = $reset;
</span><span class="boring">
</span><span class="boring">                    loop {
</span><span class="boring">                        i += 1;
</span><span class="boring">                        x = (((x as $u * x as $u % self as $u) + (self - 1) as $u) % self as $u) as $t;
</span><span class="boring">                        d = gcd(y.abs_diff(x), self);
</span><span class="boring">                        if d == self || i &gt;= reset_limit {
</span><span class="boring">                            // Reset
</span><span class="boring">                            reset_limit = reset_limit * 3 / 2;
</span><span class="boring">                            i = 0;
</span><span class="boring">                            x = (rng.next_u64() % self as u64) as $t;
</span><span class="boring">                            y = x;
</span><span class="boring">                        }
</span><span class="boring">                        if d != 1 {
</span><span class="boring">                            break;
</span><span class="boring">                        }
</span><span class="boring">                        if i == k {
</span><span class="boring">                            y = x;
</span><span class="boring">                            k &lt;&lt;= 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">
</span><span class="boring">                    if d != self {
</span><span class="boring">                        d.rho(arr, rng);
</span><span class="boring">                        (self / d).rho(arr, rng);
</span><span class="boring">                        return;
</span><span class="boring">                    }
</span><span class="boring">
</span><span class="boring">                    let mut i = 3;
</span><span class="boring">                    while i * i &lt;= self {
</span><span class="boring">                        if self % i == 0 {
</span><span class="boring">                            i.rho(arr, rng);
</span><span class="boring">                            (d / i).rho(arr, rng);
</span><span class="boring">                            return;
</span><span class="boring">                        }
</span><span class="boring">                        i += 2;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl_pollardrho!(u8, u16, 100000);
</span><span class="boring">    impl_pollardrho!(u16, u32, 100000);
</span><span class="boring">    impl_pollardrho!(u32, u64, 100000);
</span><span class="boring">    impl_pollardrho!(u64, u128, 100000);
</span><span class="boring">
</span><span class="boring">    pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
</span><span class="boring">    where
</span><span class="boring">        T: Copy + PartialEq + PartialOrd + core::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
</span><span class="boring">    {
</span><span class="boring">        if y == 0.into() {
</span><span class="boring">            x
</span><span class="boring">        } else {
</span><span class="boring">            let v = x % y;
</span><span class="boring">            gcd(y, v)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub mod rng {
</span><span class="boring">        pub struct RNG {
</span><span class="boring">            val: u64,
</span><span class="boring">        }
</span><span class="boring">        impl RNG {
</span><span class="boring">            pub fn new(seed: u64) -&gt; Self {
</span><span class="boring">                Self { val: seed }
</span><span class="boring">            }
</span><span class="boring">            pub fn next_u64(&amp;mut self) -&gt; u64 {
</span><span class="boring">                let mut x = self.val;
</span><span class="boring">                x ^= x &lt;&lt; 13;
</span><span class="boring">                x ^= x &gt;&gt; 7;
</span><span class="boring">                x ^= x &lt;&lt; 17;
</span><span class="boring">                self.val = x;
</span><span class="boring">                x
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub use rng::*;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod millerrabin {
</span><span class="boring">    pub trait Primality {
</span><span class="boring">        fn is_prime(self) -&gt; bool;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    macro_rules! impl_primality {
</span><span class="boring">        ($t:ty, $u:ty, $thres:expr, $bcnt:expr, $($basis:expr),+) =&gt; {
</span><span class="boring">            impl Primality for $t {
</span><span class="boring">                fn is_prime(self) -&gt; bool {
</span><span class="boring">                    if self &lt;= 1 {
</span><span class="boring">                        return false;
</span><span class="boring">                    } else if self &amp; 1 == 0 {
</span><span class="boring">                        return self == 2;
</span><span class="boring">                    }
</span><span class="boring">
</span><span class="boring">                    const THRES: $t = $thres;
</span><span class="boring">                    const TEST: [$t; $bcnt] = [$($basis,)+];
</span><span class="boring">
</span><span class="boring">                    if self &lt;= THRES {
</span><span class="boring">                        for p in (2..).take_while(|&amp;p| p * p &lt;= self) {
</span><span class="boring">                            if self % p == 0 {
</span><span class="boring">                                return false;
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">                        return true;
</span><span class="boring">                    }
</span><span class="boring">
</span><span class="boring">                    let pow = |base: $t, mut exp: $t| -&gt; $t {
</span><span class="boring">                        let mut base = base as $u;
</span><span class="boring">                        let mut ret = 1 as $u;
</span><span class="boring">                        while exp != 0 {
</span><span class="boring">                            if exp &amp; 1 != 0 {
</span><span class="boring">                                ret = (ret * base) % self as $u;
</span><span class="boring">                            }
</span><span class="boring">                            exp &gt;&gt;= 1;
</span><span class="boring">                            base = (base * base) % self as $u;
</span><span class="boring">                        }
</span><span class="boring">                        ret as $t
</span><span class="boring">                    };
</span><span class="boring">
</span><span class="boring">                    let s = (self - 1).trailing_zeros();
</span><span class="boring">                    let d = (self - 1) &gt;&gt; s;
</span><span class="boring">
</span><span class="boring">                    for &amp;a in TEST.iter().take_while(|&amp;&amp;a| a &lt; self - 1) {
</span><span class="boring">                        let mut x = pow(a, d);
</span><span class="boring">                        for _ in 0..s {
</span><span class="boring">                            let y = ((x as $u).pow(2) % self as $u) as $t;
</span><span class="boring">                            if y == 1 &amp;&amp; x != 1 &amp;&amp; x != self - 1 {
</span><span class="boring">                                return false;
</span><span class="boring">                            }
</span><span class="boring">                            x = y;
</span><span class="boring">                        }
</span><span class="boring">                        if x != 1 {
</span><span class="boring">                            return false;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">
</span><span class="boring">                    true
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl_primality!(u8, u16, 255, 1, 2);
</span><span class="boring">    impl_primality!(u16, u32, 2000, 2, 2, 3);
</span><span class="boring">    impl_primality!(u32, u64, 7000, 3, 2, 7, 61);
</span><span class="boring">    impl_primality!(u64, u128, 300000, 7, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-4"><a class="header" href="#code-4">Code</a></h2>
<pre><code class="language-rust noplayground">mod factorization {
    use super::millerrabin::Primality;
    use std::ops::*;

    pub trait PollardRho: Primality + From&lt;u8&gt; + PartialOrd + ShrAssign + BitAnd&lt;Output = Self&gt; + Clone {
        fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG);
        fn factorize(mut self, rng: &amp;mut rng::RNG) -&gt; Vec&lt;Self&gt; {
            let mut arr: Vec&lt;Self&gt; = Vec::new();
            if self &lt;= 1.into() {
                return arr;
            }
            while self.clone() &amp; 1.into() == 0.into() {
                self &gt;&gt;= 1.into();
                arr.push(2.into());
            }
            self.rho(&amp;mut arr, rng);
            arr
        }
    }

    macro_rules! impl_pollardrho {
        ($t:ty, $u:ty, $reset:expr) =&gt; {
            impl PollardRho for $t {
                fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG) {
                    if self &lt;= 1 {
                        return;
                    } else if self.is_prime() {
                        arr.push(self);
                        return;
                    }

                    let mut i: u64 = 0;
                    let mut x: $t = (rng.next_u64() % self as u64) as $t;
                    let mut y: $t = x;
                    let mut k: u64 = 2;
                    let mut d: $t;
                    let mut reset_limit: u64 = $reset;

                    loop {
                        i += 1;
                        x = (((x as $u * x as $u % self as $u) + (self - 1) as $u) % self as $u) as $t;
                        d = gcd(y.abs_diff(x), self);
                        if d == self || i &gt;= reset_limit {
                            // Reset
                            reset_limit = reset_limit * 3 / 2;
                            i = 0;
                            x = (rng.next_u64() % self as u64) as $t;
                            y = x;
                        }
                        if d != 1 {
                            break;
                        }
                        if i == k {
                            y = x;
                            k &lt;&lt;= 1;
                        }
                    }

                    if d != self {
                        d.rho(arr, rng);
                        (self / d).rho(arr, rng);
                        return;
                    }

                    let mut i = 3;
                    while i * i &lt;= self {
                        if self % i == 0 {
                            i.rho(arr, rng);
                            (d / i).rho(arr, rng);
                            return;
                        }
                        i += 2;
                    }
                }
            }
        };
    }

    impl_pollardrho!(u8, u16, 100000);
    impl_pollardrho!(u16, u32, 100000);
    impl_pollardrho!(u32, u64, 100000);
    impl_pollardrho!(u64, u128, 100000);

    pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
    where
        T: Copy + PartialEq + PartialOrd + core::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
    {
        if y == 0.into() {
            x
        } else {
            let v = x % y;
            gcd(y, v)
        }
    }

    pub mod rng {
        pub struct RNG {
            val: u64,
        }
        impl RNG {
            pub fn new(seed: u64) -&gt; Self {
                Self { val: seed }
            }
            pub fn next_u64(&amp;mut self) -&gt; u64 {
                let mut x = self.val;
                x ^= x &lt;&lt; 13;
                x ^= x &gt;&gt; 7;
                x ^= x &lt;&lt; 17;
                self.val = x;
                x
            }
        }
    }

    pub use self::rng::*;
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-theoretic-transform-ntt"><a class="header" href="#number-theoretic-transform-ntt">Number Theoretic Transform (NTT)</a></h1>
<p>Number Theoretic Transform (NTT) is an alternative of FFT where the domain of numbers is \(\mathbb{Z}_p\) where \(p\) is a prime with a form of \(p = a \times 2^b + 1\).</p>
<p><code>ntt::convolute(&amp;[u64], &amp;[u64]) -&gt; Vec&lt;u64&gt;</code> convolutes two slices using two NTTs on two different primes and CRT, within a range that none of the numbers in the result exceed the range of <code>u64</code>.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a: Vec&lt;u64&gt; = vec![1, 2];
let b: Vec&lt;u64&gt; = vec![3, 4, 5];
println!(&quot;{:?}&quot;, ntt::convolute(&amp;a, &amp;b)); // [3, 10, 13, 10, 0, 0, 0, 0]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod ntt {
</span><span class="boring">    // FFT_constname convention following https://algoshitpo.github.io/2020/05/20/fft-ntt/
</span><span class="boring">    // p: prime for modulo
</span><span class="boring">    // w: primitive root of p
</span><span class="boring">    // p = a * 2^b + 1
</span><span class="boring">
</span><span class="boring">    //             p  ntt_a ntt_b   ntt_w
</span><span class="boring">    //   998,244,353    119    23       3
</span><span class="boring">    // 2,281,701,377    17     27       3
</span><span class="boring">    // 2,483,027,969    37     26       3
</span><span class="boring">    // 2,113,929,217    63     25       5
</span><span class="boring">    //   104,857,601    25     22       3
</span><span class="boring">    // 1,092,616,193    521    21       3
</span><span class="boring">
</span><span class="boring">    fn ceil_pow2(n: usize) -&gt; u32 {
</span><span class="boring">        n.next_power_of_two().trailing_zeros()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Reverses k trailing bits of n. Assumes that the rest of usize::BITS-k bits are all zero.
</span><span class="boring">    const fn reverse_trailing_bits(n: usize, k: u32) -&gt; usize {
</span><span class="boring">        n.reverse_bits() &gt;&gt; (usize::BITS - k)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Clone, Debug)]
</span><span class="boring">    pub struct Ntt&lt;const P: u64&gt; {
</span><span class="boring">        pub arr: Vec&lt;u64&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;const P: u64&gt; Ntt&lt;P&gt; {
</span><span class="boring">        pub const fn ntt_a() -&gt; u64 {
</span><span class="boring">            let mut p = P - 1;
</span><span class="boring">            while p &amp; 1 == 0 {
</span><span class="boring">                p &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">            p
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub const fn ntt_b() -&gt; u32 {
</span><span class="boring">            let mut p = P - 1;
</span><span class="boring">            let mut ret = 0;
</span><span class="boring">            while p &amp; 1 == 0 {
</span><span class="boring">                p &gt;&gt;= 1;
</span><span class="boring">                ret += 1;
</span><span class="boring">            }
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub const fn ntt_w() -&gt; u64 {
</span><span class="boring">            match P {
</span><span class="boring">                998244353 | 2281701377 | 2483027969 | 104857601 | 1092616193 =&gt; 3,
</span><span class="boring">                2113929217 =&gt; 5,
</span><span class="boring">                _ =&gt; todo!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        const fn pow(base: u64, exp: u64) -&gt; u64 {
</span><span class="boring">            let mut base = base;
</span><span class="boring">            let mut exp = exp;
</span><span class="boring">            let mut ret = 1;
</span><span class="boring">            while exp != 0 {
</span><span class="boring">                if exp &amp; 1 != 0 {
</span><span class="boring">                    ret = ret * base % P;
</span><span class="boring">                }
</span><span class="boring">                base = base * base % P;
</span><span class="boring">                exp &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // unity(n, 1) ^ (1&lt;&lt;n) == 1
</span><span class="boring">        const fn unity(n: u32, k: u64) -&gt; u64 {
</span><span class="boring">            Self::pow(Self::pow(Self::ntt_w(), Self::ntt_a()), k &lt;&lt; (Self::ntt_b() - n))
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        const fn recip(x: u64) -&gt; u64 {
</span><span class="boring">            Self::pow(x, P - 2)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn new(arr: Vec&lt;u64&gt;) -&gt; Self {
</span><span class="boring">            Self { arr }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn ntt(&amp;mut self) {
</span><span class="boring">            let n: usize = self.arr.len();
</span><span class="boring">            let k = n.trailing_zeros();
</span><span class="boring">            debug_assert_eq!(n, 1 &lt;&lt; k);
</span><span class="boring">
</span><span class="boring">            for i in 0..n {
</span><span class="boring">                let j = reverse_trailing_bits(i, k);
</span><span class="boring">                if i &lt; j {
</span><span class="boring">                    self.arr.swap(i, j);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            for x in 0..k {
</span><span class="boring">                let base: u64 = Self::unity(x + 1, 1);
</span><span class="boring">                let s = 1 &lt;&lt; x;
</span><span class="boring">                for i in (0..n).step_by(s &lt;&lt; 1) {
</span><span class="boring">                    let mut mult: u64 = 1;
</span><span class="boring">                    for j in 0..s {
</span><span class="boring">                        let tmp = (self.arr[i + j + s] * mult) % P;
</span><span class="boring">                        self.arr[i + j + s] = (self.arr[i + j] + P - tmp) % P;
</span><span class="boring">                        self.arr[i + j] = (self.arr[i + j] + tmp) % P;
</span><span class="boring">                        mult = mult * base % P;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn intt(&amp;mut self) {
</span><span class="boring">            let n: usize = self.arr.len();
</span><span class="boring">            let k = n.trailing_zeros();
</span><span class="boring">            debug_assert_eq!(n, 1 &lt;&lt; k);
</span><span class="boring">
</span><span class="boring">            for i in 0..n {
</span><span class="boring">                let j = reverse_trailing_bits(i, k);
</span><span class="boring">                if i &lt; j {
</span><span class="boring">                    self.arr.swap(i, j);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            for x in 0..k {
</span><span class="boring">                let base: u64 = Self::recip(Self::unity(x + 1, 1));
</span><span class="boring">                let s = 1 &lt;&lt; x;
</span><span class="boring">                for i in (0..n).step_by(s &lt;&lt; 1) {
</span><span class="boring">                    let mut mult: u64 = 1;
</span><span class="boring">                    for j in 0..s {
</span><span class="boring">                        let tmp = (self.arr[i + j + s] * mult) % P;
</span><span class="boring">                        self.arr[i + j + s] = (self.arr[i + j] + P - tmp) % P;
</span><span class="boring">                        self.arr[i + j] = (self.arr[i + j] + tmp) % P;
</span><span class="boring">                        mult = mult * base % P;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let r = Self::recip(n as u64);
</span><span class="boring">            for f in self.arr.iter_mut() {
</span><span class="boring">                *f *= r;
</span><span class="boring">                *f %= P;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn convolute(a: &amp;[u64], b: &amp;[u64]) -&gt; Self {
</span><span class="boring">            let nlen = 1 &lt;&lt; ceil_pow2(a.len() + b.len());
</span><span class="boring">            let pad = |a: &amp;[u64]| a.iter().copied().chain(std::iter::repeat(0)).take(nlen).collect();
</span><span class="boring">            let arr = pad(a);
</span><span class="boring">            let brr = pad(b);
</span><span class="boring">
</span><span class="boring">            let mut arr = Self::new(arr);
</span><span class="boring">            let mut brr = Self::new(brr);
</span><span class="boring">            arr.ntt();
</span><span class="boring">            brr.ntt();
</span><span class="boring">
</span><span class="boring">            let crr: Vec&lt;_&gt; = arr.arr.iter().zip(brr.arr.iter()).map(|(&amp;a, &amp;b)| a * b % P).collect();
</span><span class="boring">            let mut crr = Self::new(crr);
</span><span class="boring">            crr.intt();
</span><span class="boring">            crr
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn merge&lt;const P: u64, const Q: u64&gt;(one: &amp;[u64], two: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">        let p: u64 = Ntt::&lt;Q&gt;::recip(P);
</span><span class="boring">        let q: u64 = Ntt::&lt;P&gt;::recip(Q);
</span><span class="boring">        let r: u64 = P * Q;
</span><span class="boring">        one.iter()
</span><span class="boring">            .zip(two.iter())
</span><span class="boring">            .map(|(&amp;a1, &amp;a2)| ((a1 as u128 * q as u128 * Q as u128 + a2 as u128 * p as u128 * P as u128) % r as u128) as u64)
</span><span class="boring">            .collect()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn convolute(a: &amp;[u64], b: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">        const P: u64 = 2281701377;
</span><span class="boring">        const Q: u64 = 998244353;
</span><span class="boring">        let a: Vec&lt;u64&gt; = a.iter().copied().collect();
</span><span class="boring">        let b: Vec&lt;u64&gt; = b.iter().copied().collect();
</span><span class="boring">
</span><span class="boring">        let arr = Ntt::&lt;P&gt;::convolute(&amp;a, &amp;b);
</span><span class="boring">        let brr = Ntt::&lt;Q&gt;::convolute(&amp;a, &amp;b);
</span><span class="boring">        merge::&lt;P, Q&gt;(&amp;arr.arr, &amp;brr.arr)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-5"><a class="header" href="#code-5">Code</a></h2>
<pre><code class="language-rust noplayground">mod ntt {
	// FFT_constname convention following https://algoshitpo.github.io/2020/05/20/fft-ntt/
	// p: prime for modulo
	// w: primitive root of p
	// p = a * 2^b + 1

	//             p  ntt_a ntt_b   ntt_w
	//   998,244,353    119    23       3
	// 2,281,701,377    17     27       3
	// 2,483,027,969    37     26       3
	// 2,113,929,217    63     25       5
	//   104,857,601    25     22       3
	// 1,092,616,193    521    21       3

	fn ceil_pow2(n: usize) -&gt; u32 { n.next_power_of_two().trailing_zeros() }

	/// Reverses k trailing bits of n. Assumes that the rest of usize::BITS-k bits are all zero.
	const fn reverse_trailing_bits(n: usize, k: u32) -&gt; usize { n.reverse_bits() &gt;&gt; (usize::BITS - k) }

	#[derive(Clone, Debug)]
	pub struct Ntt&lt;const P: u64&gt; {
		pub arr: Vec&lt;u64&gt;,
	}

	impl&lt;const P: u64&gt; Ntt&lt;P&gt; {
		pub const fn ntt_a() -&gt; u64 {
			let p = P - 1;
			p &gt;&gt; p.trailing_zeros()
		}

		pub const fn ntt_b() -&gt; u32 { (P - 1).trailing_zeros() }

		/// Primitive root of P
		pub const fn ntt_w() -&gt; u64 {
			match P {
				998244353 | 2281701377 | 2483027969 | 104857601 | 1092616193 =&gt; 3,
				2113929217 =&gt; 5,
				_ =&gt; todo!(),
			}
		}

		const fn pow(mut base: u64, mut exp: u64) -&gt; u64 {
			let mut ret = 1;
			while exp != 0 {
				if exp &amp; 1 != 0 {
					ret = ret * base % P;
				}
				base = base * base % P;
				exp &gt;&gt;= 1;
			}
			ret
		}

		/// Returns an integer x where x^(2^n) == 1 mod P.
		/// That is, it returns (2^n)-th root of unity.
		const fn unity(n: u32, k: u64) -&gt; u64 { Self::pow(Self::pow(Self::ntt_w(), Self::ntt_a()), k &lt;&lt; (Self::ntt_b() - n)) }

		const fn recip(x: u64) -&gt; u64 { Self::pow(x, P - 2) }

		pub fn new(arr: Vec&lt;u64&gt;) -&gt; Self { Self { arr } }

		pub fn ntt(&amp;mut self) {
			let n: usize = self.arr.len();
			let k = n.trailing_zeros();
			debug_assert_eq!(n, 1 &lt;&lt; k);

			for i in 0..n {
				let j = reverse_trailing_bits(i, k);
				if i &lt; j {
					self.arr.swap(i, j);
				}
			}

			let mut basis = vec![Self::unity(k, 1)];
			for i in 1..k as usize {
				basis.push(basis[i - 1] * basis[i - 1] % P);
			}
			for (x, &amp;base) in basis.iter().rev().enumerate() {
				let s = 1 &lt;&lt; x;
				for i in (0..n).step_by(s &lt;&lt; 1) {
					let mut mult: u64 = 1;
					for j in i..i + s {
						let tmp = (self.arr[j + s] * mult) % P;
						self.arr[j + s] = (self.arr[j] + P - tmp) % P;
						self.arr[j] = (self.arr[j] + tmp) % P;
						mult = mult * base % P;
					}
				}
			}
		}

		pub fn intt(&amp;mut self) {
			let n: usize = self.arr.len();
			let k = n.trailing_zeros();
			debug_assert_eq!(n, 1 &lt;&lt; k);

			for i in 0..n {
				let j = reverse_trailing_bits(i, k);
				if i &lt; j {
					self.arr.swap(i, j);
				}
			}

			let mut basis = vec![Self::recip(Self::unity(k, 1))];
			for i in 1..k as usize {
				basis.push(basis[i - 1] * basis[i - 1] % P);
			}
			for (x, &amp;base) in basis.iter().rev().enumerate() {
				let s = 1 &lt;&lt; x;
				for i in (0..n).step_by(s &lt;&lt; 1) {
					let mut mult: u64 = 1;
					for j in i..i + s {
						let tmp = (self.arr[j + s] * mult) % P;
						self.arr[j + s] = (self.arr[j] + P - tmp) % P;
						self.arr[j] = (self.arr[j] + tmp) % P;
						mult = mult * base % P;
					}
				}
			}

			let r = Self::recip(n as u64);
			for f in self.arr.iter_mut() {
				*f *= r;
				*f %= P;
			}
		}

		pub fn convolute(a: &amp;[u64], b: &amp;[u64]) -&gt; Self {
			let nlen = 1 &lt;&lt; ceil_pow2(a.len() + b.len());
			let pad = |a: &amp;[u64]| a.iter().copied().chain(std::iter::repeat(0)).take(nlen).collect();
			let arr = pad(a);
			let brr = pad(b);

			let mut arr = Self::new(arr);
			let mut brr = Self::new(brr);
			arr.ntt();
			brr.ntt();

			let crr: Vec&lt;_&gt; = arr.arr.iter().zip(brr.arr.iter()).map(|(&amp;a, &amp;b)| a * b % P).collect();
			let mut crr = Self::new(crr);
			crr.intt();
			crr
		}
	}

	fn merge&lt;const P: u64, const Q: u64&gt;(one: &amp;[u64], two: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
		let p = Ntt::&lt;Q&gt;::recip(P) as u128;
		let q = Ntt::&lt;P&gt;::recip(Q) as u128;
		let [pp, qq] = [P, Q].map(|x| x as u128);
		let r = (P * Q) as u128;

		one.iter()
			.zip(two.iter())
			.map(|(&amp;a1, &amp;a2)| {
				let [a, b] = [a1, a2].map(|x| x as u128);
				(a * q * qq + b * p * pp) % r
			})
			.map(|x| x as u64)
			.collect()
	}

	pub fn convolute(a: &amp;[u64], b: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
		const P: u64 = 2281701377;
		const Q: u64 = 998244353;

		let arr = Ntt::&lt;P&gt;::convolute(a, b);
		let brr = Ntt::&lt;Q&gt;::convolute(a, b);
		merge::&lt;P, Q&gt;(&amp;arr.arr, &amp;brr.arr)
	}
}</code></pre>
<hr />
<p>Last modified on 231203.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-recurrence"><a class="header" href="#linear-recurrence">Linear Recurrence</a></h1>
<p>Algorithms related to linear recurrences</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="berlekamp-massey"><a class="header" href="#berlekamp-massey">Berlekamp-Massey</a></h1>
<p><code>berlekamp_massey(A, m)</code> returns a vector <code>C</code> of length \(n\) which satisfies
\[ \begin{aligned}
A_x &amp;= \sum_{i=0}^{i=k-1} {C_i A_{x-k+i}} \\
&amp;= C_0 A_{x-k} + C_1 A_{x-k+1} + \cdots + C_{k-1} A_{x-1}
\end{aligned} \]
with minimum \(n\) under <strong>prime</strong> modulo \(m\). It is safe to have the length of <code>vals</code> as at least \(3n\).</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>// vals[x] = vals[x-3] + 2*vals[x-2] + 3*vals[x-1]
let m: u64 = 1000000007;
let mut vals: Vec&lt;u64&gt; = vec![1, 2, 3];
for x in 3..20 {
    vals.push((vals[x - 3] + 2 * vals[x - 2] + 3 * vals[x - 1]) % m);
}

let rec = berlekamp_massey(&amp;vals, m);
println!(&quot;{:?}&quot;, rec); // [1, 2, 3]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Berlekamp-Massey
</span><span class="boring">// References
</span><span class="boring">// https://blog.naver.com/jinhan814/222140081932
</span><span class="boring">// https://koosaga.com/231
</span><span class="boring">
</span><span class="boring">fn rem_pow(mut base: i64, mut exp: i64, m: i64) -&gt; i64 {
</span><span class="boring">    let mut result = 1;
</span><span class="boring">    while exp != 0 {
</span><span class="boring">        if exp &amp; 1 != 0 {
</span><span class="boring">            result = (result * base) % m;
</span><span class="boring">        }
</span><span class="boring">        exp &gt;&gt;= 1;
</span><span class="boring">        base = (base * base) % m;
</span><span class="boring">    }
</span><span class="boring">    result
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Finds rec[n] which satisfies
</span><span class="boring">/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rec[d-1]vals[d-1]
</span><span class="boring">/// with minimum n.
</span><span class="boring">fn berlekamp_massey(vals: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">    let m = m as i64;
</span><span class="boring">    let mut cur: Vec&lt;i64&gt; = Vec::new();
</span><span class="boring">    let (mut lf, mut ld) = (0, 0);
</span><span class="boring">    let mut ls: Vec&lt;i64&gt; = Vec::new();
</span><span class="boring">    for i in 0..vals.len() {
</span><span class="boring">        let mut t = 0;
</span><span class="boring">        for (j, v) in cur.iter().enumerate() {
</span><span class="boring">            t = (t + vals[i - j - 1] as i64 * v) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if (t - vals[i] as i64) % m == 0 {
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if cur.len() == 0 {
</span><span class="boring">            cur = vec![0; i + 1];
</span><span class="boring">            lf = i;
</span><span class="boring">            ld = (t - vals[i] as i64) % m;
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;
</span><span class="boring">        let mut c: Vec&lt;i64&gt; = vec![0; i - lf + ls.len()];
</span><span class="boring">        c[i - lf - 1] = k as i64;
</span><span class="boring">        for (p, j) in ls.iter().enumerate() {
</span><span class="boring">            c[i - lf + p] = -j * k % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if c.len() &lt; cur.len() {
</span><span class="boring">            c.extend((0..(cur.len() - c.len())).map(|_| 0));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        for j in 0..cur.len() {
</span><span class="boring">            c[j] = (c[j] + cur[j]) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if i - lf + ls.len() &gt;= cur.len() {
</span><span class="boring">            ls = cur;
</span><span class="boring">            lf = i;
</span><span class="boring">            ld = (t - vals[i] as i64) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        cur = c;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    for i in 0..cur.len() {
</span><span class="boring">        cur[i] = (cur[i] % m + m) % m;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    cur.into_iter().rev().map(|x| x as u64).collect()
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-6"><a class="header" href="#code-6">Code</a></h2>
<pre><code class="language-rust noplayground">// Berlekamp-Massey
// References
// https://blog.naver.com/jinhan814/222140081932
// https://koosaga.com/231

fn rem_pow(mut base: i64, mut exp: i64, m: i64) -&gt; i64 {
    let mut result = 1;
    while exp != 0 {
        if exp &amp; 1 != 0 {
            result = (result * base) % m;
        }
        exp &gt;&gt;= 1;
        base = (base * base) % m;
    }
    result
}

/// Finds rec[n] which satisfies
/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rec[d-1]vals[d-1]
/// with minimum n.
fn berlekamp_massey(vals: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let m = m as i64;
    let mut cur: Vec&lt;i64&gt; = Vec::new();
    let (mut lf, mut ld) = (0, 0);
    let mut ls: Vec&lt;i64&gt; = Vec::new();
    for i in 0..vals.len() {
        let mut t = 0;
        for (j, v) in cur.iter().enumerate() {
            t = (t + vals[i - j - 1] as i64 * v) % m;
        }

        if (t - vals[i] as i64) % m == 0 {
            continue;
        }

        if cur.len() == 0 {
            cur = vec![0; i + 1];
            lf = i;
            ld = (t - vals[i] as i64) % m;
            continue;
        }

        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;
        let mut c: Vec&lt;i64&gt; = vec![0; i - lf + ls.len()];
        c[i - lf - 1] = k as i64;
        for (p, j) in ls.iter().enumerate() {
            c[i - lf + p] = -j * k % m;
        }

        if c.len() &lt; cur.len() {
            c.extend((0..(cur.len() - c.len())).map(|_| 0));
        }

        for j in 0..cur.len() {
            c[j] = (c[j] + cur[j]) % m;
        }

        if i - lf + ls.len() &gt;= cur.len() {
            ls = cur;
            lf = i;
            ld = (t - vals[i] as i64) % m;
        }

        cur = c;
    }

    for i in 0..cur.len() {
        cur[i] = (cur[i] % m + m) % m;
    }

    cur.into_iter().rev().map(|x| x as u64).collect()
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kitamasa"><a class="header" href="#kitamasa">Kitamasa</a></h1>
<p><code>kitamasa(C, A, n, m)</code> returns \(A_n\) where
\[ \begin{aligned}
A_x &amp;= \sum_{i=0}^{i=k-1} {C_i A_{x-k+i}} \\
&amp;= C_0 A_{x-k} + C_1 A_{x-k+1} + \cdots + C_{k-1} A_{x-1}
\end{aligned} \]
in a time complexity of \( O(T(k) \log{n}) \), where \(O(T(k))\) is a time complexity taken for multiplying two polynomials of order \(k\), and \(k\) is a length of \(C\).</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>// vals[x] = vals[x-3] + 2*vals[x-2] + 3*vals[x-1]
// 1, 2, 3, 14, 50, 181, 657, 2383, 8644, 31355, 113736, 412562, 1496513, 5428399, 19690785, 71425666, ...
let m: u64 = 1000000007;
let vals: Vec&lt;u64&gt; = vec![1, 2, 3];
let rec: Vec&lt;u64&gt; = vec![1, 2, 3];

let v = kitamasa(&amp;rec, &amp;vals, 15, m);
println!(&quot;{}&quot;, v); // 71425666
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Kitamasas
</span><span class="boring">// Reference: https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/
</span><span class="boring">
</span><span class="boring">fn poly_mul(v: &amp;[u64], w: &amp;[u64], rec: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">    let mut t = vec![0; 2 * v.len()];
</span><span class="boring">
</span><span class="boring">    for j in 0..v.len() {
</span><span class="boring">        for k in 0..w.len() {
</span><span class="boring">            t[j + k] += v[j] * w[k] % m;
</span><span class="boring">            if t[j + k] &gt;= m {
</span><span class="boring">                t[j + k] -= m;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    for j in (v.len()..2 * v.len()).rev() {
</span><span class="boring">        for k in 1..=v.len() {
</span><span class="boring">            t[j - k] += t[j] * rec[k - 1] % m;
</span><span class="boring">            if t[j - k] &gt;= m {
</span><span class="boring">                t[j - k] -= m;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    t[..v.len()].iter().map(|x| *x).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Finds arr[n] where
</span><span class="boring">/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
</span><span class="boring">/// under modulo m where d=rec.len()=arr.len()
</span><span class="boring">fn kitamasa(rec: &amp;[u64], vals: &amp;[u64], mut n: u64, m: u64) -&gt; u64 {
</span><span class="boring">    let recurr: Vec&lt;_&gt; = rec.iter().rev().copied().collect();
</span><span class="boring">    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);
</span><span class="boring">    s[0] = 1;
</span><span class="boring">    if recurr.len() != 1 {
</span><span class="boring">        t[1] = 1;
</span><span class="boring">    } else {
</span><span class="boring">        t[0] = recurr[0];
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    while n != 0 {
</span><span class="boring">        if n &amp; 1 != 0 {
</span><span class="boring">            s = poly_mul(&amp;s, &amp;t, &amp;recurr, m);
</span><span class="boring">        }
</span><span class="boring">        t = poly_mul(&amp;t, &amp;t, &amp;recurr, m);
</span><span class="boring">        n &gt;&gt;= 1;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mut ret = 0u64;
</span><span class="boring">    for i in 0..recurr.len() {
</span><span class="boring">        ret += s[i] * vals[i] % m;
</span><span class="boring">        if ret &gt;= m {
</span><span class="boring">            ret -= m;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    ret
</span><span class="boring">}</span></code></pre></pre>
<h2 id="ok2-logn-implementation"><a class="header" href="#ok2-logn-implementation">\(O(k^2 \log{n})\) Implementation</a></h2>
<p>The implementation below uses naive polynomial multiplication.</p>
<pre><code class="language-rust noplayground">// Kitamasa
// Reference: JusticeHui's Blog: &lt;https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/&gt;

fn poly_mul(v: &amp;[u64], w: &amp;[u64], rec: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut t = vec![0; 2 * v.len()];

    for j in 0..v.len() {
        for k in 0..w.len() {
            t[j + k] += v[j] * w[k] % m;
            if t[j + k] &gt;= m {
                t[j + k] -= m;
            }
        }
    }

    for j in (v.len()..2 * v.len()).rev() {
        for k in 1..=v.len() {
            t[j - k] += t[j] * rec[k - 1] % m;
            if t[j - k] &gt;= m {
                t[j - k] -= m;
            }
        }
    }

    t[..v.len()].iter().map(|x| *x).collect()
}

/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under modulo m where d=rec.len()=arr.len()
fn kitamasa(rec: &amp;[u64], vals: &amp;[u64], mut n: u64, m: u64) -&gt; u64 {
    let recurr: Vec&lt;_&gt; = rec.iter().rev().copied().collect();
    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);
    s[0] = 1;
    if recurr.len() != 1 {
        t[1] = 1;
    } else {
        t[0] = recurr[0];
    }

    while n != 0 {
        if n &amp; 1 != 0 {
            s = poly_mul(&amp;s, &amp;t, &amp;recurr, m);
        }
        t = poly_mul(&amp;t, &amp;t, &amp;recurr, m);
        n &gt;&gt;= 1;
    }

    let mut ret = 0u64;
    for i in 0..recurr.len() {
        ret += s[i] * vals[i] % m;
        if ret &gt;= m {
            ret -= m;
        }
    }
    ret
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bostan-mori"><a class="header" href="#bostan-mori">Bostan-Mori</a></h1>
<p>Reference - <a href="https://hal.inria.fr/hal-02917827v2/document">Alin Bostan, Ryuhei Mori. A Simple and Fast Algorithm for Computing the N-th Term of a Linearly Recurrent Sequence. SOSA’21 (SIAM Symposium on Simplicity in Algorithms), Jan 2021, Alexandria, United States. ffhal-02917827v2f</a></p>
<p>Given \(k\) initial values \(c_0,\ c_1,\ \cdots,\ c_{k-1}\) and a linear recurrence of length \(k\):
\[ f_{n+k} = c_0f_n + c_1f_{n+1} + \cdots + c_{k-1}f_{n+k-1} \]
<code>bostan_mori::&lt;P&gt;(c, f, n)</code> calculates \(f_n \bmod P\). Here, \(P\) can be any integer larger than \(1\).</p>
<p>The time complexity of this algorithm is \(O(\mathrm{M}(k) \log n)\) where \(\mathrm{M}(k)\) represents the time complexity for polynomial multiplication.
This depends on the implementation of <code>poly_mul</code>. In this snippet, naive polynomial multiplication is used, resulting in a time complexity of \(O(k^2 \log n)\).
By replacing it with an implementation using FFT, the time complexity can be improved to \(O(k \log k \log n)\).</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<p>This example calculates terms of \({f_n}\) for \(0 \le n \le 10\) where \(f_0 = 0\), \(f_1 = 1\), and \(f_{n+2} = 2f_n + f_{n+1}\).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>for i in 0..=10 {
    println!(&quot;{}&quot;, bostan_mori::&lt;12345&gt;(&amp;[2, 1], &amp;[0, 1], i));
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Finds arr[n] where
</span><span class="boring">/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
</span><span class="boring">/// under mod P where d=rec.len()=arr.len()
</span><span class="boring">fn bostan_mori&lt;const P: u64&gt;(rec: &amp;[u64], vals: &amp;[u64], mut n: u64) -&gt; u64 {
</span><span class="boring">    if vals.len() as u64 &gt; n {
</span><span class="boring">        return vals[n as usize];
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let x = (0..rec.len()).find(|&amp;i| rec[i] != 0).unwrap_or(rec.len());
</span><span class="boring">    if x == rec.len() {
</span><span class="boring">        return 0;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let vals: Vec&lt;u64&gt; = vals.iter().map(|&amp;v| v % P).collect();
</span><span class="boring">    let rec: Vec&lt;u64&gt; = rec.iter().map(|&amp;v| v % P).collect();
</span><span class="boring">    let mut q = vec![1];
</span><span class="boring">    q.extend(rec.iter().rev().map(|&amp;v| (P - v) % P));
</span><span class="boring">    let mut p = poly_mul::&lt;P&gt;(&amp;vals, &amp;q);
</span><span class="boring">    p.truncate(rec.len());
</span><span class="boring">
</span><span class="boring">    while n &gt;= 1 {
</span><span class="boring">        let mq: Vec&lt;_&gt; = q
</span><span class="boring">            .iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .map(|(i, &amp;v)| if i % 2 == 0 { v } else { (P - v) % P })
</span><span class="boring">            .collect();
</span><span class="boring">        let u = poly_mul::&lt;P&gt;(&amp;p, &amp;mq);
</span><span class="boring">        p = u
</span><span class="boring">            .iter()
</span><span class="boring">            .copied()
</span><span class="boring">            .skip((n % 2) as usize)
</span><span class="boring">            .step_by(2)
</span><span class="boring">            .collect();
</span><span class="boring">        let a = poly_mul::&lt;P&gt;(&amp;q, &amp;mq);
</span><span class="boring">        q = a.iter().copied().step_by(2).collect();
</span><span class="boring">        n /= 2;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    p[0] % P
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn poly_mul&lt;const P: u64&gt;(a: &amp;[u64], b: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">    let mut ret = vec![0; a.len() + b.len() - 1];
</span><span class="boring">    for (i, &amp;av) in a.iter().enumerate() {
</span><span class="boring">        for (j, &amp;bv) in b.iter().enumerate() {
</span><span class="boring">            ret[i + j] = (ret[i + j] + av * bv) % P;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    ret
</span><span class="boring">}
</span><span class="boring"></span></code></pre></pre>
<h2 id="snippet"><a class="header" href="#snippet">Snippet</a></h2>
<pre><code class="language-rust noplayground">/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under mod P where d=rec.len()=arr.len()
fn bostan_mori&lt;const P: u64&gt;(rec: &amp;[u64], vals: &amp;[u64], mut n: u64) -&gt; u64 {
	if vals.len() as u64 &gt; n {
		return vals[n as usize];
	}

	let x = (0..rec.len()).find(|&amp;i| rec[i] != 0).unwrap_or(rec.len());
	if x == rec.len() {
		return 0;
	}

	let vals: Vec&lt;u64&gt; = vals.iter().map(|&amp;v| v % P).collect();
	let rec: Vec&lt;u64&gt; = rec.iter().map(|&amp;v| v % P).collect();
	let mut q = vec![1];
	q.extend(rec.iter().rev().map(|&amp;v| (P - v) % P));
	let mut p = poly_mul::&lt;P&gt;(&amp;vals, &amp;q);
	p.truncate(rec.len());

	while n &gt;= 1 {
		let mq: Vec&lt;_&gt; = q.iter().enumerate().map(|(i, &amp;v)| if i % 2 == 0 { v } else { (P - v) % P }).collect();
		let u = poly_mul::&lt;P&gt;(&amp;p, &amp;mq);
		p = u.iter().copied().skip((n % 2) as usize).step_by(2).collect();
		let a = poly_mul::&lt;P&gt;(&amp;q, &amp;mq);
		q = a.iter().copied().step_by(2).collect();
		n /= 2;
	}

	p[0] % P
}

/// Naive O(k^2) multiplication
fn poly_mul&lt;const P: u64&gt;(a: &amp;[u64], b: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
	let mut ret = vec![0; a.len() + b.len() - 1];
	for (i, &amp;av) in a.iter().enumerate() {
		for (j, &amp;bv) in b.iter().enumerate() {
			ret[i + j] = (ret[i + j] + av * bv) % P;
		}
	}
	ret
}</code></pre>
<hr />
<p>Last modified on 231203.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-square-root"><a class="header" href="#integer-square-root">Integer Square Root</a></h1>
<p><code>isqrt(s)</code> returns \( \left\lfloor \sqrt{s} \right\rfloor \). It runs much faster than the typical binary search method, but slower than casting the result from <code>std::f64::sqrt</code>. If the value can be perfectly represented with <code>f64</code> and the memory limit isn't too short, it's better to use the <code>f64</code> square root function from <code>std</code>.</p>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let x: u64 = 10002;
let sq = isqrt(x);
println!(&quot;{}&quot;, sq); // 100
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn isqrt(s: u64) -&gt; u64 {
</span><span class="boring">    let mut x0 = s &gt;&gt; 1;
</span><span class="boring">    if x0 != 0 {
</span><span class="boring">        let mut x1 = (x0 + s / x0) &gt;&gt; 1;
</span><span class="boring">        while x1 &lt; x0 {
</span><span class="boring">            x0 = x1;
</span><span class="boring">            x1 = (x0 + s / x0) &gt;&gt; 1
</span><span class="boring">        }
</span><span class="boring">        x0
</span><span class="boring">    } else {
</span><span class="boring">        s
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-7"><a class="header" href="#code-7">Code</a></h2>
<pre><code class="language-rust noplayground">fn isqrt&lt;T&gt;(s: T) -&gt; T
where T: Copy + Shr&lt;Output = T&gt; + Add&lt;Output = T&gt; + Div&lt;Output = T&gt; + PartialOrd + From&lt;u8&gt; {
	let mut x0 = s &gt;&gt; 1.into();
	if x0 != 0.into() {
		let mut x1 = (x0 + s / x0) &gt;&gt; 1.into();
		while x1 &lt; x0 {
			x0 = x1;
			x1 = (x0 + s / x0) &gt;&gt; 1.into();
		}
		x0
	} else {
		s
	}
}</code></pre>
<hr />
<p>Last modified on 231203.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disjoint-set-union"><a class="header" href="#disjoint-set-union">Disjoint Set Union</a></h1>
<p>Disjoint set union data structure.</p>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut uf = UnionFind::new(10);
println!(&quot;{}&quot;, uf.find_root(2) == uf.find_root(6)); // false
uf.union(2, 6);
println!(&quot;{}&quot;, uf.find_root(2) == uf.find_root(6)); // true
<span class="boring">}
</span><span class="boring">
</span><span class="boring">struct UnionFind {
</span><span class="boring">    parent: Vec&lt;usize&gt;,
</span><span class="boring">    size: Vec&lt;usize&gt;,
</span><span class="boring">    num: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnionFind {
</span><span class="boring">    fn new(n: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            parent: (0..n).collect(),
</span><span class="boring">            size: vec![1; n],
</span><span class="boring">            num: n,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn find_root(&amp;mut self, mut x: usize) -&gt; usize {
</span><span class="boring">        while self.parent[x] != x {
</span><span class="boring">            self.parent[x] = self.parent[self.parent[x]];
</span><span class="boring">            x = self.parent[x];
</span><span class="boring">        }
</span><span class="boring">        x
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn union(&amp;mut self, u: usize, v: usize) {
</span><span class="boring">        let u = self.find_root(u);
</span><span class="boring">        let v = self.find_root(v);
</span><span class="boring">        if u != v {
</span><span class="boring">            self.num -= 1;
</span><span class="boring">            if self.size[u] &lt; self.size[v] {
</span><span class="boring">                self.parent[u] = v;
</span><span class="boring">                self.size[v] += self.size[u];
</span><span class="boring">            } else {
</span><span class="boring">                self.parent[v] = u;
</span><span class="boring">                self.size[u] += self.size[v];
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_size(&amp;mut self, x: usize) -&gt; usize {
</span><span class="boring">        let r = self.find_root(x);
</span><span class="boring">        self.size[r]
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-8"><a class="header" href="#code-8">Code</a></h2>
<pre><code class="language-rust noplayground">struct UnionFind {
    parent: Vec&lt;usize&gt;,
    size: Vec&lt;usize&gt;,
    num: usize,
}

impl UnionFind {
    fn new(n: usize) -&gt; Self {
        Self {
            parent: (0..n).collect(),
            size: vec![1; n],
            num: n,
        }
    }

    fn find_root(&amp;mut self, mut x: usize) -&gt; usize {
        while self.parent[x] != x {
            self.parent[x] = self.parent[self.parent[x]];
            x = self.parent[x];
        }
        x
    }

    fn union(&amp;mut self, u: usize, v: usize) {
        let u = self.find_root(u);
        let v = self.find_root(v);
        if u != v {
            self.num -= 1;
            if self.size[u] &lt; self.size[v] {
                self.parent[u] = v;
                self.size[v] += self.size[u];
            } else {
                self.parent[v] = u;
                self.size[u] += self.size[v];
            }
        }
    }

    fn get_size(&amp;mut self, x: usize) -&gt; usize {
        let r = self.find_root(x);
        self.size[r]
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weighted-dsu"><a class="header" href="#weighted-dsu">Weighted DSU</a></h1>
<p>Disjoint set union where vertices have their own &quot;potential value&quot;. The potential value of a vertex \(i\) is denoted as \(w(i)\), and the differences of potential values between vertices in a same group are always well defined.</p>
<p><code>fn union(&amp;mut self, u: usize, v: usize, dw: i64)</code> addes a &quot;rule&quot; stating that \(u\) and \(v\) are in a same group, and \(w(u) - w(v) = dw\). Based on posed rules ahead, <code>fn get_pot_diff(&amp;mut self, u: usize, v: usize) -&gt; Option&lt;i64&gt;</code> returns \(w(u) - w(v)\) if \(u\) and \(v\) are in a same group.</p>
<p><code>potdiff[i]</code> in the code is defined as \(w(i) - w(r_i)\), where \(r_i\) is a root of a group \(i\) is in.</p>
<h2 id="code-9"><a class="header" href="#code-9">Code</a></h2>
<pre><code class="language-rust noplayground">struct WeightDSU {
	parent: Vec&lt;usize&gt;,
	size: Vec&lt;usize&gt;,
	num: usize,
	potdiff: Vec&lt;i64&gt;, // potdiff[x] == w(x) - w(p)
}

impl WeightDSU {
	fn new(n: usize) -&gt; Self {
		Self {
			parent: (0..n).collect(),
			size: vec![1; n],
			num: n,
			potdiff: vec![0; n],
		}
	}

	// Returns the root of x.
	fn find_root(&amp;mut self, mut x: usize) -&gt; usize {
		while self.parent[x] != x {
			let p = self.parent[x];
			self.potdiff[x] += self.potdiff[p];
			self.parent[x] = self.parent[p];
			x = self.parent[x];
		}
		x
	}

	// Returns the root of x, namely xr, with w(x) - w(xr).
	fn find_root_with_pdiff(&amp;mut self, mut x: usize) -&gt; (usize, i64) {
		let mut pd = 0;
		while self.parent[x] != x {
			let p = self.parent[x];
			self.potdiff[x] += self.potdiff[p];
			self.parent[x] = self.parent[p];
			pd += self.potdiff[x];
			x = self.parent[x];
		}
		(x, pd)
	}

	// Unions groups of u and v, with w(u) - w(v) = dw. If u and v are already in a same group,
	// if w(u) - w(v) == dv then it returns Some(true), otherwise Some(false). If they weren't
	// in a same group, then it returns None and unions two groups following the given dw.
	fn union(&amp;mut self, u: usize, v: usize, dw: i64) -&gt; Option&lt;bool&gt; {
		let (ur, pu) = self.find_root_with_pdiff(u);
		let (vr, pv) = self.find_root_with_pdiff(v);
		let nw = dw - pu + pv;
		if ur != vr {
			self.num -= 1;
			if self.size[ur] &lt; self.size[vr] {
				self.parent[ur] = vr;
				self.size[vr] += self.size[ur];
				self.potdiff[ur] = nw;
			} else {
				self.parent[vr] = ur;
				self.size[ur] += self.size[vr];
				self.potdiff[vr] = -nw;
			}
			None
		} else {
			Some(nw == 0)
		}
	}

	// Returns the size of a group x is in.
	fn get_size(&amp;mut self, x: usize) -&gt; usize {
		let r = self.find_root(x);
		self.size[r]
	}

	// Returns Some(w(u) - w(v)) if u and v are in the same group, otherwise None.
	fn get_pot_diff(&amp;mut self, u: usize, v: usize) -&gt; Option&lt;i64&gt; {
		let (ur, pu) = self.find_root_with_pdiff(u);
		let (vr, pv) = self.find_root_with_pdiff(v);
		if ur == vr {
			Some(pu - pv)
		} else {
			None
		}
	}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-trees"><a class="header" href="#segment-trees">Segment Trees</a></h1>
<p>Segment trees are a category of data structures which can handle range queries efficiently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A segment tree is a data structure for monoids \( (S, \cdot : S \times S \rightarrow S, e \in S) \). A monoid is an algebraic structure which follows the following conditions:</p>
<ul>
<li>\(\cdot\) is associative. That is, \( (a \cdot b) \cdot c = a \cdot (b \cdot c) \) for all \( a, b, c \in S \).</li>
<li>There is the identity element \(e\) such that \( a \cdot e = e \cdot a = a \) for all \( a \in S \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(S\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Update an element</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<h2 id="example-11"><a class="header" href="#example-11">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use segtree::*;

<span class="boring">fn main() {
</span>// Product segment tree with size of 10 and all elements being 1
let st = SegTree::new(10, std::iter::repeat(1), 1, |x, y| x * y % 1000000007);
// Sum segment tree with initial values
let st = SegTree::new(10, vec![1, 3, 2, 4, 3, 5, 4, 6, 5, 7], 0, |x, y| x + y);

// Sum segment tree with size of 10 and all elements being 0
let mut st = SegTree::new(10, None, 0, |x, y| x + y);

st.update(2, |_| 3);
println!(&quot;{}&quot;, st.get(2)); // 3

let prev = st.get(4);
st.update(4, |x| x + 2);
let curr = st.get(4);
println!(&quot;{prev} -&gt; {curr}&quot;); // 0 -&gt; 2

println!(&quot;{}&quot;, st.prod(..4)); // 3
println!(&quot;{}&quot;, st.prod(4..)); // 2
println!(&quot;{}&quot;, st.prod(..)); // 5
println!(&quot;{}&quot;, st.prod(100..101)); // 0
println!(&quot;{}&quot;, st.prod(4..2)); // 0

for i in 1..=st.len() {
    print!(&quot;{} &quot;, st.prod(1..i));
}
println!(); // 0 0 3 3 5 5 5 5 5 5
println!(&quot;{}&quot;, st.partition_point(1, |x| x &lt; 3)); // 3
println!(&quot;{}&quot;, st.partition_point(1, |x| x &lt; 5)); // 5
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod segtree {
</span><span class="boring">    use std::ops::RangeBounds;
</span><span class="boring">
</span><span class="boring">    /// A segment tree is a data structure for a monoid type `T`.
</span><span class="boring">    ///
</span><span class="boring">    /// Given all the constraints written in the comment of `SegTree::new`, a segment tree can process the following queries in O(TlogN) time assuming `op` all run in O(T).
</span><span class="boring">    /// - Changing the value of an element
</span><span class="boring">    /// - Calculating the product of elements in an interval, combined with `op`
</span><span class="boring">    pub struct SegTree&lt;T, O&gt; {
</span><span class="boring">        n: usize,
</span><span class="boring">        data: Vec&lt;T&gt;,
</span><span class="boring">        e: T,
</span><span class="boring">        op: O,
</span><span class="boring">        size: usize,
</span><span class="boring">        log: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;T: Copy, O: Fn(T, T) -&gt; T&gt; SegTree&lt;T, O&gt; {
</span><span class="boring">        fn get_bounds(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; (usize, usize) {
</span><span class="boring">            use std::ops::Bound::*;
</span><span class="boring">            let n = self.len();
</span><span class="boring">            let l = match range.start_bound() {
</span><span class="boring">                Included(&amp;v) =&gt; v,
</span><span class="boring">                Excluded(&amp;v) =&gt; v + 1,
</span><span class="boring">                Unbounded =&gt; 0,
</span><span class="boring">            };
</span><span class="boring">            let r = match range.end_bound() {
</span><span class="boring">                Included(&amp;v) =&gt; (v + 1).min(n),
</span><span class="boring">                Excluded(&amp;v) =&gt; v.min(n),
</span><span class="boring">                Unbounded =&gt; n,
</span><span class="boring">            };
</span><span class="boring">            if l &gt; r {
</span><span class="boring">                return (l, l);
</span><span class="boring">            }
</span><span class="boring">            (l, r)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn upd(&amp;mut self, k: usize) {
</span><span class="boring">            self.data[k] = (self.op)(self.data[k * 2], self.data[(k * 2) + 1]);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns a new segment tree of size `n` built from `iter`.
</span><span class="boring">        ///
</span><span class="boring">        /// The meanings of parameters and some generic types are as follows.
</span><span class="boring">        /// - `T` is a type of values in the array the segment tree represents.
</span><span class="boring">        /// - `n` is a number of elements in the array.
</span><span class="boring">        /// - `iter` is an iterator returning initial values of the array.
</span><span class="boring">        ///   - If `iter.count() &lt; n`, then the rest is filled with `e`.
</span><span class="boring">        ///   - If `iter.count() &gt; n`, the array is truncated down to the length of `n`.
</span><span class="boring">        /// - `op: impl Fn(T, T) -&gt; T` is a binary operator for `T`.
</span><span class="boring">        /// - `e` is an identity for `op`.
</span><span class="boring">        ///
</span><span class="boring">        /// The following notations will be used from now on.
</span><span class="boring">        /// - `op(a, b)` is denoted as `a*b`.
</span><span class="boring">        ///
</span><span class="boring">        /// Constraints of parameters are as follows.
</span><span class="boring">        /// - `op` and `e` must make `T` a monoid. That is, `op` and `e` should be given so that `T` can satisfy the following conditions.
</span><span class="boring">        ///   - `T` is associative under `op`. That is, `(a*b)*c == a*(b*c)` for all `[a, b, c]: [T; 3]`.
</span><span class="boring">        ///   - `T` has `e` as an identity element under `op`. That is, `a*e == e*a == a` for all `a: T`.
</span><span class="boring">        ///
</span><span class="boring">        /// For example, a generic range sum segment tree with every value initialized with `0` and of length `n` can be constucted as follows.
</span><span class="boring">        /// ```no_run
</span><span class="boring">        /// let mut st = SegTree::new(n, None, 0i64, |x, y| x + y);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(n: usize, iter: impl IntoIterator&lt;Item = T&gt;, e: T, op: O) -&gt; Self {
</span><span class="boring">            let size = n.next_power_of_two();
</span><span class="boring">            let log = size.trailing_zeros();
</span><span class="boring">
</span><span class="boring">            let mut data = vec![e; size];
</span><span class="boring">            data.extend(iter.into_iter().take(n));
</span><span class="boring">            data.resize(2 * size, e);
</span><span class="boring">
</span><span class="boring">            let mut st = Self { n, data, e, op, size, log };
</span><span class="boring">            for i in (1..size).rev() {
</span><span class="boring">                st.upd(i);
</span><span class="boring">            }
</span><span class="boring">            st
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns the length of the array.
</span><span class="boring">        pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">            self.n
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns the `i`-th value of the array.
</span><span class="boring">        pub fn get(&amp;self, i: usize) -&gt; T {
</span><span class="boring">            self.data[i + self.size]
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Assign `upd_to(self.get(i))` to the `i`-th element.
</span><span class="boring">        pub fn update(&amp;mut self, i: usize, upd_to: impl Fn(T) -&gt; T) {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            self.data[i] = upd_to(self.data[i]);
</span><span class="boring">            for j in 1..=self.log {
</span><span class="boring">                self.upd(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns the product of elements in `range`.
</span><span class="boring">        pub fn prod(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; T {
</span><span class="boring">            let (mut l, mut r) = self.get_bounds(range);
</span><span class="boring">            (l += self.size, r += self.size);
</span><span class="boring">
</span><span class="boring">            if (l, r) == (0, self.n) {
</span><span class="boring">                return self.data[1];
</span><span class="boring">            } else if l == r {
</span><span class="boring">                return self.e;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut sml, mut smr) = (self.e, self.e);
</span><span class="boring">            while l &lt; r {
</span><span class="boring">                if l &amp; 1 == 1 {
</span><span class="boring">                    sml = (self.op)(sml, self.data[l]);
</span><span class="boring">                    l += 1;
</span><span class="boring">                }
</span><span class="boring">                if r &amp; 1 == 1 {
</span><span class="boring">                    r -= 1;
</span><span class="boring">                    smr = (self.op)(self.data[r], smr);
</span><span class="boring">                }
</span><span class="boring">                (l &gt;&gt;= 1, r &gt;&gt;= 1);
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            (self.op)(sml, smr)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// For a function `pred` which has a nonnegative value `x`, such that `pred(self.prod(l..r))` is `false` if and only if `x &lt;= r`, `self.partition_point(l, pred)` returns the value of such `x`.
</span><span class="boring">        /// That is, this is the minimum value of `r` such that `pred(self.prod(l..r))` starts to be `false`.
</span><span class="boring">        /// If `pred(self.e)` is `true`, then this function assumes that `pred(self.prod(l..r))` is always `true` for any `r` in range `l..=self.len()` and returns `l`.
</span><span class="boring">        /// However, it's recommended to always set `pred(self.e)` to be `true` to avoid unnecessary case works.
</span><span class="boring">        ///
</span><span class="boring">        /// ## Constraints
</span><span class="boring">        /// - `0 &lt;= l &lt;= self.len()`
</span><span class="boring">        ///
</span><span class="boring">        /// ## Examples
</span><span class="boring">        /// `f(r) := pred(self.prod(l..r))`
</span><span class="boring">        ///
</span><span class="boring">        /// Given that `self.len() == 7`, calling `self.partition_point(0)` returns values written below.
</span><span class="boring">        /// ```text
</span><span class="boring">        ///    r |     0     1     2     3     4     5     6     7     8
</span><span class="boring">        ///
</span><span class="boring">        /// f(r) |  true  true  true  true false false false false   N/A
</span><span class="boring">        ///                             returns^
</span><span class="boring">        ///
</span><span class="boring">        /// f(r) | false false false false false false false false   N/A
</span><span class="boring">        ///     returns^
</span><span class="boring">        ///
</span><span class="boring">        /// f(r) |  true  true  true  true  true  true  true  true   N/A
</span><span class="boring">        ///                                                     returns^
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn partition_point(&amp;self, l: usize, pred: impl Fn(T) -&gt; bool) -&gt; usize {
</span><span class="boring">            if !pred(self.e) {
</span><span class="boring">                // `pred(self.prod(l..l))` is `false`
</span><span class="boring">                // Thus l is returned.
</span><span class="boring">                // This case is not covered in the original implementation as it simply requires pred(self.e) to be `true`
</span><span class="boring">                return l;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            if l == self.n {
</span><span class="boring">                // `pred(self.e)` has already been checked that it's `true`.
</span><span class="boring">                // Thus the answer must be `self.n`.
</span><span class="boring">                return self.n;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut l = l + self.size;
</span><span class="boring">            let mut sm = self.e;
</span><span class="boring">
</span><span class="boring">            loop {
</span><span class="boring">                l &gt;&gt;= l.trailing_zeros();
</span><span class="boring">                if !pred((self.op)(sm, self.data[l])) {
</span><span class="boring">                    while l &lt; self.size {
</span><span class="boring">                        l &lt;&lt;= 1;
</span><span class="boring">                        let tmp = (self.op)(sm, self.data[l]);
</span><span class="boring">                        if pred(tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            l += 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return l + 1 - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm = (self.op)(sm, self.data[l]);
</span><span class="boring">                l += 1;
</span><span class="boring">                if l &amp; ((!l) + 1) == l {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            self.n + 1
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// For a function `pred` which has a value `x` less than or equal to `r`, such that `pred(self.prod(l..r))` is `true` if and only if `x &lt;= l`, `self.left_partition_point(r, pred)` returns the value of such `x`.
</span><span class="boring">        /// That is, this is the minimum value of `l` such that `pred(self.prod(l..r))` starts to be `true`.
</span><span class="boring">        /// If `pred(self.e)` is `false`, then this function assumes that `pred(self.prod(l..r))` is always `false` for any `l` in range `0..=r` and returns `r+1`.
</span><span class="boring">        /// However, it's recommended to always set `pred(self.e)` to be `true` to avoid unnecessary case works.
</span><span class="boring">        ///
</span><span class="boring">        /// ## Constraints
</span><span class="boring">        /// - `0 &lt;= r &lt;= self.len()`
</span><span class="boring">        ///
</span><span class="boring">        /// ## Examples
</span><span class="boring">        /// `f(l) := pred(self.prod(l..r))`
</span><span class="boring">        ///
</span><span class="boring">        /// Calling `self.left_partition_point(7)` returns values written below.
</span><span class="boring">        /// ```text
</span><span class="boring">        ///    l |     0     1     2     3     4     5     6     7     8
</span><span class="boring">        ///
</span><span class="boring">        /// f(l) | false false false false  true  true  true  true   N/A
</span><span class="boring">        ///                             returns^
</span><span class="boring">        ///
</span><span class="boring">        /// f(l) |  true  true  true  true  true  true  true  true   N/A
</span><span class="boring">        ///     returns^
</span><span class="boring">        ///
</span><span class="boring">        /// f(l) | false false false false false false false false   N/A
</span><span class="boring">        ///                                                     returns^
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn left_partition_point(&amp;self, r: usize, pred: impl Fn(T) -&gt; bool) -&gt; usize {
</span><span class="boring">            if !pred(self.e) {
</span><span class="boring">                return r + 1;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            if r == 0 {
</span><span class="boring">                // `pred(self.e)` is always `true` at this point
</span><span class="boring">                return 0;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut r = r + self.size;
</span><span class="boring">            let mut sm = self.e;
</span><span class="boring">
</span><span class="boring">            loop {
</span><span class="boring">                r -= 1;
</span><span class="boring">                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
</span><span class="boring">                    r &gt;&gt;= 1;
</span><span class="boring">                }
</span><span class="boring">                if !pred((self.op)(self.data[r], sm)) {
</span><span class="boring">                    while r &lt; self.size {
</span><span class="boring">                        r = (r &lt;&lt; 1) + 1;
</span><span class="boring">                        let tmp = (self.op)(self.data[r], sm);
</span><span class="boring">                        if pred(tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            r -= 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return r + 1 - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm = (self.op)(self.data[r], sm);
</span><span class="boring">                if r &amp; ((!r) + 1) == r {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            0
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-10"><a class="header" href="#code-10">Code</a></h2>
<pre><code class="language-rust noplayground">mod segtree {
    use std::ops::RangeBounds;

    /// A segment tree is a data structure for a monoid type `T`.
    ///
    /// Given all the constraints written in the comment of `SegTree::new`, a segment tree can process the following queries in O(TlogN) time assuming `op` all run in O(T).
    /// - Changing the value of an element
    /// - Calculating the product of elements in an interval, combined with `op`
    pub struct SegTree&lt;T, O&gt; {
        n: usize,
        data: Vec&lt;T&gt;,
        e: T,
        op: O,
        size: usize,
        log: u32,
    }

    impl&lt;T: Copy, O: Fn(T, T) -&gt; T&gt; SegTree&lt;T, O&gt; {
        fn get_bounds(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; (usize, usize) {
            use std::ops::Bound::*;
            let n = self.len();
            let l = match range.start_bound() {
                Included(&amp;v) =&gt; v,
                Excluded(&amp;v) =&gt; v + 1,
                Unbounded =&gt; 0,
            };
            let r = match range.end_bound() {
                Included(&amp;v) =&gt; (v + 1).min(n),
                Excluded(&amp;v) =&gt; v.min(n),
                Unbounded =&gt; n,
            };
            if l &gt; r {
                return (l, l);
            }
            (l, r)
        }

        fn upd(&amp;mut self, k: usize) {
            self.data[k] = (self.op)(self.data[k * 2], self.data[(k * 2) + 1]);
        }

        /// Returns a new segment tree of size `n` built from `iter`.
        ///
        /// The meanings of parameters and some generic types are as follows.
        /// - `T` is a type of values in the array the segment tree represents.
        /// - `n` is a number of elements in the array.
        /// - `iter` is an iterator returning initial values of the array.
        ///   - If `iter.count() &lt; n`, then the rest is filled with `e`.
        ///   - If `iter.count() &gt; n`, the array is truncated down to the length of `n`.
        /// - `op: impl Fn(T, T) -&gt; T` is a binary operator for `T`.
        /// - `e` is an identity for `op`.
        ///
        /// The following notations will be used from now on.
        /// - `op(a, b)` is denoted as `a*b`.
        ///
        /// Constraints of parameters are as follows.
        /// - `op` and `e` must make `T` a monoid. That is, `op` and `e` should be given so that `T` can satisfy the following conditions.
        ///   - `T` is associative under `op`. That is, `(a*b)*c == a*(b*c)` for all `[a, b, c]: [T; 3]`.
        ///   - `T` has `e` as an identity element under `op`. That is, `a*e == e*a == a` for all `a: T`.
        ///
        /// For example, a generic range sum segment tree with every value initialized with `0` and of length `n` can be constucted as follows.
        /// ```no_run
        /// let mut st = SegTree::new(n, None, 0i64, |x, y| x + y);
        /// ```
        pub fn new(n: usize, iter: impl IntoIterator&lt;Item = T&gt;, e: T, op: O) -&gt; Self {
            let size = n.next_power_of_two();
            let log = size.trailing_zeros();

            let mut data = vec![e; size];
            data.extend(iter.into_iter().take(n));
            data.resize(2 * size, e);

            let mut st = Self { n, data, e, op, size, log };
            for i in (1..size).rev() {
                st.upd(i);
            }
            st
        }

        /// Returns the length of the array.
        pub fn len(&amp;self) -&gt; usize {
            self.n
        }

        /// Returns the `i`-th value of the array.
        pub fn get(&amp;self, i: usize) -&gt; T {
            self.data[i + self.size]
        }

        /// Assign `upd_to(self.get(i))` to the `i`-th element.
        pub fn update(&amp;mut self, i: usize, upd_to: impl Fn(T) -&gt; T) {
            let i = i + self.size;
            self.data[i] = upd_to(self.data[i]);
            for j in 1..=self.log {
                self.upd(i &gt;&gt; j);
            }
        }

        /// Returns the product of elements in `range`.
        pub fn prod(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; T {
            let (mut l, mut r) = self.get_bounds(range);
            (l += self.size, r += self.size);

            if (l, r) == (0, self.n) {
                return self.data[1];
            } else if l == r {
                return self.e;
            }

            let (mut sml, mut smr) = (self.e, self.e);
            while l &lt; r {
                if l &amp; 1 == 1 {
                    sml = (self.op)(sml, self.data[l]);
                    l += 1;
                }
                if r &amp; 1 == 1 {
                    r -= 1;
                    smr = (self.op)(self.data[r], smr);
                }
                (l &gt;&gt;= 1, r &gt;&gt;= 1);
            }

            (self.op)(sml, smr)
        }

        /// For a function `pred` which has a nonnegative value `x`, such that `pred(self.prod(l..r))` is `false` if and only if `x &lt;= r`, `self.partition_point(l, pred)` returns the value of such `x`.
        /// That is, this is the minimum value of `r` such that `pred(self.prod(l..r))` starts to be `false`.
        /// If `pred(self.e)` is `true`, then this function assumes that `pred(self.prod(l..r))` is always `true` for any `r` in range `l..=self.len()` and returns `l`.
        /// However, it's recommended to always set `pred(self.e)` to be `true` to avoid unnecessary case works.
        ///
        /// ## Constraints
        /// - `0 &lt;= l &lt;= self.len()`
        ///
        /// ## Examples
        /// `f(r) := pred(self.prod(l..r))`
        ///
        /// Given that `self.len() == 7`, calling `self.partition_point(0)` returns values written below.
        /// ```text
        ///    r |     0     1     2     3     4     5     6     7     8
        ///
        /// f(r) |  true  true  true  true false false false false   N/A
        ///                             returns^
        ///
        /// f(r) | false false false false false false false false   N/A
        ///     returns^
        ///
        /// f(r) |  true  true  true  true  true  true  true  true   N/A
        ///                                                     returns^
        /// ```
        pub fn partition_point(&amp;self, l: usize, pred: impl Fn(T) -&gt; bool) -&gt; usize {
            if !pred(self.e) {
                // `pred(self.prod(l..l))` is `false`
                // Thus l is returned.
                // This case is not covered in the original implementation as it simply requires pred(self.e) to be `true`
                return l;
            }

            if l == self.n {
                // `pred(self.e)` has already been checked that it's `true`.
                // Thus the answer must be `self.n`.
                return self.n;
            }

            let mut l = l + self.size;
            let mut sm = self.e;

            loop {
                l &gt;&gt;= l.trailing_zeros();
                if !pred((self.op)(sm, self.data[l])) {
                    while l &lt; self.size {
                        l &lt;&lt;= 1;
                        let tmp = (self.op)(sm, self.data[l]);
                        if pred(tmp) {
                            sm = tmp;
                            l += 1;
                        }
                    }
                    return l + 1 - self.size;
                }
                sm = (self.op)(sm, self.data[l]);
                l += 1;
                if l &amp; ((!l) + 1) == l {
                    break;
                }
            }
            self.n + 1
        }

        /// For a function `pred` which has a value `x` less than or equal to `r`, such that `pred(self.prod(l..r))` is `true` if and only if `x &lt;= l`, `self.left_partition_point(r, pred)` returns the value of such `x`.
        /// That is, this is the minimum value of `l` such that `pred(self.prod(l..r))` starts to be `true`.
        /// If `pred(self.e)` is `false`, then this function assumes that `pred(self.prod(l..r))` is always `false` for any `l` in range `0..=r` and returns `r+1`.
        /// However, it's recommended to always set `pred(self.e)` to be `true` to avoid unnecessary case works.
        ///
        /// ## Constraints
        /// - `0 &lt;= r &lt;= self.len()`
        ///
        /// ## Examples
        /// `f(l) := pred(self.prod(l..r))`
        ///
        /// Calling `self.left_partition_point(7)` returns values written below.
        /// ```text
        ///    l |     0     1     2     3     4     5     6     7     8
        ///
        /// f(l) | false false false false  true  true  true  true   N/A
        ///                             returns^
        ///
        /// f(l) |  true  true  true  true  true  true  true  true   N/A
        ///     returns^
        ///
        /// f(l) | false false false false false false false false   N/A
        ///                                                     returns^
        /// ```
        pub fn left_partition_point(&amp;self, r: usize, pred: impl Fn(T) -&gt; bool) -&gt; usize {
            if !pred(self.e) {
                return r + 1;
            }

            if r == 0 {
                // `pred(self.e)` is always `true` at this point
                return 0;
            }

            let mut r = r + self.size;
            let mut sm = self.e;

            loop {
                r -= 1;
                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                    r &gt;&gt;= 1;
                }
                if !pred((self.op)(self.data[r], sm)) {
                    while r &lt; self.size {
                        r = (r &lt;&lt; 1) + 1;
                        let tmp = (self.op)(self.data[r], sm);
                        if pred(tmp) {
                            sm = tmp;
                            r -= 1;
                        }
                    }
                    return r + 1 - self.size;
                }
                sm = (self.op)(self.data[r], sm);
                if r &amp; ((!r) + 1) == r {
                    break;
                }
            }
            0
        }
    }
}</code></pre>
<hr />
<p>Last modified on 231007</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fenwick-tree"><a class="header" href="#fenwick-tree">Fenwick Tree</a></h1>
<p>Given an integer array \(A\) of length \(n\), a Fenwick tree processes the following queries in \(O(\log{n})\) time:</p>
<ul>
<li>Add a certain amount to an element</li>
<li>Calculate the sum of the elements of an interval</li>
</ul>
<p>A Fenwick tree uses half the memory of a segment tree, but the performance in terms of time is just about the same.</p>
<p>A type of elements of \(A\) must be a primitive signed integer type, such as <code>i32</code> and <code>i64</code>, and floats such as <code>f64</code>. Unsigned integer types like <code>u64</code> do not work. Specifically, the type should implement <code>From&lt;i8&gt;</code>.</p>
<h2 id="example-12"><a class="header" href="#example-12">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut fw: Fenwick&lt;i32&gt; = Fenwick::new(10);
for i in 0..10 {
    print!(&quot;{} &quot;, fw.get(i));
}
println!(); // 0 0 0 0 0 0 0 0 0 0
fw.add(2, 10);
fw.add(5, 100);
fw.add(3, -1);
for i in 0..10 {
    print!(&quot;{} &quot;, fw.get(i));
}
println!(); // 0 0 10 -1 0 100 0 0 0 0
println!(&quot;{}&quot;, fw.sum(3..8)); // 99
<span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Fenwick&lt;T&gt; {
</span><span class="boring">    n: usize,
</span><span class="boring">    data: Vec&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Copy + From&lt;i8&gt; + std::ops::AddAssign + std::ops::Sub&lt;Output = T&gt;&gt; Fenwick&lt;T&gt; {
</span><span class="boring">    fn new(n: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            data: vec![0.into(); n],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add(&amp;mut self, idx: usize, val: T) {
</span><span class="boring">        let mut idx = idx + 1;
</span><span class="boring">        while idx &lt;= self.n {
</span><span class="boring">            self.data[idx - 1] += val;
</span><span class="boring">            idx += idx &amp; (!idx + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self, idx: usize) -&gt; T {
</span><span class="boring">        self.sum(idx..=idx)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn sum(&amp;self, range: impl std::ops::RangeBounds&lt;usize&gt;) -&gt; T {
</span><span class="boring">        use std::ops::Bound::*;
</span><span class="boring">        let l = match range.start_bound() {
</span><span class="boring">            Included(&amp;v) =&gt; v,
</span><span class="boring">            Excluded(&amp;v) =&gt; v + 1,
</span><span class="boring">            Unbounded =&gt; 0,
</span><span class="boring">        };
</span><span class="boring">        let r = match range.end_bound() {
</span><span class="boring">            Included(&amp;v) =&gt; v + 1,
</span><span class="boring">            Excluded(&amp;v) =&gt; v,
</span><span class="boring">            Unbounded =&gt; self.n,
</span><span class="boring">        };
</span><span class="boring">        self.inner_sum(r) - self.inner_sum(l)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn inner_sum(&amp;self, mut r: usize) -&gt; T {
</span><span class="boring">        let mut s: T = 0.into();
</span><span class="boring">        while r &gt; 0 {
</span><span class="boring">            s += self.data[r - 1];
</span><span class="boring">            r -= r &amp; (!r + 1);
</span><span class="boring">        }
</span><span class="boring">        s
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-11"><a class="header" href="#code-11">Code</a></h2>
<pre><code class="language-rust noplayground">struct Fenwick&lt;T&gt; {
	n: usize,
	data: Vec&lt;T&gt;,
}

impl&lt;T: Copy + From&lt;i8&gt; + std::ops::AddAssign + std::ops::Sub&lt;Output = T&gt;&gt; Fenwick&lt;T&gt; {
	fn new(n: usize) -&gt; Self {
		Self { n, data: vec![0.into(); n] }
	}

	fn add(&amp;mut self, idx: usize, val: T) {
		let mut idx = idx + 1;
		while idx &lt;= self.n {
			self.data[idx - 1] += val;
			idx += idx &amp; (!idx + 1);
		}
	}

	fn get(&amp;self, idx: usize) -&gt; T {
		self.sum(idx..=idx)
	}

	fn sum(&amp;self, range: impl std::ops::RangeBounds&lt;usize&gt;) -&gt; T {
		use std::ops::Bound::*;
		let l = match range.start_bound() {
			Included(&amp;v) =&gt; v,
			Excluded(&amp;v) =&gt; v + 1,
			Unbounded =&gt; 0,
		};
		let r = match range.end_bound() {
			Included(&amp;v) =&gt; v + 1,
			Excluded(&amp;v) =&gt; v,
			Unbounded =&gt; self.n,
		};
		self.inner_sum(r) - self.inner_sum(l)
	}

	fn inner_sum(&amp;self, mut r: usize) -&gt; T {
		let mut s: T = 0.into();
		while r &gt; 0 {
			s += self.data[r - 1];
			r -= r &amp; (!r + 1);
		}
		s
	}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-segment-tree"><a class="header" href="#lazy-segment-tree">Lazy Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A lazy segment tree is a data struture for a pair of a <a href="datastructure/segtree/./segtree.html">monoid</a> \( (T, \cdot : T \times T \rightarrow T, e \in T) \) and a set \(F\) of \(T \rightarrow T\) mappings that satisfies the following properties:</p>
<ul>
<li>\(F\) contains the identity mapping \(Id\) such that \( Id(x) = x \) for all \(x\in T\).</li>
<li>\(F\) is closed under composition. That is, \( f \circ g \in F \) for all \( f, g \in F \).</li>
<li>\( f (x \cdot y) = f(x) \cdot f(y) \) hold for all \(f \in F \) and \( x, y \in T \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(T\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Apply the mapping \( f \in F \) on all the elements of an interval</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<h2 id="example-13"><a class="header" href="#example-13">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use lazyseg::*;

<span class="boring">fn main() {
</span>// Generic range addition, range sum lazy segment tree
let mut ls = LazySeg::new(
    10,
    (0..10).map(|i| (i, 1)),
    |(x, l), (y, m)| (x + y, l + m),
    (0i64, 0i64),
    |a, (x, l)| (x + a * l, l),
    |a, b| a + b,
    0i64,
);

println!(&quot;{}&quot;, ls.prod(2..8).0); // 27
ls.apply_range(3..6, 3);
println!(&quot;{}&quot;, ls.prod(2..8).0); // 36

for r in 3..=10 {
    print!(&quot;{} &quot;, ls.prod(3..r).0);
}
println!(); // 0 6 13 21 27 34 42 51
println!(&quot;{}&quot;, ls.partition_point(3, |(x, _)| x &lt; 40)); // 9

for l in 0..=7 {
    print!(&quot;{} &quot;, ls.prod(l..7).0);
}
println!(); // 30 30 29 27 21 14 6 0
println!(&quot;{}&quot;, ls.left_partition_point(7, |(x, _)| x &lt; 25)); // 4
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod lazyseg {
</span><span class="boring">    use std::ops::RangeBounds;
</span><span class="boring">
</span><span class="boring">    /// A lazy segment tree is a data structure for a monoid type `T` and a mapping `F` that maps a `T` value to another `T` value.
</span><span class="boring">    ///
</span><span class="boring">    /// Given all the constraints written in the comments of `LazySeg::new`, a lazy segment tree can process the following queries in O(TlogN) time assuming `op`, `map`, `compos` all run in O(T).
</span><span class="boring">    /// - Applying the map `f: U` onto all the elements in an interval
</span><span class="boring">    /// - Calculating the product of elements in an interval, combined with `op`
</span><span class="boring">    pub struct LazySeg&lt;T, O, F, M, C&gt; {
</span><span class="boring">        n: usize,
</span><span class="boring">        data: Vec&lt;T&gt;,
</span><span class="boring">        lazy: Vec&lt;F&gt;,
</span><span class="boring">        e: T,
</span><span class="boring">        op: O,
</span><span class="boring">        id: F,
</span><span class="boring">        map: M,
</span><span class="boring">        compos: C,
</span><span class="boring">        size: usize,
</span><span class="boring">        log: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;T, O, F, M, C&gt; LazySeg&lt;T, O, F, M, C&gt;
</span><span class="boring">    where
</span><span class="boring">        T: Copy,
</span><span class="boring">        O: Fn(T, T) -&gt; T,
</span><span class="boring">        F: Copy,
</span><span class="boring">        M: Fn(F, T) -&gt; T,
</span><span class="boring">        C: Fn(F, F) -&gt; F,
</span><span class="boring">    {
</span><span class="boring">        fn get_bounds(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; (usize, usize) {
</span><span class="boring">            use std::ops::Bound::*;
</span><span class="boring">            let n = self.len();
</span><span class="boring">            let l = match range.start_bound() {
</span><span class="boring">                Included(&amp;v) =&gt; v,
</span><span class="boring">                Excluded(&amp;v) =&gt; v + 1,
</span><span class="boring">                Unbounded =&gt; 0,
</span><span class="boring">            };
</span><span class="boring">            let r = match range.end_bound() {
</span><span class="boring">                Included(&amp;v) =&gt; (v + 1).min(n),
</span><span class="boring">                Excluded(&amp;v) =&gt; v.min(n),
</span><span class="boring">                Unbounded =&gt; n,
</span><span class="boring">            };
</span><span class="boring">            if l &gt; r {
</span><span class="boring">                return (l, l);
</span><span class="boring">            }
</span><span class="boring">            (l, r)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn upd(&amp;mut self, k: usize) {
</span><span class="boring">            self.data[k] = (self.op)(self.data[k * 2], self.data[k * 2 + 1]);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn all_apply(&amp;mut self, k: usize, f: F) {
</span><span class="boring">            self.data[k] = (self.map)(f, self.data[k]);
</span><span class="boring">            if k &lt; self.size {
</span><span class="boring">                self.lazy[k] = (self.compos)(f, self.lazy[k]);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn push(&amp;mut self, k: usize) {
</span><span class="boring">            self.all_apply(k * 2, self.lazy[k]);
</span><span class="boring">            self.all_apply(k * 2 + 1, self.lazy[k]);
</span><span class="boring">            self.lazy[k] = self.id;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns a new lazy segment tree of size `n` built from `iter`.
</span><span class="boring">        ///
</span><span class="boring">        /// The meanings of parameters and some generic types are as follows.
</span><span class="boring">        /// - `T` is a type of values in the array the lazy segment tree represents.
</span><span class="boring">        /// - `F` is a type of mappings for the array.
</span><span class="boring">        /// - `n` is a number of elements in the array.
</span><span class="boring">        /// - `iter` is an iterator returning initial values of the array.
</span><span class="boring">        ///   - If `iter.count() &lt; n`, then the rest is filled with `e`.
</span><span class="boring">        ///   - If `iter.count() &gt; n`, the array is truncated down to the length of `n`.
</span><span class="boring">        /// - `op: impl Fn(T, T) -&gt; T` is a binary operator for `T`.
</span><span class="boring">        /// - `e` is an identity for `op`.
</span><span class="boring">        /// - `map: impl Fn(F, T) -&gt; T` defines how to map `T` to another `T` based on the `F` value.
</span><span class="boring">        /// - `compos: impl Fn(F, F) -&gt; F` defines how to compose two `F`'s.
</span><span class="boring">        /// - `id` defines an identity for `compos`.
</span><span class="boring">        ///
</span><span class="boring">        /// The following notations will be used from now on.
</span><span class="boring">        /// - `op(a, b)` is denoted as `a*b`.
</span><span class="boring">        /// - `map(f, a)` is denoted as `f.a`.
</span><span class="boring">        /// - `map(g, map(f, a))` is denoted as `g.f.a`.
</span><span class="boring">        ///
</span><span class="boring">        /// Constraints of parameters are as follows.
</span><span class="boring">        /// - `op` and `e` must make `T` a monoid. That is, `op` and `e` should be given so that `T` can satisfy the following conditions.
</span><span class="boring">        ///   - `T` is associative under `op`. That is, `(a*b)*c == a*(b*c)` for all `[a, b, c]: [T; 3]`.
</span><span class="boring">        ///   - `T` has `e` as an identity element under `op`. That is, `a*e == e*a == a` for all `a: T`.
</span><span class="boring">        /// - `map`, `compos`, and `id` must satisfy the following conditions.
</span><span class="boring">        ///   - `compos` should be properly defined. That is, if `compos(g, f) == h`, then `g.f.a == h.a` must hold.
</span><span class="boring">        ///   - `id` must be a proper identity for `F` under `compos`. That is, `f.id.a == id.f.a == f.a` for all `a: T` and `f: F`.
</span><span class="boring">        ///   - IMPORTANT: `map` must satisfy `f.(x*y) == f.x * f.y`.
</span><span class="boring">        ///
</span><span class="boring">        /// For example, a generic range addition range sum lazy segment tree with every value initialized with `0` and of length `n` can be constructed as follows.
</span><span class="boring">        /// ```no_run
</span><span class="boring">        /// let mut ls = LazySeg::new(
</span><span class="boring">        ///     n,
</span><span class="boring">        ///     (0..n).map(|_| (0, 1)),
</span><span class="boring">        ///     |(x, l), (y, m)| (x + y, l + m),
</span><span class="boring">        ///     (0i64, 0i64),
</span><span class="boring">        ///     |a, (x, l)| (x + a * l, l),
</span><span class="boring">        ///     |a, b| a + b,
</span><span class="boring">        ///     0i64,
</span><span class="boring">        /// );
</span><span class="boring">        /// ```
</span><span class="boring">        /// A so-called &quot;ax+b&quot; lazy segment tree starting with an array of `vec![0; n]` can be constructed as follows.
</span><span class="boring">        /// ```no_run
</span><span class="boring">        /// let mut ls = LazySeg::new(
</span><span class="boring">        ///     n,
</span><span class="boring">        ///     (0..n).map(|_| (0, 1)),
</span><span class="boring">        ///     |(x, l), (y, m)| (x + y, l + m),
</span><span class="boring">        ///     (0i64, 0i64),
</span><span class="boring">        ///     |(a, b), (x, l)| (a * x, b * l),
</span><span class="boring">        ///     |(a, b), (c, d)| (a * c, a * d + b),
</span><span class="boring">        ///     (1i64, 0i64),
</span><span class="boring">        /// );
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(n: usize, iter: impl IntoIterator&lt;Item = T&gt;, op: O, e: T, map: M, compos: C, id: F) -&gt; Self {
</span><span class="boring">            let size = n.next_power_of_two();
</span><span class="boring">            let log = size.trailing_zeros();
</span><span class="boring">
</span><span class="boring">            let mut data = vec![e; size];
</span><span class="boring">            data.extend(iter.into_iter().take(n));
</span><span class="boring">            data.resize(2 * size, e);
</span><span class="boring">
</span><span class="boring">            let mut ls = Self {
</span><span class="boring">                n,
</span><span class="boring">                data,
</span><span class="boring">                lazy: vec![id; size],
</span><span class="boring">                e,
</span><span class="boring">                op,
</span><span class="boring">                id,
</span><span class="boring">                map,
</span><span class="boring">                compos,
</span><span class="boring">                size,
</span><span class="boring">                log,
</span><span class="boring">            };
</span><span class="boring">            for i in (1..size).rev() {
</span><span class="boring">                ls.upd(i);
</span><span class="boring">            }
</span><span class="boring">            ls
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns the length of the array.
</span><span class="boring">        pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">            self.n
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns the `i`-th value of the array.
</span><span class="boring">        pub fn get(&amp;mut self, i: usize) -&gt; T {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            for j in (1..=self.log).rev() {
</span><span class="boring">                self.push(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">            self.data[i]
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Assign `upd_to(self.get(i))` to the `i`-th element.
</span><span class="boring">        pub fn update(&amp;mut self, i: usize, upd_to: impl Fn(T) -&gt; T) {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            for j in (1..=self.log).rev() {
</span><span class="boring">                self.push(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">            self.data[i] = upd_to(self.data[i]);
</span><span class="boring">            for j in 1..=self.log {
</span><span class="boring">                self.upd(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns the product of elements in `range`.
</span><span class="boring">        pub fn prod(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; T {
</span><span class="boring">            let (l, r) = self.get_bounds(range);
</span><span class="boring">
</span><span class="boring">            if l == 0 &amp;&amp; r == self.size {
</span><span class="boring">                let ret = (self.op)(self.e, self.data[1]);
</span><span class="boring">                return ret;
</span><span class="boring">            } else if l == r {
</span><span class="boring">                return self.e;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut l, mut r) = (l + self.size, r + self.size);
</span><span class="boring">
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                if ((l &gt;&gt; i) &lt;&lt; i) != l {
</span><span class="boring">                    self.push(l &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">                if ((r &gt;&gt; i) &lt;&lt; i) != r {
</span><span class="boring">                    self.push((r - 1) &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut sml, mut smr) = (self.e, self.e);
</span><span class="boring">            while l &lt; r {
</span><span class="boring">                if l &amp; 1 == 1 {
</span><span class="boring">                    sml = (self.op)(sml, self.data[l]);
</span><span class="boring">                    l += 1;
</span><span class="boring">                }
</span><span class="boring">                if r &amp; 1 == 1 {
</span><span class="boring">                    r -= 1;
</span><span class="boring">                    smr = (self.op)(self.data[r], smr);
</span><span class="boring">                }
</span><span class="boring">                (l &gt;&gt;= 1, r &gt;&gt;= 1);
</span><span class="boring">            }
</span><span class="boring">            (self.op)(sml, smr)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Changes every element `x` in `range` of the array to `map.x`.
</span><span class="boring">        pub fn apply_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;, map: F) {
</span><span class="boring">            let (l, r) = self.get_bounds(range);
</span><span class="boring">            if l &gt;= r {
</span><span class="boring">                return;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut l, mut r) = (l + self.size, r + self.size);
</span><span class="boring">
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                if ((l &gt;&gt; i) &lt;&lt; i) != l {
</span><span class="boring">                    self.push(l &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">                if ((r &gt;&gt; i) &lt;&lt; i) != r {
</span><span class="boring">                    self.push((r - 1) &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (l2, r2) = (l, r);
</span><span class="boring">            while l &lt; r {
</span><span class="boring">                if l &amp; 1 == 1 {
</span><span class="boring">                    self.all_apply(l, map);
</span><span class="boring">                    l += 1;
</span><span class="boring">                }
</span><span class="boring">                if r &amp; 1 == 1 {
</span><span class="boring">                    r -= 1;
</span><span class="boring">                    self.all_apply(r, map);
</span><span class="boring">                }
</span><span class="boring">                l &gt;&gt;= 1;
</span><span class="boring">                r &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">            l = l2;
</span><span class="boring">            r = r2;
</span><span class="boring">
</span><span class="boring">            for i in 1..=self.log {
</span><span class="boring">                if ((l &gt;&gt; i) &lt;&lt; i) != l {
</span><span class="boring">                    self.upd(l &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">                if ((r &gt;&gt; i) &lt;&lt; i) != r {
</span><span class="boring">                    self.upd((r - 1) &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// For a function `pred` which has a nonnegative value `x`, such that `pred(self.prod(l..r))` is `false` if and only if `x &lt;= r`, `self.partition_point(l, pred)` returns the value of such `x`.
</span><span class="boring">        /// That is, this is the minimum value of `r` such that `pred(self.prod(l..r))` starts to be `false`.
</span><span class="boring">        /// If `pred(self.e)` is `true`, then this function assumes that `pred(self.prod(l..r))` is always `true` for any `r` in range `l..=self.len()` and returns `l`.
</span><span class="boring">        /// However, it's recommended to always set `pred(self.e)` to be `true` to avoid unnecessary case works.
</span><span class="boring">        ///
</span><span class="boring">        /// ## Constraints
</span><span class="boring">        /// - `0 &lt;= l &lt;= self.len()`
</span><span class="boring">        ///
</span><span class="boring">        /// ## Examples
</span><span class="boring">        /// `f(r) := pred(self.prod(l..r))`
</span><span class="boring">        ///
</span><span class="boring">        /// Given that `self.len() == 7`, calling `self.partition_point(0)` returns values written below.
</span><span class="boring">        /// ```text
</span><span class="boring">        ///    r |     0     1     2     3     4     5     6     7     8
</span><span class="boring">        ///
</span><span class="boring">        /// f(r) |  true  true  true  true false false false false   N/A
</span><span class="boring">        ///                             returns^
</span><span class="boring">        ///
</span><span class="boring">        /// f(r) | false false false false false false false false   N/A
</span><span class="boring">        ///     returns^
</span><span class="boring">        ///
</span><span class="boring">        /// f(r) |  true  true  true  true  true  true  true  true   N/A
</span><span class="boring">        ///                                                     returns^
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn partition_point(&amp;mut self, l: usize, pred: impl Fn(T) -&gt; bool) -&gt; usize {
</span><span class="boring">            if !pred(self.e) {
</span><span class="boring">                return l;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            if l == self.n {
</span><span class="boring">                // `pred(self.e)` has already been checked that it's `true`.
</span><span class="boring">                return self.n;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut l = l + self.size;
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                self.push(l &gt;&gt; i);
</span><span class="boring">            }
</span><span class="boring">            let mut sm = self.e;
</span><span class="boring">
</span><span class="boring">            loop {
</span><span class="boring">                l &gt;&gt;= l.trailing_zeros();
</span><span class="boring">                if !pred((self.op)(sm, self.data[l])) {
</span><span class="boring">                    while l &lt; self.size {
</span><span class="boring">                        self.push(l);
</span><span class="boring">                        l &lt;&lt;= 1;
</span><span class="boring">                        let tmp = (self.op)(sm, self.data[l]);
</span><span class="boring">                        if pred(tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            l += 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return l + 1 - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm = (self.op)(sm, self.data[l]);
</span><span class="boring">                l += 1;
</span><span class="boring">                if l &amp; ((!l) + 1) == l {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            self.n + 1
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// For a function `pred` which has a value `x` less than or equal to `r`, such that `pred(self.prod(l..r))` is `true` if and only if `x &lt;= l`, `self.left_partition_point(r, pred)` returns the value of such `x`.
</span><span class="boring">        /// That is, this is the minimum value of `l` such that `pred(self.prod(l..r))` starts to be `true`.
</span><span class="boring">        /// If `pred(self.e)` is `false`, then this function assumes that `pred(self.prod(l..r))` is always `false` for any `l` in range `0..=r` and returns `r+1`.
</span><span class="boring">        /// However, it's recommended to always set `pred(self.e)` to be `true` to avoid unnecessary case works.
</span><span class="boring">        ///
</span><span class="boring">        /// ## Constraints
</span><span class="boring">        /// - `0 &lt;= r &lt;= self.len()`
</span><span class="boring">        ///
</span><span class="boring">        /// ## Examples
</span><span class="boring">        /// `f(l) := pred(self.prod(l..r))`
</span><span class="boring">        ///
</span><span class="boring">        /// Calling `self.left_partition_point(7)` returns values written below.
</span><span class="boring">        /// ```text
</span><span class="boring">        ///    l |     0     1     2     3     4     5     6     7     8
</span><span class="boring">        ///
</span><span class="boring">        /// f(l) | false false false false  true  true  true  true   N/A
</span><span class="boring">        ///                             returns^
</span><span class="boring">        ///
</span><span class="boring">        /// f(l) |  true  true  true  true  true  true  true  true   N/A
</span><span class="boring">        ///     returns^
</span><span class="boring">        ///
</span><span class="boring">        /// f(l) | false false false false false false false false   N/A
</span><span class="boring">        ///                                                     returns^
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn left_partition_point(&amp;mut self, r: usize, pred: impl Fn(T) -&gt; bool) -&gt; usize {
</span><span class="boring">            if !pred(self.e) {
</span><span class="boring">                return r + 1;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            if r == 0 {
</span><span class="boring">                // `pred(self.e)` has already been checked that it's `true`.
</span><span class="boring">                return 0;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut r = r + self.size;
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                self.push((r - 1) &gt;&gt; i);
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut sm = self.e;
</span><span class="boring">            loop {
</span><span class="boring">                r -= 1;
</span><span class="boring">                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
</span><span class="boring">                    r &gt;&gt;= 1;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                if !pred((self.op)(self.data[r], sm)) {
</span><span class="boring">                    while r &lt; self.size {
</span><span class="boring">                        self.push(r);
</span><span class="boring">                        r = (r &lt;&lt; 1) + 1;
</span><span class="boring">                        let tmp = (self.op)(self.data[r], sm);
</span><span class="boring">                        if pred(tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            r -= 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return r + 1 - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm = (self.op)(self.data[r], sm);
</span><span class="boring">                if r &amp; ((!r) + 1) == r {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            0
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-12"><a class="header" href="#code-12">Code</a></h2>
<pre><code class="language-rust noplayground">mod lazyseg {
    use std::ops::RangeBounds;

    /// A lazy segment tree is a data structure for a monoid type `T` and a mapping `F` that maps a `T` value to another `T` value.
    ///
    /// Given all the constraints written in the comments of `LazySeg::new`, a lazy segment tree can process the following queries in O(TlogN) time assuming `op`, `map`, `compos` all run in O(T).
    /// - Applying the map `f: U` onto all the elements in an interval
    /// - Calculating the product of elements in an interval, combined with `op`
    pub struct LazySeg&lt;T, O, F, M, C&gt; {
        n: usize,
        data: Vec&lt;T&gt;,
        lazy: Vec&lt;F&gt;,
        e: T,
        op: O,
        id: F,
        map: M,
        compos: C,
        size: usize,
        log: u32,
    }

    impl&lt;T, O, F, M, C&gt; LazySeg&lt;T, O, F, M, C&gt;
    where
        T: Copy,
        O: Fn(T, T) -&gt; T,
        F: Copy,
        M: Fn(F, T) -&gt; T,
        C: Fn(F, F) -&gt; F,
    {
        fn get_bounds(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; (usize, usize) {
            use std::ops::Bound::*;
            let n = self.len();
            let l = match range.start_bound() {
                Included(&amp;v) =&gt; v,
                Excluded(&amp;v) =&gt; v + 1,
                Unbounded =&gt; 0,
            };
            let r = match range.end_bound() {
                Included(&amp;v) =&gt; (v + 1).min(n),
                Excluded(&amp;v) =&gt; v.min(n),
                Unbounded =&gt; n,
            };
            if l &gt; r {
                return (l, l);
            }
            (l, r)
        }

        fn upd(&amp;mut self, k: usize) {
            self.data[k] = (self.op)(self.data[k * 2], self.data[k * 2 + 1]);
        }

        fn all_apply(&amp;mut self, k: usize, f: F) {
            self.data[k] = (self.map)(f, self.data[k]);
            if k &lt; self.size {
                self.lazy[k] = (self.compos)(f, self.lazy[k]);
            }
        }

        fn push(&amp;mut self, k: usize) {
            self.all_apply(k * 2, self.lazy[k]);
            self.all_apply(k * 2 + 1, self.lazy[k]);
            self.lazy[k] = self.id;
        }

        /// Returns a new lazy segment tree of size `n` built from `iter`.
        ///
        /// The meanings of parameters and some generic types are as follows.
        /// - `T` is a type of values in the array the lazy segment tree represents.
        /// - `F` is a type of mappings for the array.
        /// - `n` is a number of elements in the array.
        /// - `iter` is an iterator returning initial values of the array.
        ///   - If `iter.count() &lt; n`, then the rest is filled with `e`.
        ///   - If `iter.count() &gt; n`, the array is truncated down to the length of `n`.
        /// - `op: impl Fn(T, T) -&gt; T` is a binary operator for `T`.
        /// - `e` is an identity for `op`.
        /// - `map: impl Fn(F, T) -&gt; T` defines how to map `T` to another `T` based on the `F` value.
        /// - `compos: impl Fn(F, F) -&gt; F` defines how to compose two `F`'s.
        /// - `id` defines an identity for `compos`.
        ///
        /// The following notations will be used from now on.
        /// - `op(a, b)` is denoted as `a*b`.
        /// - `map(f, a)` is denoted as `f.a`.
        /// - `map(g, map(f, a))` is denoted as `g.f.a`.
        ///
        /// Constraints of parameters are as follows.
        /// - `op` and `e` must make `T` a monoid. That is, `op` and `e` should be given so that `T` can satisfy the following conditions.
        ///   - `T` is associative under `op`. That is, `(a*b)*c == a*(b*c)` for all `[a, b, c]: [T; 3]`.
        ///   - `T` has `e` as an identity element under `op`. That is, `a*e == e*a == a` for all `a: T`.
        /// - `map`, `compos`, and `id` must satisfy the following conditions.
        ///   - `compos` should be properly defined. That is, if `compos(g, f) == h`, then `g.f.a == h.a` must hold.
        ///   - `id` must be a proper identity for `F` under `compos`. That is, `f.id.a == id.f.a == f.a` for all `a: T` and `f: F`.
        ///   - IMPORTANT: `map` must satisfy `f.(x*y) == f.x * f.y`.
        ///
        /// For example, a generic range addition range sum lazy segment tree with every value initialized with `0` and of length `n` can be constructed as follows.
        /// ```no_run
        /// let mut ls = LazySeg::new(
        ///     n,
        ///     (0..n).map(|_| (0, 1)),
        ///     |(x, l), (y, m)| (x + y, l + m),
        ///     (0i64, 0i64),
        ///     |a, (x, l)| (x + a * l, l),
        ///     |a, b| a + b,
        ///     0i64,
        /// );
        /// ```
        /// A so-called &quot;ax+b&quot; lazy segment tree starting with an array of `vec![0; n]` can be constructed as follows.
        /// ```no_run
        /// let mut ls = LazySeg::new(
        ///     n,
        ///     (0..n).map(|_| (0, 1)),
        ///     |(x, l), (y, m)| (x + y, l + m),
        ///     (0i64, 0i64),
        ///     |(a, b), (x, l)| (a * x, b * l),
        ///     |(a, b), (c, d)| (a * c, a * d + b),
        ///     (1i64, 0i64),
        /// );
        /// ```
        pub fn new(n: usize, iter: impl IntoIterator&lt;Item = T&gt;, op: O, e: T, map: M, compos: C, id: F) -&gt; Self {
            let size = n.next_power_of_two();
            let log = size.trailing_zeros();

            let mut data = vec![e; size];
            data.extend(iter.into_iter().take(n));
            data.resize(2 * size, e);

            let mut ls = Self {
                n,
                data,
                lazy: vec![id; size],
                e,
                op,
                id,
                map,
                compos,
                size,
                log,
            };
            for i in (1..size).rev() {
                ls.upd(i);
            }
            ls
        }

        /// Returns the length of the array.
        pub fn len(&amp;self) -&gt; usize {
            self.n
        }

        /// Returns the `i`-th value of the array.
        pub fn get(&amp;mut self, i: usize) -&gt; T {
            let i = i + self.size;
            for j in (1..=self.log).rev() {
                self.push(i &gt;&gt; j);
            }
            self.data[i]
        }

        /// Assign `upd_to(self.get(i))` to the `i`-th element.
        pub fn update(&amp;mut self, i: usize, upd_to: impl Fn(T) -&gt; T) {
            let i = i + self.size;
            for j in (1..=self.log).rev() {
                self.push(i &gt;&gt; j);
            }
            self.data[i] = upd_to(self.data[i]);
            for j in 1..=self.log {
                self.upd(i &gt;&gt; j);
            }
        }

        /// Returns the product of elements in `range`.
        pub fn prod(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; T {
            let (l, r) = self.get_bounds(range);

            if l == 0 &amp;&amp; r == self.size {
                let ret = (self.op)(self.e, self.data[1]);
                return ret;
            } else if l == r {
                return self.e;
            }

            let (mut l, mut r) = (l + self.size, r + self.size);

            for i in (1..=self.log).rev() {
                if ((l &gt;&gt; i) &lt;&lt; i) != l {
                    self.push(l &gt;&gt; i);
                }
                if ((r &gt;&gt; i) &lt;&lt; i) != r {
                    self.push((r - 1) &gt;&gt; i);
                }
            }

            let (mut sml, mut smr) = (self.e, self.e);
            while l &lt; r {
                if l &amp; 1 == 1 {
                    sml = (self.op)(sml, self.data[l]);
                    l += 1;
                }
                if r &amp; 1 == 1 {
                    r -= 1;
                    smr = (self.op)(self.data[r], smr);
                }
                (l &gt;&gt;= 1, r &gt;&gt;= 1);
            }
            (self.op)(sml, smr)
        }

        /// Changes every element `x` in `range` of the array to `map.x`.
        pub fn apply_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;, map: F) {
            let (l, r) = self.get_bounds(range);
            if l &gt;= r {
                return;
            }

            let (mut l, mut r) = (l + self.size, r + self.size);

            for i in (1..=self.log).rev() {
                if ((l &gt;&gt; i) &lt;&lt; i) != l {
                    self.push(l &gt;&gt; i);
                }
                if ((r &gt;&gt; i) &lt;&lt; i) != r {
                    self.push((r - 1) &gt;&gt; i);
                }
            }

            let (l2, r2) = (l, r);
            while l &lt; r {
                if l &amp; 1 == 1 {
                    self.all_apply(l, map);
                    l += 1;
                }
                if r &amp; 1 == 1 {
                    r -= 1;
                    self.all_apply(r, map);
                }
                l &gt;&gt;= 1;
                r &gt;&gt;= 1;
            }
            l = l2;
            r = r2;

            for i in 1..=self.log {
                if ((l &gt;&gt; i) &lt;&lt; i) != l {
                    self.upd(l &gt;&gt; i);
                }
                if ((r &gt;&gt; i) &lt;&lt; i) != r {
                    self.upd((r - 1) &gt;&gt; i);
                }
            }
        }

        /// For a function `pred` which has a nonnegative value `x`, such that `pred(self.prod(l..r))` is `false` if and only if `x &lt;= r`, `self.partition_point(l, pred)` returns the value of such `x`.
        /// That is, this is the minimum value of `r` such that `pred(self.prod(l..r))` starts to be `false`.
        /// If `pred(self.e)` is `true`, then this function assumes that `pred(self.prod(l..r))` is always `true` for any `r` in range `l..=self.len()` and returns `l`.
        /// However, it's recommended to always set `pred(self.e)` to be `true` to avoid unnecessary case works.
        ///
        /// ## Constraints
        /// - `0 &lt;= l &lt;= self.len()`
        ///
        /// ## Examples
        /// `f(r) := pred(self.prod(l..r))`
        ///
        /// Given that `self.len() == 7`, calling `self.partition_point(0)` returns values written below.
        /// ```text
        ///    r |     0     1     2     3     4     5     6     7     8
        ///
        /// f(r) |  true  true  true  true false false false false   N/A
        ///                             returns^
        ///
        /// f(r) | false false false false false false false false   N/A
        ///     returns^
        ///
        /// f(r) |  true  true  true  true  true  true  true  true   N/A
        ///                                                     returns^
        /// ```
        pub fn partition_point(&amp;mut self, l: usize, pred: impl Fn(T) -&gt; bool) -&gt; usize {
            if !pred(self.e) {
                return l;
            }

            if l == self.n {
                // `pred(self.e)` has already been checked that it's `true`.
                return self.n;
            }

            let mut l = l + self.size;
            for i in (1..=self.log).rev() {
                self.push(l &gt;&gt; i);
            }
            let mut sm = self.e;

            loop {
                l &gt;&gt;= l.trailing_zeros();
                if !pred((self.op)(sm, self.data[l])) {
                    while l &lt; self.size {
                        self.push(l);
                        l &lt;&lt;= 1;
                        let tmp = (self.op)(sm, self.data[l]);
                        if pred(tmp) {
                            sm = tmp;
                            l += 1;
                        }
                    }
                    return l + 1 - self.size;
                }
                sm = (self.op)(sm, self.data[l]);
                l += 1;
                if l &amp; ((!l) + 1) == l {
                    break;
                }
            }
            self.n + 1
        }

        /// For a function `pred` which has a value `x` less than or equal to `r`, such that `pred(self.prod(l..r))` is `true` if and only if `x &lt;= l`, `self.left_partition_point(r, pred)` returns the value of such `x`.
        /// That is, this is the minimum value of `l` such that `pred(self.prod(l..r))` starts to be `true`.
        /// If `pred(self.e)` is `false`, then this function assumes that `pred(self.prod(l..r))` is always `false` for any `l` in range `0..=r` and returns `r+1`.
        /// However, it's recommended to always set `pred(self.e)` to be `true` to avoid unnecessary case works.
        ///
        /// ## Constraints
        /// - `0 &lt;= r &lt;= self.len()`
        ///
        /// ## Examples
        /// `f(l) := pred(self.prod(l..r))`
        ///
        /// Calling `self.left_partition_point(7)` returns values written below.
        /// ```text
        ///    l |     0     1     2     3     4     5     6     7     8
        ///
        /// f(l) | false false false false  true  true  true  true   N/A
        ///                             returns^
        ///
        /// f(l) |  true  true  true  true  true  true  true  true   N/A
        ///     returns^
        ///
        /// f(l) | false false false false false false false false   N/A
        ///                                                     returns^
        /// ```
        pub fn left_partition_point(&amp;mut self, r: usize, pred: impl Fn(T) -&gt; bool) -&gt; usize {
            if !pred(self.e) {
                return r + 1;
            }

            if r == 0 {
                // `pred(self.e)` has already been checked that it's `true`.
                return 0;
            }

            let mut r = r + self.size;
            for i in (1..=self.log).rev() {
                self.push((r - 1) &gt;&gt; i);
            }

            let mut sm = self.e;
            loop {
                r -= 1;
                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                    r &gt;&gt;= 1;
                }

                if !pred((self.op)(self.data[r], sm)) {
                    while r &lt; self.size {
                        self.push(r);
                        r = (r &lt;&lt; 1) + 1;
                        let tmp = (self.op)(self.data[r], sm);
                        if pred(tmp) {
                            sm = tmp;
                            r -= 1;
                        }
                    }
                    return r + 1 - self.size;
                }
                sm = (self.op)(self.data[r], sm);
                if r &amp; ((!r) + 1) == r {
                    break;
                }
            }
            0
        }
    }
}</code></pre>
<hr />
<p>Last modified on 231007.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rope"><a class="header" href="#rope">Rope</a></h1>
<p>Rope acts as if it is a list, but inserting a value at an arbitrary position takes time complexity of amortized \( O(\log{N}) \). However, accessing values also takes amortized \( O(\log{N}) \) time. Building a rope from an iterator takes \( O(N) \).</p>
<p>When accessing to elements, if you use immutable borrow; that is, borrowing through <code>rope.get(idx)</code> or immutably indexing a value like <code>let v = rope[3];</code>, then <strong>splaying doesn't happen</strong> and in the worst case the accessing could take \(O(N)\). Make sure to use <code>get_mut()</code> for performance.</p>
<h2 id="example-14"><a class="header" href="#example-14">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>use rope::Rope;

let mut arr: Rope&lt;i32&gt; = (0..10).collect();
println!(&quot;{:?}&quot;, arr);

let out = arr.take_range(1..5).unwrap();
arr.merge_right(out);
println!(&quot;{:?}&quot;, arr);

for i in 11..100000 {
    let n = arr.len() / 2;
    arr.insert(n, i);
}
println!(&quot;{}&quot;, arr[50000]);

for _ in 0..arr.len() - 10 {
    let n = arr.len() / 2;
    arr.remove(n + 1);
}
println!(&quot;{:?}&quot;, arr);
<span class="boring">}
</span><span class="boring">mod rope {
</span><span class="boring">    use std::{
</span><span class="boring">        cmp::Ordering,
</span><span class="boring">        fmt::{Debug, Display},
</span><span class="boring">        ops::{Bound::*, Index, IndexMut, RangeBounds},
</span><span class="boring">        ptr::{self, NonNull},
</span><span class="boring">        iter::FromIterator,
</span><span class="boring">    };
</span><span class="boring">    pub struct Node&lt;T&gt; {
</span><span class="boring">        data: T,
</span><span class="boring">        subt: usize,
</span><span class="boring">        l: Link&lt;T&gt;,
</span><span class="boring">        r: Link&lt;T&gt;,
</span><span class="boring">        p: Link&lt;T&gt;,
</span><span class="boring">    }
</span><span class="boring">    type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">    impl&lt;T&gt; Node&lt;T&gt; {
</span><span class="boring">        fn new(data: T) -&gt; Self {
</span><span class="boring">            Node {
</span><span class="boring">                data,
</span><span class="boring">                subt: 1,
</span><span class="boring">                l: None,
</span><span class="boring">                r: None,
</span><span class="boring">                p: None,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn left_size(&amp;self) -&gt; usize {
</span><span class="boring">            unsafe { self.l.map_or(0, |l| (*l.as_ptr()).subt) }
</span><span class="boring">        }
</span><span class="boring">        fn right_size(&amp;self) -&gt; usize {
</span><span class="boring">            unsafe { self.r.map_or(0, |r| (*r.as_ptr()).subt) }
</span><span class="boring">        }
</span><span class="boring">        fn upd_subtree(&amp;mut self) {
</span><span class="boring">            self.subt = 1 + self.left_size() + self.right_size();
</span><span class="boring">        }
</span><span class="boring">        // Option&lt;(is_left, parent)&gt;
</span><span class="boring">        unsafe fn is_left_child(x: NonNull&lt;Self&gt;) -&gt; Option&lt;(bool, NonNull&lt;Self&gt;)&gt; {
</span><span class="boring">            if let Some(p) = (*x.as_ptr()).p {
</span><span class="boring">                if (*p.as_ptr())
</span><span class="boring">                    .l
</span><span class="boring">                    .map_or(false, |pl| ptr::eq(x.as_ptr(), pl.as_ptr()))
</span><span class="boring">                {
</span><span class="boring">                    Some((true, p))
</span><span class="boring">                } else {
</span><span class="boring">                    Some((false, p))
</span><span class="boring">                }
</span><span class="boring">            } else {
</span><span class="boring">                None
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct Rope&lt;T&gt; {
</span><span class="boring">        root: Link&lt;T&gt;,
</span><span class="boring">        size: usize,
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Default for Rope&lt;T&gt; {
</span><span class="boring">        fn default() -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                root: None,
</span><span class="boring">                size: 0,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Rope&lt;T&gt; {
</span><span class="boring">        pub fn new() -&gt; Self {
</span><span class="boring">            Self::default()
</span><span class="boring">        }
</span><span class="boring">        pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">            self.size
</span><span class="boring">        }
</span><span class="boring">        pub fn insert(&amp;mut self, idx: usize, data: T) {
</span><span class="boring">            debug_assert!(idx &lt;= self.size);
</span><span class="boring">            unsafe {
</span><span class="boring">                let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));
</span><span class="boring">                if let Some(r) = self.root {
</span><span class="boring">                    let idx = self.kth_ptr(idx);
</span><span class="boring">                    if let Some(idx) = idx {
</span><span class="boring">                        // idx_node is the node which new_node should replace
</span><span class="boring">                        // &quot;Replace&quot; means the new_node should be placed right before the idx_node
</span><span class="boring">                        if let Some(l) = (*idx.as_ptr()).l {
</span><span class="boring">                            // Attach at the right of rightmost node from l
</span><span class="boring">                            let mut p = l;
</span><span class="boring">                            while let Some(r) = (*p.as_ptr()).r {
</span><span class="boring">                                p = r;
</span><span class="boring">                            }
</span><span class="boring">                            // Attach new_node to the right of p
</span><span class="boring">                            (*new_node.as_ptr()).p = Some(p);
</span><span class="boring">                            (*p.as_ptr()).r = Some(new_node);
</span><span class="boring">                        } else {
</span><span class="boring">                            // Attach it right away
</span><span class="boring">                            let p = idx;
</span><span class="boring">                            (*new_node.as_ptr()).p = Some(p);
</span><span class="boring">                            (*p.as_ptr()).l = Some(new_node);
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // idx == self.size
</span><span class="boring">                        // new_node goes to the rightmost of the tree
</span><span class="boring">                        let mut p = r;
</span><span class="boring">                        while let Some(r) = (*p.as_ptr()).r {
</span><span class="boring">                            p = r;
</span><span class="boring">                        }
</span><span class="boring">                        // Attach new_node to the right of p
</span><span class="boring">                        (*new_node.as_ptr()).p = Some(p);
</span><span class="boring">                        (*p.as_ptr()).r = Some(new_node);
</span><span class="boring">                    }
</span><span class="boring">                    let mut c = new_node;
</span><span class="boring">                    while let Some(p) = (*c.as_ptr()).p {
</span><span class="boring">                        c = p;
</span><span class="boring">                        (*c.as_ptr()).upd_subtree();
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    self.root = Some(new_node);
</span><span class="boring">                }
</span><span class="boring">                self.splay(new_node);
</span><span class="boring">                self.size += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        pub fn remove(&amp;mut self, idx: usize) -&gt; Option&lt;T&gt; {
</span><span class="boring">            if idx &gt;= self.size {
</span><span class="boring">                return None;
</span><span class="boring">            }
</span><span class="boring">            let data: T = unsafe {
</span><span class="boring">                if let Some(mut rt) = self.kth_ptr(idx) {
</span><span class="boring">                    rt = self.remove_helper(rt);
</span><span class="boring">                    if let Some(rp) = (*rt.as_ptr()).p {
</span><span class="boring">                        self.splay(rp);
</span><span class="boring">                    }
</span><span class="boring">                    let retr = Box::from_raw(rt.as_ptr());
</span><span class="boring">                    retr.data
</span><span class="boring">                } else {
</span><span class="boring">                    unreachable!()
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">            self.size -= 1;
</span><span class="boring">            Some(data)
</span><span class="boring">        }
</span><span class="boring">        pub fn push_front(&amp;mut self, data: T) {
</span><span class="boring">            self.insert(0, data);
</span><span class="boring">        }
</span><span class="boring">        pub fn push_back(&amp;mut self, data: T) {
</span><span class="boring">            self.insert(self.size, data);
</span><span class="boring">        }
</span><span class="boring">        pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">            self.remove(0)
</span><span class="boring">        }
</span><span class="boring">        pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">            self.remove(self.size - 1)
</span><span class="boring">        }
</span><span class="boring">        /// Splits out the rope, leaving self[..at] and returning self[at..].
</span><span class="boring">        /// If the index is invalid, it returns None.
</span><span class="boring">        pub fn take_right(&amp;mut self, right_start: usize) -&gt; Option&lt;Self&gt; {
</span><span class="boring">            let rhs = unsafe {
</span><span class="boring">                if right_start == 0 {
</span><span class="boring">                    let rhs = Self {
</span><span class="boring">                        root: self.root,
</span><span class="boring">                        size: self.size,
</span><span class="boring">                    };
</span><span class="boring">                    self.root = None;
</span><span class="boring">                    self.size = 0;
</span><span class="boring">                    rhs
</span><span class="boring">                } else {
</span><span class="boring">                    let root = self.kth_ptr(right_start - 1)?;
</span><span class="boring">                    self.splay(root);
</span><span class="boring">                    if let Some(r) = (*root.as_ptr()).r {
</span><span class="boring">                        (*root.as_ptr()).r = None;
</span><span class="boring">                        (*r.as_ptr()).p = None;
</span><span class="boring">                        (*root.as_ptr()).upd_subtree();
</span><span class="boring">                        self.size = (*root.as_ptr()).subt;
</span><span class="boring">                        Self {
</span><span class="boring">                            root: Some(r),
</span><span class="boring">                            size: (*r.as_ptr()).subt,
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        Self {
</span><span class="boring">                            root: None,
</span><span class="boring">                            size: 0,
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">            Some(rhs)
</span><span class="boring">        }
</span><span class="boring">        /// Splits out the rope and returns self[..at] and self[at..].
</span><span class="boring">        /// If the index is invalid, it returns None.
</span><span class="boring">        pub fn split_at(mut self, at: usize) -&gt; Option&lt;(Self, Self)&gt; {
</span><span class="boring">            let rhs = self.take_right(at)?;
</span><span class="boring">            Some((self, rhs))
</span><span class="boring">        }
</span><span class="boring">        /// Takes out the range from the rope.
</span><span class="boring">        /// Returns None if the index is invalid.
</span><span class="boring">        pub fn take_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; Option&lt;Self&gt; {
</span><span class="boring">            let l = match range.start_bound() {
</span><span class="boring">                Included(&amp;l) =&gt; l,
</span><span class="boring">                Excluded(&amp;l) =&gt; l + 1,
</span><span class="boring">                Unbounded =&gt; 0,
</span><span class="boring">            };
</span><span class="boring">            let r = match range.end_bound() {
</span><span class="boring">                Included(&amp;r) =&gt; r + 1,
</span><span class="boring">                Excluded(&amp;r) =&gt; r,
</span><span class="boring">                Unbounded =&gt; self.size,
</span><span class="boring">            };
</span><span class="boring">            if l &gt; r || l &gt; self.size || r &gt; self.size {
</span><span class="boring">                return None;
</span><span class="boring">            }
</span><span class="boring">            // Now the operations below never ends early
</span><span class="boring">            let c = self.take_right(r)?;
</span><span class="boring">            let b = self.take_right(l)?;
</span><span class="boring">            self.merge_right(c);
</span><span class="boring">            Some(b)
</span><span class="boring">        }
</span><span class="boring">        pub fn merge_right(&amp;mut self, mut rhs: Self) {
</span><span class="boring">            if self.len() == 0 {
</span><span class="boring">                self.root = rhs.root;
</span><span class="boring">                self.size = rhs.size;
</span><span class="boring">            } else {
</span><span class="boring">                unsafe {
</span><span class="boring">                    let rmost = self.kth_ptr(self.size - 1).unwrap();
</span><span class="boring">                    self.splay(rmost);
</span><span class="boring">                    (*rmost.as_ptr()).r = rhs.root;
</span><span class="boring">                    if let Some(rhs_root) = rhs.root {
</span><span class="boring">                        (*rhs_root.as_ptr()).p = Some(rmost);
</span><span class="boring">                    }
</span><span class="boring">                    (*rmost.as_ptr()).upd_subtree();
</span><span class="boring">                    self.size = (*rmost.as_ptr()).subt;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            rhs.root = None;
</span><span class="boring">            rhs.size = 0;
</span><span class="boring">        }
</span><span class="boring">        pub fn merge_left(&amp;mut self, mut lhs: Self) {
</span><span class="boring">            if self.len() == 0 {
</span><span class="boring">                self.root = lhs.root;
</span><span class="boring">                self.size = lhs.size;
</span><span class="boring">            } else {
</span><span class="boring">                unsafe {
</span><span class="boring">                    let lmost = self.kth_ptr(0).unwrap();
</span><span class="boring">                    self.splay(lmost);
</span><span class="boring">                    (*lmost.as_ptr()).l = lhs.root;
</span><span class="boring">                    if let Some(lhs_root) = lhs.root {
</span><span class="boring">                        (*lhs_root.as_ptr()).p = Some(lmost);
</span><span class="boring">                    }
</span><span class="boring">                    (*lmost.as_ptr()).upd_subtree();
</span><span class="boring">                    self.size = (*lmost.as_ptr()).subt;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            lhs.root = None;
</span><span class="boring">            lhs.size = 0;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T: Debug&gt; Debug for Rope&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">            write!(f, &quot;[&quot;)?;
</span><span class="boring">            let mut cnt: usize = 0;
</span><span class="boring">            unsafe {
</span><span class="boring">                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
</span><span class="boring">                let mut curr = self.root;
</span><span class="boring">                loop {
</span><span class="boring">                    while let Some(x) = curr {
</span><span class="boring">                        stack.push(x.as_ptr());
</span><span class="boring">                        curr = (*x.as_ptr()).l;
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(x) = stack.pop() {
</span><span class="boring">                        if cnt == 0 {
</span><span class="boring">                            write!(f, &quot;{:?}&quot;, (*x).data)?;
</span><span class="boring">                        } else {
</span><span class="boring">                            write!(f, &quot;, {:?}&quot;, (*x).data)?;
</span><span class="boring">                        }
</span><span class="boring">                        cnt += 1;
</span><span class="boring">                        curr = (*x).r;
</span><span class="boring">                    } else {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            write!(f, &quot;]&quot;)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T: Display&gt; Display for Rope&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">            unsafe {
</span><span class="boring">                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
</span><span class="boring">                let mut curr = self.root;
</span><span class="boring">                loop {
</span><span class="boring">                    while let Some(x) = curr {
</span><span class="boring">                        stack.push(x.as_ptr());
</span><span class="boring">                        curr = (*x.as_ptr()).l;
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(x) = stack.pop() {
</span><span class="boring">                        write!(f, &quot;{}&quot;, (*x).data)?;
</span><span class="boring">                        curr = (*x).r;
</span><span class="boring">                    } else {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Drop for Rope&lt;T&gt; {
</span><span class="boring">        fn drop(&amp;mut self) {
</span><span class="boring">            if let Some(root) = self.root {
</span><span class="boring">                unsafe {
</span><span class="boring">                    let mut st: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
</span><span class="boring">                    st.push(root.as_ptr());
</span><span class="boring">                    while let Some(t) = st.pop() {
</span><span class="boring">                        let v = Box::from_raw(t);
</span><span class="boring">                        if let Some(l) = v.l {
</span><span class="boring">                            st.push(l.as_ptr());
</span><span class="boring">                        }
</span><span class="boring">                        if let Some(r) = v.r {
</span><span class="boring">                            st.push(r.as_ptr());
</span><span class="boring">                        }
</span><span class="boring">                        // retrieve.drop()
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Index&lt;usize&gt; for Rope&lt;T&gt; {
</span><span class="boring">        type Output = T;
</span><span class="boring">        fn index(&amp;self, idx: usize) -&gt; &amp;Self::Output {
</span><span class="boring">            unsafe {
</span><span class="boring">                let p = self.kth_ptr(idx);
</span><span class="boring">                &amp;(*p.unwrap().as_ptr()).data
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; IndexMut&lt;usize&gt; for Rope&lt;T&gt; {
</span><span class="boring">        fn index_mut(&amp;mut self, idx: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">            unsafe {
</span><span class="boring">                let p = self.kth_ptr(idx);
</span><span class="boring">                &amp;mut (*p.unwrap().as_ptr()).data
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; FromIterator&lt;T&gt; for Rope&lt;T&gt; {
</span><span class="boring">        fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {
</span><span class="boring">            let mut arr = Self::new();
</span><span class="boring">            for v in iter {
</span><span class="boring">                unsafe { arr.push_ontop_root(v) };
</span><span class="boring">            }
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    //------------------------
</span><span class="boring">    // Helper implementations
</span><span class="boring">    //------------------------
</span><span class="boring">    impl&lt;T&gt; Rope&lt;T&gt; {
</span><span class="boring">        /// Adds data as a new root of a rope, and putting the original root
</span><span class="boring">        /// as a left child of the root.
</span><span class="boring">        unsafe fn push_ontop_root(&amp;mut self, data: T) {
</span><span class="boring">            let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));
</span><span class="boring">            if let Some(root) = self.root {
</span><span class="boring">                (*root.as_ptr()).p = Some(new_node);
</span><span class="boring">                (*new_node.as_ptr()).l = Some(root);
</span><span class="boring">            }
</span><span class="boring">            self.root = Some(new_node);
</span><span class="boring">            (*new_node.as_ptr()).upd_subtree();
</span><span class="boring">            self.size += 1;
</span><span class="boring">        }
</span><span class="boring">        /// Returns false if x has no parent, and do nothing
</span><span class="boring">        /// Returns true if x has a parent, after performing rotation
</span><span class="boring">        unsafe fn rotate(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; bool {
</span><span class="boring">            if let Some((is_x_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                // Check if p is root
</span><span class="boring">                if let Some(root) = self.root {
</span><span class="boring">                    if ptr::eq(root.as_ptr(), p.as_ptr()) {
</span><span class="boring">                        self.root = Some(x);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                // Connect x to xpp. If pp is None, do nothing.
</span><span class="boring">                (*x.as_ptr()).p = (*p.as_ptr()).p;
</span><span class="boring">                if let Some((is_p_left, pp)) = Node::is_left_child(p) {
</span><span class="boring">                    if is_p_left {
</span><span class="boring">                        (*pp.as_ptr()).l = Some(x);
</span><span class="boring">                    } else {
</span><span class="boring">                        (*pp.as_ptr()).r = Some(x);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                if is_x_left {
</span><span class="boring">                    let b = (*x.as_ptr()).r;
</span><span class="boring">                    (*x.as_ptr()).r = Some(p);
</span><span class="boring">                    (*p.as_ptr()).p = Some(x);
</span><span class="boring">                    (*p.as_ptr()).l = b;
</span><span class="boring">                    if let Some(b) = b {
</span><span class="boring">                        (*b.as_ptr()).p = Some(p);
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    let b = (*x.as_ptr()).l;
</span><span class="boring">                    (*x.as_ptr()).l = Some(p);
</span><span class="boring">                    (*p.as_ptr()).p = Some(x);
</span><span class="boring">                    (*p.as_ptr()).r = b;
</span><span class="boring">                    if let Some(b) = b {
</span><span class="boring">                        (*b.as_ptr()).p = Some(p);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                (*p.as_ptr()).upd_subtree();
</span><span class="boring">                (*x.as_ptr()).upd_subtree();
</span><span class="boring">                true
</span><span class="boring">            } else {
</span><span class="boring">                false
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn splay(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) {
</span><span class="boring">            unsafe {
</span><span class="boring">                while let Some(root) = self.root {
</span><span class="boring">                    if ptr::eq(x.as_ptr(), root.as_ptr()) {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), p.as_ptr()) {
</span><span class="boring">                            // If p is root, rotate x once
</span><span class="boring">                            self.rotate(x);
</span><span class="boring">                        } else {
</span><span class="boring">                            // Panics if pp doesn't exist, which happens only when p is root
</span><span class="boring">                            let (is_p_left, _pp) = Node::is_left_child(p).unwrap();
</span><span class="boring">                            if is_x_left == is_p_left {
</span><span class="boring">                                self.rotate(p);
</span><span class="boring">                                self.rotate(x);
</span><span class="boring">                            } else {
</span><span class="boring">                                self.rotate(x);
</span><span class="boring">                                self.rotate(x);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // x has no parent, which should logically never happen
</span><span class="boring">                        unreachable!()
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        unsafe fn kth_ptr(&amp;self, idx: usize) -&gt; Link&lt;T&gt; {
</span><span class="boring">            if self.size &lt;= idx {
</span><span class="boring">                return None;
</span><span class="boring">            }
</span><span class="boring">            if let Some(r) = self.root {
</span><span class="boring">                let mut rem = idx;
</span><span class="boring">                let mut p = r;
</span><span class="boring">                loop {
</span><span class="boring">                    let lsize = (*p.as_ptr()).left_size();
</span><span class="boring">                    match rem.cmp(&amp;lsize) {
</span><span class="boring">                        Ordering::Less =&gt; {
</span><span class="boring">                            p = (*p.as_ptr()).l?;
</span><span class="boring">                        }
</span><span class="boring">                        Ordering::Equal =&gt; {
</span><span class="boring">                            break;
</span><span class="boring">                        }
</span><span class="boring">                        Ordering::Greater =&gt; {
</span><span class="boring">                            rem -= lsize + 1;
</span><span class="boring">                            p = (*p.as_ptr()).r?;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                Some(p)
</span><span class="boring">            } else {
</span><span class="boring">                None
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        unsafe fn remove_helper(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; NonNull&lt;Node&lt;T&gt;&gt; {
</span><span class="boring">            // Set remove_target to the actual node to delete
</span><span class="boring">            match ((*x.as_ptr()).l, ((*x.as_ptr()).r)) {
</span><span class="boring">                (None, None) =&gt; {
</span><span class="boring">                    // Reset root if the node itself is root
</span><span class="boring">                    if let Some(root) = self.root {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
</span><span class="boring">                            self.root = None;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // Detatch itself from parent
</span><span class="boring">                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if is_x_left {
</span><span class="boring">                            (*p.as_ptr()).l = None;
</span><span class="boring">                        } else {
</span><span class="boring">                            (*p.as_ptr()).r = None;
</span><span class="boring">                        }
</span><span class="boring">                        // Update subtree size
</span><span class="boring">                        let mut p = p;
</span><span class="boring">                        (*p.as_ptr()).upd_subtree();
</span><span class="boring">                        while let Some(pp) = (*p.as_ptr()).p {
</span><span class="boring">                            p = pp;
</span><span class="boring">                            (*p.as_ptr()).upd_subtree();
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    x
</span><span class="boring">                }
</span><span class="boring">                (Some(l), None) =&gt; {
</span><span class="boring">                    // Reset root if the node itself is a root
</span><span class="boring">                    if let Some(root) = self.root {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
</span><span class="boring">                            self.root = Some(l);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    (*l.as_ptr()).p = (*x.as_ptr()).p;
</span><span class="boring">                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if is_rt_left {
</span><span class="boring">                            (*p.as_ptr()).l = Some(l);
</span><span class="boring">                        } else {
</span><span class="boring">                            (*p.as_ptr()).r = Some(l);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    let mut p = l;
</span><span class="boring">                    while let Some(pp) = (*p.as_ptr()).p {
</span><span class="boring">                        p = pp;
</span><span class="boring">                        (*p.as_ptr()).upd_subtree();
</span><span class="boring">                    }
</span><span class="boring">                    x
</span><span class="boring">                }
</span><span class="boring">                (None, Some(r)) =&gt; {
</span><span class="boring">                    // Reset root if the node itself is a root
</span><span class="boring">                    if let Some(root) = self.root {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
</span><span class="boring">                            self.root = Some(r);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    (*r.as_ptr()).p = (*x.as_ptr()).p;
</span><span class="boring">                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if is_rt_left {
</span><span class="boring">                            (*p.as_ptr()).l = Some(r);
</span><span class="boring">                        } else {
</span><span class="boring">                            (*p.as_ptr()).r = Some(r);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    let mut p = r;
</span><span class="boring">                    while let Some(pp) = (*p.as_ptr()).p {
</span><span class="boring">                        p = pp;
</span><span class="boring">                        (*p.as_ptr()).upd_subtree();
</span><span class="boring">                    }
</span><span class="boring">                    x
</span><span class="boring">                }
</span><span class="boring">                (Some(l), Some(_)) =&gt; {
</span><span class="boring">                    let mut sw = l;
</span><span class="boring">                    while let Some(sr) = (*sw.as_ptr()).r {
</span><span class="boring">                        sw = sr;
</span><span class="boring">                    }
</span><span class="boring">                    std::mem::swap(&amp;mut (*x.as_ptr()).data, &amp;mut (*sw.as_ptr()).data);
</span><span class="boring">                    sw = self.remove_helper(sw);
</span><span class="boring">                    sw
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    //-----------
</span><span class="boring">    // Iterators
</span><span class="boring">    //-----------
</span><span class="boring">    impl&lt;T&gt; Rope&lt;T&gt; {
</span><span class="boring">        pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
</span><span class="boring">            Iter::new(self)
</span><span class="boring">        }
</span><span class="boring">        pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
</span><span class="boring">            IterMut::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct Iter&lt;'a, T&gt; {
</span><span class="boring">        rope: &amp;'a Rope&lt;T&gt;,
</span><span class="boring">        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
</span><span class="boring">        curr: Link&lt;T&gt;,
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
</span><span class="boring">        fn new(rope: &amp;'a Rope&lt;T&gt;) -&gt; Self {
</span><span class="boring">            let root = rope.root;
</span><span class="boring">            Self {
</span><span class="boring">                rope,
</span><span class="boring">                stack: Vec::new(),
</span><span class="boring">                curr: root,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; IntoIterator for &amp;'a Rope&lt;T&gt; {
</span><span class="boring">        type Item = &amp;'a T;
</span><span class="boring">        type IntoIter = Iter&lt;'a, T&gt;;
</span><span class="boring">        fn into_iter(self) -&gt; Self::IntoIter {
</span><span class="boring">            Self::IntoIter::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
</span><span class="boring">        type Item = &amp;'a T;
</span><span class="boring">        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">            unsafe {
</span><span class="boring">                while let Some(x) = self.curr {
</span><span class="boring">                    self.stack.push(x);
</span><span class="boring">                    self.curr = (*x.as_ptr()).l;
</span><span class="boring">                }
</span><span class="boring">                if let Some(x) = self.stack.pop() {
</span><span class="boring">                    self.curr = (*x.as_ptr()).r;
</span><span class="boring">                    Some(&amp;x.as_ref().data)
</span><span class="boring">                } else {
</span><span class="boring">                    None
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
</span><span class="boring">            (self.rope.len(), Some(self.rope.len()))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct IterMut&lt;'a, T&gt; {
</span><span class="boring">        rope: &amp;'a mut Rope&lt;T&gt;,
</span><span class="boring">        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
</span><span class="boring">        curr: Link&lt;T&gt;,
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; IterMut&lt;'a, T&gt; {
</span><span class="boring">        fn new(rope: &amp;'a mut Rope&lt;T&gt;) -&gt; Self {
</span><span class="boring">            let root = rope.root;
</span><span class="boring">            Self {
</span><span class="boring">                rope,
</span><span class="boring">                stack: Vec::new(),
</span><span class="boring">                curr: root,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Rope&lt;T&gt; {
</span><span class="boring">        type Item = &amp;'a mut T;
</span><span class="boring">        type IntoIter = IterMut&lt;'a, T&gt;;
</span><span class="boring">        fn into_iter(self) -&gt; Self::IntoIter {
</span><span class="boring">            Self::IntoIter::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
</span><span class="boring">        type Item = &amp;'a mut T;
</span><span class="boring">        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">            unsafe {
</span><span class="boring">                while let Some(x) = self.curr {
</span><span class="boring">                    self.stack.push(x);
</span><span class="boring">                    self.curr = (*x.as_ptr()).l;
</span><span class="boring">                }
</span><span class="boring">                if let Some(mut x) = self.stack.pop() {
</span><span class="boring">                    self.curr = (*x.as_ptr()).r;
</span><span class="boring">                    Some(&amp;mut x.as_mut().data)
</span><span class="boring">                } else {
</span><span class="boring">                    None
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
</span><span class="boring">            (self.rope.len(), Some(self.rope.len()))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-13"><a class="header" href="#code-13">Code</a></h2>
<pre><code class="language-rust noplayground">mod rope {
    use std::{
        cmp::Ordering,
        fmt::{Debug, Display},
        ops::{Bound::*, Index, IndexMut, RangeBounds},
        ptr::{self, NonNull},
    };

    pub struct Rope&lt;T&gt; {
        root: Link&lt;T&gt;,
        size: usize,
    }

    impl&lt;T&gt; Default for Rope&lt;T&gt; {
        fn default() -&gt; Self {
            Self {
                root: None,
                size: 0,
            }
        }
    }

    impl&lt;T&gt; Rope&lt;T&gt; {
        pub fn new() -&gt; Self {
            Self::default()
        }

        pub fn len(&amp;self) -&gt; usize {
            self.size
        }

        pub fn clear(&amp;mut self) {
            let drop_tree = Self {
                root: self.root,
                size: self.size,
            };
            drop(drop_tree);
            self.root = None;
            self.size = 0;
        }

        pub fn insert(&amp;mut self, idx: usize, data: T) {
            debug_assert!(idx &lt;= self.size);
            unsafe {
                let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));

                if let Some(r) = self.root {
                    let idx = self.kth_ptr(idx);
                    if let Some(idx) = idx {
                        // idx_node is the node which new_node should replace
                        // &quot;Replace&quot; means the new_node should be placed right before the idx_node
                        if let Some(l) = (*idx.as_ptr()).l {
                            // Attach at the right of rightmost node from l
                            let mut p = l;
                            while let Some(r) = (*p.as_ptr()).r {
                                p = r;
                            }
                            // Attach new_node to the right of p
                            (*new_node.as_ptr()).p = Some(p);
                            (*p.as_ptr()).r = Some(new_node);
                        } else {
                            // Attach it right away
                            let p = idx;
                            (*new_node.as_ptr()).p = Some(p);
                            (*p.as_ptr()).l = Some(new_node);
                        }
                    } else {
                        // idx == self.size
                        // new_node goes to the rightmost of the tree
                        let mut p = r;
                        while let Some(r) = (*p.as_ptr()).r {
                            p = r;
                        }
                        // Attach new_node to the right of p
                        (*new_node.as_ptr()).p = Some(p);
                        (*p.as_ptr()).r = Some(new_node);
                    }

                    let mut c = new_node;
                    while let Some(p) = (*c.as_ptr()).p {
                        c = p;
                        (*c.as_ptr()).upd_subtree();
                    }
                } else {
                    self.root = Some(new_node);
                }

                self.splay(new_node);
                self.size += 1;
            }
        }

        pub fn remove(&amp;mut self, idx: usize) -&gt; Option&lt;T&gt; {
            if idx &gt;= self.size {
                return None;
            }

            let data: T = unsafe {
                if let Some(mut rt) = self.kth_ptr(idx) {
                    rt = self.remove_helper(rt);
                    if let Some(rp) = (*rt.as_ptr()).p {
                        self.splay(rp);
                    }
                    let retr = Box::from_raw(rt.as_ptr());
                    retr.data
                } else {
                    unreachable!()
                }
            };

            self.size -= 1;
            Some(data)
        }

        pub fn push_front(&amp;mut self, data: T) {
            self.insert(0, data);
        }

        pub fn push_back(&amp;mut self, data: T) {
            self.insert(self.size, data);
        }

        pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.remove(0)
        }

        pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.remove(self.size - 1)
        }

        /// Splits out the rope, leaving self[..at] and returning self[at..].
        /// If the index is invalid, it returns None.
        pub fn take_right(&amp;mut self, right_start: usize) -&gt; Option&lt;Self&gt; {
            let rhs = unsafe {
                if right_start == 0 {
                    let rhs = Self {
                        root: self.root,
                        size: self.size,
                    };
                    self.root = None;
                    self.size = 0;
                    rhs
                } else {
                    let root = self.kth_ptr(right_start - 1)?;
                    self.splay(root);
                    if let Some(r) = (*root.as_ptr()).r {
                        (*root.as_ptr()).r = None;
                        (*r.as_ptr()).p = None;
                        (*root.as_ptr()).upd_subtree();
                        self.size = (*root.as_ptr()).subt;
                        Self {
                            root: Some(r),
                            size: (*r.as_ptr()).subt,
                        }
                    } else {
                        Self {
                            root: None,
                            size: 0,
                        }
                    }
                }
            };
            Some(rhs)
        }

        /// Splits out the rope and returns self[..at] and self[at..].
        /// If the index is invalid, it returns None.
        pub fn split_at(mut self, at: usize) -&gt; Option&lt;(Self, Self)&gt; {
            let rhs = self.take_right(at)?;
            Some((self, rhs))
        }

        /// Takes out the range from the rope.
        /// Returns None if the index is invalid.
        pub fn take_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; Option&lt;Self&gt; {
            let l = match range.start_bound() {
                Included(&amp;l) =&gt; l,
                Excluded(&amp;l) =&gt; l + 1,
                Unbounded =&gt; 0,
            };
            let r = match range.end_bound() {
                Included(&amp;r) =&gt; r + 1,
                Excluded(&amp;r) =&gt; r,
                Unbounded =&gt; self.size,
            };

            if l &gt; r || l &gt; self.size || r &gt; self.size {
                return None;
            }
            // Now the operations below never ends early
            let c = self.take_right(r)?;
            let b = self.take_right(l)?;
            self.merge_right(c);
            Some(b)
        }

        pub fn merge_right(&amp;mut self, mut rhs: Self) {
            if self.len() == 0 {
                self.root = rhs.root;
                self.size = rhs.size;
            } else {
                unsafe {
                    let rmost = self.kth_ptr(self.size - 1).unwrap();
                    self.splay(rmost);
                    (*rmost.as_ptr()).r = rhs.root;
                    if let Some(rhs_root) = rhs.root {
                        (*rhs_root.as_ptr()).p = Some(rmost);
                    }
                    (*rmost.as_ptr()).upd_subtree();
                    self.size = (*rmost.as_ptr()).subt;
                }
            }
            rhs.root = None;
            rhs.size = 0;
        }

        pub fn merge_left(&amp;mut self, mut lhs: Self) {
            if self.len() == 0 {
                self.root = lhs.root;
                self.size = lhs.size;
            } else {
                unsafe {
                    let lmost = self.kth_ptr(0).unwrap();
                    self.splay(lmost);
                    (*lmost.as_ptr()).l = lhs.root;
                    if let Some(lhs_root) = lhs.root {
                        (*lhs_root.as_ptr()).p = Some(lmost);
                    }
                    (*lmost.as_ptr()).upd_subtree();
                    self.size = (*lmost.as_ptr()).subt;
                }
            }
            lhs.root = None;
            lhs.size = 0;
        }

        /// Inserts rope into self at self.
        /// After the operation, rope[0] becomes self[at].
        /// Returns false if the specified index is invalid, true otherwise.
        pub fn insert_rope(&amp;mut self, rope: Self, at: usize) -&gt; bool {
            let rhs = self.take_right(at);
            if let Some(rhs) = rhs {
                self.merge_right(rope);
                self.merge_right(rhs);
                true
            } else {
                false
            }
        }
    }

    impl&lt;T: Clone&gt; Clone for Rope&lt;T&gt; {
        fn clone(&amp;self) -&gt; Self {
            self.iter().cloned().collect()
        }
    }

    impl&lt;T: Debug&gt; Debug for Rope&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;[&quot;)?;
            let mut cnt: usize = 0;
            unsafe {
                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
                let mut curr = self.root;
                loop {
                    while let Some(x) = curr {
                        stack.push(x.as_ptr());
                        curr = (*x.as_ptr()).l;
                    }
                    if let Some(x) = stack.pop() {
                        if cnt == 0 {
                            write!(f, &quot;{:?}&quot;, (*x).data)?;
                        } else {
                            write!(f, &quot;, {:?}&quot;, (*x).data)?;
                        }
                        cnt += 1;
                        curr = (*x).r;
                    } else {
                        break;
                    }
                }
            }
            write!(f, &quot;]&quot;)
        }
    }

    impl&lt;T: Display&gt; Display for Rope&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            unsafe {
                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
                let mut curr = self.root;
                loop {
                    while let Some(x) = curr {
                        stack.push(x.as_ptr());
                        curr = (*x.as_ptr()).l;
                    }
                    if let Some(x) = stack.pop() {
                        write!(f, &quot;{}&quot;, (*x).data)?;
                        curr = (*x).r;
                    } else {
                        break;
                    }
                }
            }
            Ok(())
        }
    }

    impl&lt;T&gt; Drop for Rope&lt;T&gt; {
        fn drop(&amp;mut self) {
            if let Some(root) = self.root {
                unsafe {
                    let mut st: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
                    st.push(root.as_ptr());
                    while let Some(t) = st.pop() {
                        let v = Box::from_raw(t);
                        if let Some(l) = v.l {
                            st.push(l.as_ptr());
                        }
                        if let Some(r) = v.r {
                            st.push(r.as_ptr());
                        }
                        drop(v);
                    }
                }
            }
        }
    }

    impl&lt;T&gt; Index&lt;usize&gt; for Rope&lt;T&gt; {
        type Output = T;
        fn index(&amp;self, idx: usize) -&gt; &amp;Self::Output {
            unsafe {
                let p = self.kth_ptr(idx).unwrap();
                &amp;(*p.as_ptr()).data
            }
        }
    }

    impl&lt;T&gt; IndexMut&lt;usize&gt; for Rope&lt;T&gt; {
        fn index_mut(&amp;mut self, idx: usize) -&gt; &amp;mut Self::Output {
            unsafe {
                let p = self.kth_ptr(idx).unwrap();
                self.splay(p);
                &amp;mut (*p.as_ptr()).data
            }
        }
    }

    impl&lt;T&gt; FromIterator&lt;T&gt; for Rope&lt;T&gt; {
        fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {
            let mut arr = Self::new();
            for v in iter {
                unsafe { arr.push_ontop_root(v) };
            }
            arr
        }
    }

    impl&lt;T&gt; Rope&lt;T&gt; {
        pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
            Iter::new(self)
        }

        pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
            IterMut::new(self)
        }
    }

    pub struct Iter&lt;'a, T&gt; {
        rope: &amp;'a Rope&lt;T&gt;,
        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
        curr: Link&lt;T&gt;,
    }

    impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
        fn new(rope: &amp;'a Rope&lt;T&gt;) -&gt; Self {
            let root = rope.root;
            Self {
                rope,
                stack: Vec::new(),
                curr: root,
            }
        }
    }

    impl&lt;'a, T&gt; IntoIterator for &amp;'a Rope&lt;T&gt; {
        type Item = &amp;'a T;
        type IntoIter = Iter&lt;'a, T&gt;;
        fn into_iter(self) -&gt; Self::IntoIter {
            Self::IntoIter::new(self)
        }
    }

    impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
        type Item = &amp;'a T;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            unsafe {
                while let Some(x) = self.curr {
                    self.stack.push(x);
                    self.curr = (*x.as_ptr()).l;
                }
                if let Some(x) = self.stack.pop() {
                    self.curr = (*x.as_ptr()).r;
                    Some(&amp;x.as_ref().data)
                } else {
                    None
                }
            }
        }

        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
            (self.rope.len(), Some(self.rope.len()))
        }
    }

    pub struct IterMut&lt;'a, T&gt; {
        rope: &amp;'a mut Rope&lt;T&gt;,
        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
        curr: Link&lt;T&gt;,
    }

    impl&lt;'a, T&gt; IterMut&lt;'a, T&gt; {
        fn new(rope: &amp;'a mut Rope&lt;T&gt;) -&gt; Self {
            let root = rope.root;
            Self {
                rope,
                stack: Vec::new(),
                curr: root,
            }
        }
    }

    impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Rope&lt;T&gt; {
        type Item = &amp;'a mut T;
        type IntoIter = IterMut&lt;'a, T&gt;;
        fn into_iter(self) -&gt; Self::IntoIter {
            Self::IntoIter::new(self)
        }
    }

    impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
        type Item = &amp;'a mut T;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            unsafe {
                while let Some(x) = self.curr {
                    self.stack.push(x);
                    self.curr = (*x.as_ptr()).l;
                }
                if let Some(mut x) = self.stack.pop() {
                    self.curr = (*x.as_ptr()).r;
                    Some(&amp;mut x.as_mut().data)
                } else {
                    None
                }
            }
        }

        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
            (self.rope.len(), Some(self.rope.len()))
        }
    }

    //------------------------
    // Helper implementations
    //------------------------

    struct Node&lt;T&gt; {
        data: T,
        subt: usize,
        l: Link&lt;T&gt;,
        r: Link&lt;T&gt;,
        p: Link&lt;T&gt;,
    }

    type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;

    impl&lt;T&gt; Node&lt;T&gt; {
        fn new(data: T) -&gt; Self {
            Node {
                data,
                subt: 1,
                l: None,
                r: None,
                p: None,
            }
        }
        fn left_size(&amp;self) -&gt; usize {
            unsafe { self.l.map_or(0, |l| (*l.as_ptr()).subt) }
        }
        fn right_size(&amp;self) -&gt; usize {
            unsafe { self.r.map_or(0, |r| (*r.as_ptr()).subt) }
        }
        fn upd_subtree(&amp;mut self) {
            self.subt = 1 + self.left_size() + self.right_size();
        }

        // Option&lt;(is_left, parent)&gt;
        unsafe fn is_left_child(x: NonNull&lt;Self&gt;) -&gt; Option&lt;(bool, NonNull&lt;Self&gt;)&gt; {
            if let Some(p) = (*x.as_ptr()).p {
                if (*p.as_ptr())
                    .l
                    .map_or(false, |pl| ptr::eq(x.as_ptr(), pl.as_ptr()))
                {
                    Some((true, p))
                } else {
                    Some((false, p))
                }
            } else {
                None
            }
        }
    }

    impl&lt;T&gt; Rope&lt;T&gt; {
        /// Adds data as a new root of a rope, and putting the original root
        /// as a left child of the root.
        unsafe fn push_ontop_root(&amp;mut self, data: T) {
            let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));
            if let Some(root) = self.root {
                (*root.as_ptr()).p = Some(new_node);
                (*new_node.as_ptr()).l = Some(root);
            }
            self.root = Some(new_node);
            (*new_node.as_ptr()).upd_subtree();
            self.size += 1;
        }

        /// Returns false if x has no parent, and do nothing
        /// Returns true if x has a parent, after performing rotation
        unsafe fn rotate(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; bool {
            if let Some((is_x_left, p)) = Node::is_left_child(x) {
                // Check if p is root
                if let Some(root) = self.root {
                    if ptr::eq(root.as_ptr(), p.as_ptr()) {
                        self.root = Some(x);
                    }
                }

                // Connect x to xpp. If pp is None, do nothing.
                (*x.as_ptr()).p = (*p.as_ptr()).p;
                if let Some((is_p_left, pp)) = Node::is_left_child(p) {
                    if is_p_left {
                        (*pp.as_ptr()).l = Some(x);
                    } else {
                        (*pp.as_ptr()).r = Some(x);
                    }
                }

                if is_x_left {
                    let b = (*x.as_ptr()).r;
                    (*x.as_ptr()).r = Some(p);
                    (*p.as_ptr()).p = Some(x);
                    (*p.as_ptr()).l = b;
                    if let Some(b) = b {
                        (*b.as_ptr()).p = Some(p);
                    }
                } else {
                    let b = (*x.as_ptr()).l;
                    (*x.as_ptr()).l = Some(p);
                    (*p.as_ptr()).p = Some(x);
                    (*p.as_ptr()).r = b;
                    if let Some(b) = b {
                        (*b.as_ptr()).p = Some(p);
                    }
                }

                (*p.as_ptr()).upd_subtree();
                (*x.as_ptr()).upd_subtree();
                true
            } else {
                false
            }
        }

        fn splay(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) {
            unsafe {
                while let Some(root) = self.root {
                    if ptr::eq(x.as_ptr(), root.as_ptr()) {
                        break;
                    }

                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
                        if ptr::eq(root.as_ptr(), p.as_ptr()) {
                            // If p is root, rotate x once
                            self.rotate(x);
                        } else {
                            // Panics if pp doesn't exist, which happens only when p is root
                            let (is_p_left, _pp) = Node::is_left_child(p).unwrap();
                            if is_x_left == is_p_left {
                                self.rotate(p);
                                self.rotate(x);
                            } else {
                                self.rotate(x);
                                self.rotate(x);
                            }
                        }
                    } else {
                        // x has no parent, which should logically never happen
                        unreachable!()
                    }
                }
            }
        }

        unsafe fn kth_ptr(&amp;self, idx: usize) -&gt; Link&lt;T&gt; {
            if self.size &lt;= idx {
                return None;
            }
            if let Some(r) = self.root {
                let mut rem = idx;
                let mut p = r;
                loop {
                    let lsize = (*p.as_ptr()).left_size();
                    match rem.cmp(&amp;lsize) {
                        Ordering::Less =&gt; {
                            p = (*p.as_ptr()).l?;
                        }
                        Ordering::Equal =&gt; {
                            break;
                        }
                        Ordering::Greater =&gt; {
                            rem -= lsize + 1;
                            p = (*p.as_ptr()).r?;
                        }
                    }
                }
                Some(p)
            } else {
                None
            }
        }

        unsafe fn remove_helper(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; NonNull&lt;Node&lt;T&gt;&gt; {
            // Set remove_target to the actual node to delete
            match ((*x.as_ptr()).l, ((*x.as_ptr()).r)) {
                (None, None) =&gt; {
                    // Reset root if the node itself is root
                    if let Some(root) = self.root {
                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
                            self.root = None;
                        }
                    }
                    // Detatch itself from parent
                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
                        if is_x_left {
                            (*p.as_ptr()).l = None;
                        } else {
                            (*p.as_ptr()).r = None;
                        }
                        // Update subtree size
                        let mut p = p;
                        (*p.as_ptr()).upd_subtree();
                        while let Some(pp) = (*p.as_ptr()).p {
                            p = pp;
                            (*p.as_ptr()).upd_subtree();
                        }
                    }
                    x
                }
                (Some(l), None) =&gt; {
                    // Reset root if the node itself is a root
                    if let Some(root) = self.root {
                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
                            self.root = Some(l);
                        }
                    }

                    (*l.as_ptr()).p = (*x.as_ptr()).p;
                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
                        if is_rt_left {
                            (*p.as_ptr()).l = Some(l);
                        } else {
                            (*p.as_ptr()).r = Some(l);
                        }
                    }

                    let mut p = l;
                    while let Some(pp) = (*p.as_ptr()).p {
                        p = pp;
                        (*p.as_ptr()).upd_subtree();
                    }
                    x
                }
                (None, Some(r)) =&gt; {
                    // Reset root if the node itself is a root
                    if let Some(root) = self.root {
                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
                            self.root = Some(r);
                        }
                    }

                    (*r.as_ptr()).p = (*x.as_ptr()).p;
                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
                        if is_rt_left {
                            (*p.as_ptr()).l = Some(r);
                        } else {
                            (*p.as_ptr()).r = Some(r);
                        }
                    }

                    let mut p = r;
                    while let Some(pp) = (*p.as_ptr()).p {
                        p = pp;
                        (*p.as_ptr()).upd_subtree();
                    }
                    x
                }
                (Some(l), Some(_)) =&gt; {
                    let mut sw = l;
                    while let Some(sr) = (*sw.as_ptr()).r {
                        sw = sr;
                    }
                    std::mem::swap(&amp;mut (*x.as_ptr()).data, &amp;mut (*sw.as_ptr()).data);
                    sw = self.remove_helper(sw);
                    sw
                }
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitset"><a class="header" href="#bitset">Bitset</a></h1>
<p><code>BitSet</code> is equivalent to a fixed-size array of booleans. Each boolean value is packed as a bit of <code>u64</code>.</p>
<p>For auto-vectorization, each <code>u64</code> are packed as <code>[u64; 4]</code> so that it can act as a &quot;SIMD lane&quot;.</p>
<p>As this snippet is purely for PS and CP, it does not contain many necessary checks, such as checking if two bitset as an argument of a function has the same length.
For any other purpose, I highly recommend the <a href="https://docs.rs/bitset-core/latest/bitset_core/">bitset_core crate</a> which highly inspired this snippet.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>An array of <code>[u64; 4]</code> implements <code>BitSetOps</code> trait, therefore is recognized as a bitset. The number of booleans packed into the bitset can be found with <code>fn bit_len(&amp;self) -&gt; usize</code>.</p>
<p>Refer to the <a href="datastructure/bitarray.html#apis">APIs</a> for further information.</p>
<h2 id="example-15"><a class="header" href="#example-15">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use bitset::*;
<span class="boring">
</span><span class="boring">fn main() {
</span>const MAX_VAL: usize = 1000000;

let mut is_prime = [[0u64; 4]; (MAX_VAL + 256) / 256];
println!(&quot;{}&quot;, is_prime.bit_len()); // 1000192

is_prime.bit_init(true);
is_prime.bit_reset(0);
is_prime.bit_reset(1);

for i in (2..=MAX_VAL).take_while(|&amp;i| i * i &lt;= MAX_VAL) {
    if is_prime.bit_get(i) {
        for j in (i * i..=MAX_VAL).step_by(i) {
            is_prime.bit_reset(j);
        }
    }
}

println!(
    &quot;{}&quot;,
    is_prime.bit_count_ones() - (is_prime.bit_len() - (MAX_VAL + 1))
); // 78498
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod bitset {
</span><span class="boring">    /* Copyright (c) 2020 Casper &lt;CasualX@users.noreply.github.com&gt;
</span><span class="boring">     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
</span><span class="boring">     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
</span><span class="boring">     * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</span><span class="boring">     */
</span><span class="boring">
</span><span class="boring">    //! This module is purely for PS and CP. Thus it skips safety checks such as checking if
</span><span class="boring">    //! self.len() and rhs.len() are equal, and it may panic if shift overflow (for the whole
</span><span class="boring">    //! bitset) happens.
</span><span class="boring">
</span><span class="boring">    // DO NOT CHANGE THESE VALUES
</span><span class="boring">    // The full generalization for bitset is not done.
</span><span class="boring">    type ElemTy = u64;
</span><span class="boring">    const ELEM_BIT: usize = ElemTy::BITS as usize;
</span><span class="boring">    const ELEM_LEN: usize = 4;
</span><span class="boring">    const BITS_PER_WORD: usize = ELEM_BIT * ELEM_LEN;
</span><span class="boring">
</span><span class="boring">    pub type BitSet = [[ElemTy; ELEM_LEN]];
</span><span class="boring">
</span><span class="boring">    pub trait BitSetOps {
</span><span class="boring">        fn bit_len(&amp;self) -&gt; usize;
</span><span class="boring">        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_get(&amp;self, idx: usize) -&gt; bool;
</span><span class="boring">        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_all(&amp;self) -&gt; bool;
</span><span class="boring">        fn bit_any(&amp;self) -&gt; bool;
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_none(&amp;self) -&gt; bool {
</span><span class="boring">            !self.bit_any()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool;
</span><span class="boring">        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool;
</span><span class="boring">        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool;
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_superset(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            rhs.bit_subset(self)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_not(&amp;mut self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_count_ones(&amp;self) -&gt; usize;
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_count_zeros(&amp;self) -&gt; usize {
</span><span class="boring">            self.bit_len() - self.bit_count_ones()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_fmt(&amp;self) -&gt; &amp;BitFmt&lt;Self&gt; {
</span><span class="boring">            unsafe { &amp;*(self as *const _ as *const _) }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl BitSetOps for BitSet {
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_len(&amp;self) -&gt; usize {
</span><span class="boring">            self.len() * BITS_PER_WORD
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self {
</span><span class="boring">            let val = [ElemTy::wrapping_add(!(val as ElemTy), 1); ELEM_LEN];
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i] = val;
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_get(&amp;self, idx: usize) -&gt; bool {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] &amp; (1 &lt;&lt; bit) != 0
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] |= 1 &lt;&lt; bit;
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] &amp;= !(1 &lt;&lt; bit);
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] ^= 1 &lt;&lt; bit;
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            let mask = 1 &lt;&lt; bit;
</span><span class="boring">            self[block][lane] =
</span><span class="boring">                (self[block][lane] &amp; !mask) | (ElemTy::wrapping_add(!(val as ElemTy), 1) &amp; mask);
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_all(&amp;self) -&gt; bool {
</span><span class="boring">            self.iter()
</span><span class="boring">                .all(|block| block[0] == !0 &amp;&amp; block[1] == !0 &amp;&amp; block[2] == !0 &amp;&amp; block[3] == !0)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_any(&amp;self) -&gt; bool {
</span><span class="boring">            self.iter()
</span><span class="boring">                .all(|block| block[0] == 0 &amp;&amp; block[1] == 0 &amp;&amp; block[2] == 0 &amp;&amp; block[3] == 0)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
</span><span class="boring">                lblk[0] == rblk[0] &amp;&amp; lblk[1] == rblk[1] &amp;&amp; lblk[2] == rblk[2] &amp;&amp; lblk[3] == rblk[3]
</span><span class="boring">            })
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
</span><span class="boring">                lblk[0] &amp; rblk[0] == 0
</span><span class="boring">                    &amp;&amp; lblk[1] &amp; rblk[1] == 0
</span><span class="boring">                    &amp;&amp; lblk[2] &amp; rblk[2] == 0
</span><span class="boring">                    &amp;&amp; lblk[3] &amp; rblk[3] == 0
</span><span class="boring">            })
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
</span><span class="boring">                rblk[0] == rblk[0] | lblk[0]
</span><span class="boring">                    &amp;&amp; rblk[1] == rblk[1] | lblk[1]
</span><span class="boring">                    &amp;&amp; rblk[2] == rblk[2] | lblk[2]
</span><span class="boring">                    &amp;&amp; rblk[3] == rblk[3] | lblk[3]
</span><span class="boring">            })
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] |= rhs[i][0];
</span><span class="boring">                self[i][1] |= rhs[i][1];
</span><span class="boring">                self[i][2] |= rhs[i][2];
</span><span class="boring">                self[i][3] |= rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] &amp;= rhs[i][0];
</span><span class="boring">                self[i][1] &amp;= rhs[i][1];
</span><span class="boring">                self[i][2] &amp;= rhs[i][2];
</span><span class="boring">                self[i][3] &amp;= rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] &amp;= !rhs[i][0];
</span><span class="boring">                self[i][1] &amp;= !rhs[i][1];
</span><span class="boring">                self[i][2] &amp;= !rhs[i][2];
</span><span class="boring">                self[i][3] &amp;= !rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] ^= rhs[i][0];
</span><span class="boring">                self[i][1] ^= rhs[i][1];
</span><span class="boring">                self[i][2] ^= rhs[i][2];
</span><span class="boring">                self[i][3] ^= rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_not(&amp;mut self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] = !self[i][0];
</span><span class="boring">                self[i][1] = !self[i][1];
</span><span class="boring">                self[i][2] = !self[i][2];
</span><span class="boring">                self[i][3] = !self[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] = self[i][0] &amp; !mask[i][0] | rhs[i][0] &amp; mask[i][0];
</span><span class="boring">                self[i][1] = self[i][1] &amp; !mask[i][1] | rhs[i][1] &amp; mask[i][1];
</span><span class="boring">                self[i][2] = self[i][2] &amp; !mask[i][2] | rhs[i][2] &amp; mask[i][2];
</span><span class="boring">                self[i][3] = self[i][3] &amp; !mask[i][3] | rhs[i][3] &amp; mask[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let elem_move = by / ELEM_BIT;
</span><span class="boring">            let bit_move = by % ELEM_BIT;
</span><span class="boring">
</span><span class="boring">            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
</span><span class="boring">            slice.copy_within(..slice.len() - elem_move, elem_move);
</span><span class="boring">            slice[..elem_move].fill(0);
</span><span class="boring">
</span><span class="boring">            if bit_move != 0 {
</span><span class="boring">                let mut carry: ElemTy = 0;
</span><span class="boring">                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
</span><span class="boring">                for i in 0..self.len() {
</span><span class="boring">                    tmp[0] = self[i][0] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[1] = self[i][1] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[2] = self[i][2] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[3] = self[i][3] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    self[i][0] &lt;&lt;= bit_move;
</span><span class="boring">                    self[i][1] &lt;&lt;= bit_move;
</span><span class="boring">                    self[i][2] &lt;&lt;= bit_move;
</span><span class="boring">                    self[i][3] &lt;&lt;= bit_move;
</span><span class="boring">                    let tmpc = tmp[ELEM_LEN - 1];
</span><span class="boring">                    tmp.copy_within(..ELEM_LEN - 1, 1);
</span><span class="boring">                    tmp[0] = carry;
</span><span class="boring">                    self[i][0] |= tmp[0];
</span><span class="boring">                    self[i][1] |= tmp[1];
</span><span class="boring">                    self[i][2] |= tmp[2];
</span><span class="boring">                    self[i][3] |= tmp[3];
</span><span class="boring">                    carry = tmpc;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let elem_move = by / ELEM_BIT;
</span><span class="boring">            let bit_move = by % ELEM_BIT;
</span><span class="boring">
</span><span class="boring">            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
</span><span class="boring">            slice.copy_within(elem_move.., 0);
</span><span class="boring">            let sl = slice.len();
</span><span class="boring">            slice[sl - elem_move..].fill(0);
</span><span class="boring">
</span><span class="boring">            if bit_move != 0 {
</span><span class="boring">                let mut carry: ElemTy = 0;
</span><span class="boring">                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
</span><span class="boring">                for i in 0..self.len() {
</span><span class="boring">                    tmp[0] = self[i][0] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[1] = self[i][1] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[2] = self[i][2] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[3] = self[i][3] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    self[i][0] &gt;&gt;= bit_move;
</span><span class="boring">                    self[i][1] &gt;&gt;= bit_move;
</span><span class="boring">                    self[i][2] &gt;&gt;= bit_move;
</span><span class="boring">                    self[i][3] &gt;&gt;= bit_move;
</span><span class="boring">                    let tmpc = tmp[0];
</span><span class="boring">                    tmp.copy_within(1.., 0);
</span><span class="boring">                    tmp[ELEM_LEN - 1] = carry;
</span><span class="boring">                    carry = tmpc;
</span><span class="boring">                    self[i][0] |= tmp[0];
</span><span class="boring">                    self[i][1] |= tmp[1];
</span><span class="boring">                    self[i][2] |= tmp[2];
</span><span class="boring">                    self[i][3] |= tmp[3];
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_count_ones(&amp;self) -&gt; usize {
</span><span class="boring">            self.iter()
</span><span class="boring">                .map(|chunk| {
</span><span class="boring">                    chunk[0].count_ones() as usize
</span><span class="boring">                        + chunk[1].count_ones() as usize
</span><span class="boring">                        + chunk[2].count_ones() as usize
</span><span class="boring">                        + chunk[3].count_ones() as usize
</span><span class="boring">                })
</span><span class="boring">                .sum()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    mod fmt {
</span><span class="boring">        use super::BitSetOps as BitSet;
</span><span class="boring">        use std::fmt;
</span><span class="boring">
</span><span class="boring">        #[repr(transparent)]
</span><span class="boring">        pub struct BitFmt&lt;T: ?Sized&gt;(T);
</span><span class="boring">
</span><span class="boring">        fn bitstring&lt;T: ?Sized + BitSet&gt;(this: &amp;T, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">            const ALPHABET: [u8; 2] = [b'0', b'1'];
</span><span class="boring">            let mut buf = [0u8; 9];
</span><span class="boring">            let mut first = true;
</span><span class="boring">            buf[0] = b'_';
</span><span class="boring">            let mut i = 0;
</span><span class="boring">            while i &lt; this.bit_len() {
</span><span class="boring">                buf[1] = ALPHABET[this.bit_get(i + 0) as usize];
</span><span class="boring">                buf[2] = ALPHABET[this.bit_get(i + 1) as usize];
</span><span class="boring">                buf[3] = ALPHABET[this.bit_get(i + 2) as usize];
</span><span class="boring">                buf[4] = ALPHABET[this.bit_get(i + 3) as usize];
</span><span class="boring">                buf[5] = ALPHABET[this.bit_get(i + 4) as usize];
</span><span class="boring">                buf[6] = ALPHABET[this.bit_get(i + 5) as usize];
</span><span class="boring">                buf[7] = ALPHABET[this.bit_get(i + 6) as usize];
</span><span class="boring">                buf[8] = ALPHABET[this.bit_get(i + 7) as usize];
</span><span class="boring">                let s = unsafe { &amp;*((&amp;buf[first as usize..]) as *const _ as *const str) };
</span><span class="boring">                f.write_str(s)?;
</span><span class="boring">                i += 8;
</span><span class="boring">                first = false;
</span><span class="boring">            }
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl&lt;T: ?Sized + BitSet&gt; fmt::Display for BitFmt&lt;T&gt; {
</span><span class="boring">            fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">                bitstring(&amp;self.0, f)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub use self::fmt::BitFmt;
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-14"><a class="header" href="#code-14">Code</a></h2>
<pre><code class="language-rust noplayground">mod bitset {
    /* Copyright (c) 2020 Casper &lt;CasualX@users.noreply.github.com&gt;
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */

    //! This module is purely for PS and CP. Thus it skips safety checks such as checking if
    //! self.len() and rhs.len() are equal, and it may panic if shift overflow (for the whole
    //! bitset) happens.

    // DO NOT CHANGE THESE VALUES
    // The full generalization for bitset is not done.
    type ElemTy = u64;
    const ELEM_BIT: usize = ElemTy::BITS as usize;
    const ELEM_LEN: usize = 4;
    const BITS_PER_WORD: usize = ELEM_BIT * ELEM_LEN;

    pub type BitSet = [[ElemTy; ELEM_LEN]];

    pub trait BitSetOps {
        fn bit_len(&amp;self) -&gt; usize;
        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self;

        fn bit_get(&amp;self, idx: usize) -&gt; bool;
        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self;

        fn bit_all(&amp;self) -&gt; bool;
        fn bit_any(&amp;self) -&gt; bool;
        #[inline]
        fn bit_none(&amp;self) -&gt; bool {
            !self.bit_any()
        }

        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool;
        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool;
        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool;
        #[inline]
        fn bit_superset(&amp;self, rhs: &amp;Self) -&gt; bool {
            rhs.bit_subset(self)
        }

        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_not(&amp;mut self) -&gt; &amp;mut Self;
        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self;

        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self;
        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self;

        fn bit_count_ones(&amp;self) -&gt; usize;
        #[inline]
        fn bit_count_zeros(&amp;self) -&gt; usize {
            self.bit_len() - self.bit_count_ones()
        }

        #[inline]
        fn bit_fmt(&amp;self) -&gt; &amp;BitFmt&lt;Self&gt; {
            unsafe { &amp;*(self as *const _ as *const _) }
        }
    }

    impl BitSetOps for BitSet {
        #[inline]
        fn bit_len(&amp;self) -&gt; usize {
            self.len() * BITS_PER_WORD
        }

        #[inline]
        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self {
            let val = [ElemTy::wrapping_add(!(val as ElemTy), 1); ELEM_LEN];
            for i in 0..self.len() {
                self[i] = val;
            }
            self
        }

        #[inline]
        fn bit_get(&amp;self, idx: usize) -&gt; bool {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] &amp; (1 &lt;&lt; bit) != 0
        }

        #[inline]
        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] |= 1 &lt;&lt; bit;
            self
        }

        #[inline]
        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] &amp;= !(1 &lt;&lt; bit);
            self
        }

        #[inline]
        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] ^= 1 &lt;&lt; bit;
            self
        }

        #[inline]
        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            let mask = 1 &lt;&lt; bit;
            self[block][lane] =
                (self[block][lane] &amp; !mask) | (ElemTy::wrapping_add(!(val as ElemTy), 1) &amp; mask);
            self
        }

        #[inline]
        fn bit_all(&amp;self) -&gt; bool {
            self.iter()
                .all(|block| block[0] == !0 &amp;&amp; block[1] == !0 &amp;&amp; block[2] == !0 &amp;&amp; block[3] == !0)
        }

        #[inline]
        fn bit_any(&amp;self) -&gt; bool {
            self.iter()
                .all(|block| block[0] == 0 &amp;&amp; block[1] == 0 &amp;&amp; block[2] == 0 &amp;&amp; block[3] == 0)
        }

        #[inline]
        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
                lblk[0] == rblk[0] &amp;&amp; lblk[1] == rblk[1] &amp;&amp; lblk[2] == rblk[2] &amp;&amp; lblk[3] == rblk[3]
            })
        }

        #[inline]
        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
                lblk[0] &amp; rblk[0] == 0
                    &amp;&amp; lblk[1] &amp; rblk[1] == 0
                    &amp;&amp; lblk[2] &amp; rblk[2] == 0
                    &amp;&amp; lblk[3] &amp; rblk[3] == 0
            })
        }

        /// Returns if self is a subset of rhs
        #[inline]
        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
                rblk[0] == rblk[0] | lblk[0]
                    &amp;&amp; rblk[1] == rblk[1] | lblk[1]
                    &amp;&amp; rblk[2] == rblk[2] | lblk[2]
                    &amp;&amp; rblk[3] == rblk[3] | lblk[3]
            })
        }

        #[inline]
        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] |= rhs[i][0];
                self[i][1] |= rhs[i][1];
                self[i][2] |= rhs[i][2];
                self[i][3] |= rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] &amp;= rhs[i][0];
                self[i][1] &amp;= rhs[i][1];
                self[i][2] &amp;= rhs[i][2];
                self[i][3] &amp;= rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] &amp;= !rhs[i][0];
                self[i][1] &amp;= !rhs[i][1];
                self[i][2] &amp;= !rhs[i][2];
                self[i][3] &amp;= !rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] ^= rhs[i][0];
                self[i][1] ^= rhs[i][1];
                self[i][2] ^= rhs[i][2];
                self[i][3] ^= rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_not(&amp;mut self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] = !self[i][0];
                self[i][1] = !self[i][1];
                self[i][2] = !self[i][2];
                self[i][3] = !self[i][3];
            }
            self
        }

        #[inline]
        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] = self[i][0] &amp; !mask[i][0] | rhs[i][0] &amp; mask[i][0];
                self[i][1] = self[i][1] &amp; !mask[i][1] | rhs[i][1] &amp; mask[i][1];
                self[i][2] = self[i][2] &amp; !mask[i][2] | rhs[i][2] &amp; mask[i][2];
                self[i][3] = self[i][3] &amp; !mask[i][3] | rhs[i][3] &amp; mask[i][3];
            }
            self
        }

        #[inline]
        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self {
            let elem_move = by / ELEM_BIT;
            let bit_move = by % ELEM_BIT;

            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
            slice.copy_within(..slice.len() - elem_move, elem_move);
            slice[..elem_move].fill(0);

            if bit_move != 0 {
                let mut carry: ElemTy = 0;
                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
                for i in 0..self.len() {
                    tmp[0] = self[i][0] &gt;&gt; (ELEM_BIT - bit_move);
                    tmp[1] = self[i][1] &gt;&gt; (ELEM_BIT - bit_move);
                    tmp[2] = self[i][2] &gt;&gt; (ELEM_BIT - bit_move);
                    tmp[3] = self[i][3] &gt;&gt; (ELEM_BIT - bit_move);
                    self[i][0] &lt;&lt;= bit_move;
                    self[i][1] &lt;&lt;= bit_move;
                    self[i][2] &lt;&lt;= bit_move;
                    self[i][3] &lt;&lt;= bit_move;
                    let tmpc = tmp[ELEM_LEN - 1];
                    tmp.copy_within(..ELEM_LEN - 1, 1);
                    tmp[0] = carry;
                    self[i][0] |= tmp[0];
                    self[i][1] |= tmp[1];
                    self[i][2] |= tmp[2];
                    self[i][3] |= tmp[3];
                    carry = tmpc;
                }
            }

            self
        }

        #[inline]
        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self {
            let elem_move = by / ELEM_BIT;
            let bit_move = by % ELEM_BIT;

            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
            slice.copy_within(elem_move.., 0);
            let sl = slice.len();
            slice[sl - elem_move..].fill(0);

            if bit_move != 0 {
                let mut carry: ElemTy = 0;
                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
                for i in 0..self.len() {
                    tmp[0] = self[i][0] &lt;&lt; (ELEM_BIT - bit_move);
                    tmp[1] = self[i][1] &lt;&lt; (ELEM_BIT - bit_move);
                    tmp[2] = self[i][2] &lt;&lt; (ELEM_BIT - bit_move);
                    tmp[3] = self[i][3] &lt;&lt; (ELEM_BIT - bit_move);
                    self[i][0] &gt;&gt;= bit_move;
                    self[i][1] &gt;&gt;= bit_move;
                    self[i][2] &gt;&gt;= bit_move;
                    self[i][3] &gt;&gt;= bit_move;
                    let tmpc = tmp[0];
                    tmp.copy_within(1.., 0);
                    tmp[ELEM_LEN - 1] = carry;
                    carry = tmpc;
                    self[i][0] |= tmp[0];
                    self[i][1] |= tmp[1];
                    self[i][2] |= tmp[2];
                    self[i][3] |= tmp[3];
                }
            }

            self
        }

        #[inline]
        fn bit_count_ones(&amp;self) -&gt; usize {
            self.iter()
                .map(|chunk| {
                    chunk[0].count_ones() as usize
                        + chunk[1].count_ones() as usize
                        + chunk[2].count_ones() as usize
                        + chunk[3].count_ones() as usize
                })
                .sum()
        }
    }

    mod fmt {
        use super::BitSetOps as BitSet;
        use std::fmt;

        #[repr(transparent)]
        pub struct BitFmt&lt;T: ?Sized&gt;(T);

        fn bitstring&lt;T: ?Sized + BitSet&gt;(this: &amp;T, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            const ALPHABET: [u8; 2] = [b'0', b'1'];
            let mut buf = [0u8; 9];
            let mut first = true;
            buf[0] = b'_';
            let mut i = 0;
            while i &lt; this.bit_len() {
                buf[1] = ALPHABET[this.bit_get(i + 0) as usize];
                buf[2] = ALPHABET[this.bit_get(i + 1) as usize];
                buf[3] = ALPHABET[this.bit_get(i + 2) as usize];
                buf[4] = ALPHABET[this.bit_get(i + 3) as usize];
                buf[5] = ALPHABET[this.bit_get(i + 4) as usize];
                buf[6] = ALPHABET[this.bit_get(i + 5) as usize];
                buf[7] = ALPHABET[this.bit_get(i + 6) as usize];
                buf[8] = ALPHABET[this.bit_get(i + 7) as usize];
                let s = unsafe { &amp;*((&amp;buf[first as usize..]) as *const _ as *const str) };
                f.write_str(s)?;
                i += 8;
                first = false;
            }
            Ok(())
        }

        impl&lt;T: ?Sized + BitSet&gt; fmt::Display for BitFmt&lt;T&gt; {
            fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
                bitstring(&amp;self.0, f)
            }
        }
    }
    pub use self::fmt::BitFmt;
}</code></pre>
<h2 id="simd-auto-vectorization-and-rustc-optimization-level"><a class="header" href="#simd-auto-vectorization-and-rustc-optimization-level">SIMD, Auto-vectorization and <code>rustc</code> Optimization Level</a></h2>
<p>To fully enable the power of aggressive SIMD optimization, the <code>opt-level</code> for compilation should be 3.
When the level is 2, despite many of vectorizations still happen, the occurence noticably decreases.</p>
<p>As most of the OJs compile Rust codes with <code>opt-level</code> of 2, to fully enable the power of SIMD, you need to hardcode the machine code into Rust.
As this is virtually impossible to do manually in actual PS/CP, using third-party tools like <a href="https://github.com/kiwiyou/basm-rs">basm-rs</a> is highly recommended.</p>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<p>The behavior of APIs having multiple bitsets as arguments, when their length are not equal to each other, is unspecified.</p>
<ul>
<li>
<p><code>pub type BitSet</code></p>
<p><code>[u64; 4]</code> is defined as a <code>type BitSet</code>.
As this is a dynamically sized type, when declaring a bitset you cannot use <code>BitSet</code> in its type declaration.
Instead, you need to do like the below example.</p>
<pre><code class="language-rust noplayground">let mut bitset</code></pre>
</li>
<li>
<p><code>fn bit_len(&amp;self) -&gt; usize</code></p>
<p>Returns the number of boolean values included in the set.</p>
</li>
<li>
<p><code>fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self</code></p>
<p>Initializes every boolean value of <code>self</code> as <code>val</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_get(&amp;self, idx: usize) -&gt; bool</code></p>
<p>Returns the <code>idx</code>th boolean value of <code>self</code>.</p>
</li>
<li>
<p><code>fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self</code></p>
<p>Sets the <code>idx</code>th boolean value to <code>true</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self</code></p>
<p>Sets the <code>idx</code>th boolean value to <code>false</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self</code></p>
<p>Flips the <code>idx</code>th boolean value, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self</code></p>
<p>Sets the <code>idx</code>th boolean value to <code>val</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_all(&amp;self) -&gt; bool</code></p>
<p>Returns <code>true</code> if every boolean value of <code>self</code> is <code>true</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_none(&amp;self) -&gt; bool</code></p>
<p>Returns <code>true</code> if every boolean value of <code>self</code> is <code>false</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool</code></p>
<p>Returns <code>true</code> if every bit of <code>self</code> turned on is not in <code>rhs</code>, and vice versa. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool</code></p>
<p>Returns <code>true</code> if <code>self</code> is a subset of <code>rhs</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_superset(&amp;self, rhs: &amp;Self) -&gt; bool</code></p>
<p>Returns <code>true</code> if <code>self</code> is a superset of <code>rhs</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self | rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self &amp; rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self &amp; !rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self ^ rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_not(&amp;mut self) -&gt; &amp;mut Self</code></p>
<p>Reverses every bits of <code>self</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>(self &amp; !mask) | (rhs &amp; mask)</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self</code></p>
<p>Shifts <code>self</code> right by <code>by</code>. The direction of shifting is to the lower index.
The empty bits are filled with <code>0</code>, and the overflowed bits disappear.</p>
</li>
<li>
<p><code>fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self</code></p>
<p>Shifts <code>self</code> left by <code>by</code>. The direction of shifting is to the lower index.
The empty bits are filled with <code>0</code>, and the overflowed bits disappear.</p>
</li>
<li>
<p><code>fn bit_count_ones(&amp;self) -&gt; usize</code></p>
<p>Returns the number of boolean values that is <code>true</code>.</p>
</li>
<li>
<p><code>fn bit_count_zeros(&amp;self) -&gt; usize</code></p>
<p>Returns the number of boolean values that is <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_fmt(&amp;self) -&gt; &amp;BitFmt&lt;Self&gt;</code></p>
<p>Used for printing out the bitset.</p>
<pre><code class="language-rust noplayground">println!(&quot;{}&quot;, bitset.bit_fmt());</code></pre>
</li>
</ul>
<h2 id="license-1"><a class="header" href="#license-1">License</a></h2>
<p>This code is protected under MIT license, holded by 
Casper <a href="mailto:datastructure/CasualX@users.noreply.github.com">CasualX@users.noreply.github.com</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dijkstra"><a class="header" href="#dijkstra">Dijkstra</a></h1>
<p><code>dijkstra(graph: &amp;Graph&lt;T&gt;, src: usize)</code> where <code>Graph&lt;T&gt;</code> is a <a href="graphs/./adjlist.html">graph representation</a>, <code>T</code> is a numeric data type, and <code>src</code> is an id of a source node. It returns a <code>dist = Vec&lt;Option&lt;T&gt;&gt;</code>, where <code>dist[dst]</code> is the length of a shortest path from <code>src</code> to <code>dst</code> if it exists, or <code>None</code> if <code>dst</code> is unreachable from <code>src</code>.</p>
<h2 id="example-16"><a class="header" href="#example-16">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">#[allow(unused)]
<span class="boring">use std::{cmp::*, collections::*, iter, mem::*, num::*, ops::*};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut graph: Vec&lt;Vec&lt;(usize, i64)&gt;&gt; = vec![vec![]; 4];
for (u, v, w) in [(0, 1, 5), (1, 2, 5), (1, 2, 15)] {
    graph[u].push((v, w));
    graph[v].push((u, w));
}
println!(&quot;{:?}&quot;, dijkstra(&amp;graph, 0)); // [Some(0), Some(5), Some(10), None]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasNz {
</span><span class="boring">    type NzType;
</span><span class="boring">    fn into_nz(self) -&gt; Option&lt;Self::NzType&gt;;
</span><span class="boring">    fn retrieve(nz: Self::NzType) -&gt; Self;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! impl_hasnz {
</span><span class="boring">    ($($t:ty, $n:ty);*) =&gt; { $(
</span><span class="boring">        impl HasNz for $t {
</span><span class="boring">            type NzType = $n;
</span><span class="boring">            fn into_nz(self) -&gt; Option&lt;$n&gt; { &lt;$n&gt;::new(self) }
</span><span class="boring">            fn retrieve(nz: $n) -&gt; Self { nz.get() }
</span><span class="boring">        }
</span><span class="boring">    )* };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl_hasnz!(i8, NonZeroI8; i16, NonZeroI16; i32, NonZeroI32; i64, NonZeroI64; i128, NonZeroI128; isize, NonZeroIsize);
</span><span class="boring">impl_hasnz!(u8, NonZeroU8; u16, NonZeroU16; u32, NonZeroU32; u64, NonZeroU64; u128, NonZeroU128; usize, NonZeroUsize);
</span><span class="boring">
</span><span class="boring">fn dijkstra&lt;T&gt;(graph: &amp;[Vec&lt;(usize, T)&gt;], src: usize) -&gt; Vec&lt;Option&lt;T&gt;&gt;
</span><span class="boring">where
</span><span class="boring">    T: Copy + From&lt;u8&gt; + Add&lt;Output = T&gt; + Sub&lt;Output = T&gt; + Eq + Ord + HasNz,
</span><span class="boring">    &lt;T as HasNz&gt;::NzType: Copy,
</span><span class="boring">{
</span><span class="boring">    let mut dist: Vec&lt;Option&lt;T::NzType&gt;&gt; = vec![None; graph.len()];
</span><span class="boring">    let mut heap: BinaryHeap&lt;(Reverse&lt;T&gt;, usize)&gt; = BinaryHeap::new();
</span><span class="boring">    heap.push((Reverse(1.into()), src));
</span><span class="boring">
</span><span class="boring">    while let Some((Reverse(curr_cost), curr)) = heap.pop() {
</span><span class="boring">        if dist[curr].map_or(false, |x| T::retrieve(x) &lt; curr_cost) {
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">        dist[curr] = curr_cost.into_nz();
</span><span class="boring">
</span><span class="boring">        for &amp;(next, weight) in graph[curr].iter() {
</span><span class="boring">            let next_cost = curr_cost + weight;
</span><span class="boring">            if dist[next].map_or(true, |x| T::retrieve(x) &gt; next_cost) {
</span><span class="boring">                dist[next] = next_cost.into_nz();
</span><span class="boring">                heap.push((Reverse(next_cost), next));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    dist.iter().map(|x| x.map(|x| T::retrieve(x) - 1.into())).collect()
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-15"><a class="header" href="#code-15">Code</a></h2>
<pre><code class="language-rust noplayground">trait HasNz {
    type NzType;
    fn into_nz(self) -&gt; Option&lt;Self::NzType&gt;;
    fn retrieve(nz: Self::NzType) -&gt; Self;
}

macro_rules! impl_hasnz {
    ($($t:ty, $n:ty);*) =&gt; { $(
        impl HasNz for $t {
            type NzType = $n;
            fn into_nz(self) -&gt; Option&lt;$n&gt; { &lt;$n&gt;::new(self) }
            fn retrieve(nz: $n) -&gt; Self { nz.get() }
        }
    )* };
}

impl_hasnz!(i8, NonZeroI8; i16, NonZeroI16; i32, NonZeroI32; i64, NonZeroI64; i128, NonZeroI128; isize, NonZeroIsize);
impl_hasnz!(u8, NonZeroU8; u16, NonZeroU16; u32, NonZeroU32; u64, NonZeroU64; u128, NonZeroU128; usize, NonZeroUsize);

fn dijkstra&lt;T&gt;(graph: &amp;[Vec&lt;(usize, T)&gt;], src: usize) -&gt; Vec&lt;Option&lt;T&gt;&gt;
where
    T: Copy + From&lt;u8&gt; + Add&lt;Output = T&gt; + Sub&lt;Output = T&gt; + Eq + Ord + HasNz,
    &lt;T as HasNz&gt;::NzType: Copy,
{
    let mut dist: Vec&lt;Option&lt;T::NzType&gt;&gt; = vec![None; graph.len()];
    let mut heap: BinaryHeap&lt;(Reverse&lt;T&gt;, usize)&gt; = BinaryHeap::new();
    heap.push((Reverse(1.into()), src));

    while let Some((Reverse(curr_cost), curr)) = heap.pop() {
        if dist[curr].map_or(false, |x| T::retrieve(x) &lt; curr_cost) {
            continue;
        }
        dist[curr] = curr_cost.into_nz();

        for &amp;(next, weight) in graph[curr].iter() {
            let next_cost = curr_cost + weight;
            if dist[next].map_or(true, |x| T::retrieve(x) &gt; next_cost) {
                dist[next] = next_cost.into_nz();
                heap.push((Reverse(next_cost), next));
            }
        }
    }

    dist.iter().map(|x| x.map(|x| T::retrieve(x) - 1.into())).collect()
}</code></pre>
<h3 id="compact-version"><a class="header" href="#compact-version">Compact Version</a></h3>
<p>The code is much compact, but the performance is slightly worse than the one above. This version seems to be approximately 10% slower, but none of the definitive tests have been done to check it.</p>
<pre><code class="language-rust noplayground">fn dijkstra&lt;T: Copy + From&lt;u8&gt; + Add&lt;Output = T&gt; + Eq + Ord&gt;(graph: &amp;[Vec&lt;(usize, T)&gt;], src: usize) -&gt; Vec&lt;Option&lt;T&gt;&gt; {
    let mut dist: Vec&lt;Option&lt;T&gt;&gt; = vec![None; graph.len()];
    let mut heap: BinaryHeap&lt;(Reverse&lt;T&gt;, usize)&gt; = BinaryHeap::new();
    heap.push((Reverse(0.into()), src));

    while let Some((Reverse(curr_cost), curr)) = heap.pop() {
        if dist[curr].map_or(false, |x| x &lt; curr_cost) {
            continue;
        }
        dist[curr] = Some(curr_cost);

        for &amp;(next, weight) in graph[curr].iter() {
            let next_cost = curr_cost + weight;
            if dist[next].map_or(true, |x| x &gt; next_cost) {
                dist[next] = Some(next_cost);
                heap.push((Reverse(next_cost), next));
            }
        }
    }
    dist
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dial"><a class="header" href="#dial">Dial</a></h1>
<p>Dial algorithm is an alternative to Dijkstra algorithm, which can be used when the maximum value of the edge costs is small. Instead of using a heap, dial algorithm uses a queue of vectors to sort searched paths by their distances. Generally the performance of it is quite similar to that of Dijkstra, but if somehow you want to use this instead, then go ahead!</p>
<p>The usage is exactly the same with Dijkstra algorithm, except that the name of the function is different.</p>
<h2 id="code-16"><a class="header" href="#code-16">Code</a></h2>
<pre><code class="language-rust noplayground">trait HasNz {
    type NzType;
    fn into_nz(self) -&gt; Option&lt;Self::NzType&gt;;
    fn retrieve(nz: Self::NzType) -&gt; Self;
}

macro_rules! impl_hasnz {
    ($($t:ty, $n:ty);*) =&gt; { $(
        impl HasNz for $t {
            type NzType = $n;
            fn into_nz(self) -&gt; Option&lt;$n&gt; { &lt;$n&gt;::new(self) }
            fn retrieve(nz: $n) -&gt; Self { nz.get() }
        }
    )* };
}

impl_hasnz!(i8, NonZeroI8; i16, NonZeroI16; i32, NonZeroI32; i64, NonZeroI64; i128, NonZeroI128; isize, NonZeroIsize);
impl_hasnz!(u8, NonZeroU8; u16, NonZeroU16; u32, NonZeroU32; u64, NonZeroU64; u128, NonZeroU128; usize, NonZeroUsize);

fn dial&lt;T&gt;(graph: &amp;[Vec&lt;(usize, T)&gt;], src: usize) -&gt; Vec&lt;Option&lt;T&gt;&gt;
where
    T: Copy + From&lt;u8&gt; + Into&lt;u32&gt; + Add&lt;Output = T&gt; + Sub&lt;Output = T&gt; + Eq + Ord + HasNz,
    &lt;T as HasNz&gt;::NzType: Copy,
{
    let max_cost: u32 = graph.iter().map(|list| list.iter().map(|&amp;(_, v)| v.into())).flatten().max().unwrap_or(0);

    let mut dist: Vec&lt;Option&lt;T::NzType&gt;&gt; = vec![None; graph.len()];
    dist[src] = {
        let one: T = 1.into();
        one.into_nz()
    };

    let mut qcnt: usize = 1;
    let mut queue = std::collections::VecDeque::with_capacity(max_cost as usize + 2);
    for _ in 0..=queue.capacity() {
        queue.push_back(vec![]);
    }
    queue[0].push(src as u32);

    let mut curr_cost: T = 0.into();
    while qcnt != 0 {
        curr_cost = curr_cost + 1.into();
        let mut hand = queue.pop_front().unwrap();

        while let Some(curr) = hand.pop() {
            qcnt -= 1;
            if dist[curr as usize].map_or(false, |x| T::retrieve(x) &lt; curr_cost) {
                continue;
            }

            for &amp;(next, weight) in graph[curr as usize].iter() {
                let next_cost = curr_cost + weight;

                if dist[next].map_or(true, |x| T::retrieve(x) &gt; next_cost) {
                    dist[next] = next_cost.into_nz();

                    qcnt += 1;
                    if weight == 0.into() {
                        hand.push(next as u32);
                    } else {
                        queue[weight.into() as usize - 1].push(next as u32);
                    }
                }
            }
        }

        queue.push_back(hand);
    }

    dist.iter().map(|x| x.map(|x| T::retrieve(x) - 1.into())).collect()
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strongly-connected-components"><a class="header" href="#strongly-connected-components">Strongly Connected Components</a></h1>
<p>Finding SCCs of a directed graph. Tarjan's algorithm is used for the algorithm.</p>
<h2 id="example-17"><a class="header" href="#example-17">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use scc::*;

<span class="boring">fn main() {
</span>let mut graph = vec![vec![]; 5];
for (u, v) in [(0, 2), (3, 0), (2, 3), (0, 1), (1, 4)] {
    graph[u].push(v);
}

let scc_list = find_scc(&amp;graph);
println!(&quot;{:?}&quot;, scc_list); // [[3, 2, 0], [1], [4]]
let scc_id = gen_scc_ids(&amp;graph, &amp;scc_list);
println!(&quot;{:?}&quot;, scc_id); // [0, 1, 0, 0, 2]
let scc_graph = gen_scc_graph(&amp;graph, &amp;scc_list, &amp;scc_id);
println!(&quot;{:?}&quot;, scc_graph); // [[1], [2], []]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod scc {
</span><span class="boring">    struct SccStack {
</span><span class="boring">        stack: Vec&lt;u32&gt;,
</span><span class="boring">        check: Vec&lt;u64&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl SccStack {
</span><span class="boring">        fn new(cap: usize) -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                stack: vec![0; cap],
</span><span class="boring">                check: vec![0; (cap + 63) / 64],
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn push(&amp;mut self, n: usize) {
</span><span class="boring">            self.stack.push(n as u32);
</span><span class="boring">            self.check[n / 64] |= 1 &lt;&lt; (n % 64);
</span><span class="boring">        }
</span><span class="boring">        fn pop(&amp;mut self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">            let tmp = self.stack.pop()? as usize;
</span><span class="boring">            self.check[tmp / 64] &amp;= !(1 &lt;&lt; (tmp % 64));
</span><span class="boring">            Some(tmp)
</span><span class="boring">        }
</span><span class="boring">        fn contains(&amp;self, n: usize) -&gt; bool {
</span><span class="boring">            self.check[n / 64] &amp; (1 &lt;&lt; (n % 64)) != 0
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    struct DfsPack {
</span><span class="boring">        gid: usize,
</span><span class="boring">        id: Vec&lt;usize&gt;,
</span><span class="boring">        low: Vec&lt;usize&gt;,
</span><span class="boring">        st: SccStack,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn dfs(n: usize, graph: &amp;[Vec&lt;usize&gt;], curr: usize, p: &amp;mut DfsPack, list: &amp;mut Vec&lt;Vec&lt;usize&gt;&gt;) {
</span><span class="boring">        p.st.push(curr);
</span><span class="boring">        p.id[curr] = p.gid;
</span><span class="boring">        p.low[curr] = p.gid;
</span><span class="boring">        p.gid += 1;
</span><span class="boring">
</span><span class="boring">        for &amp;next in graph[curr].iter() {
</span><span class="boring">            if p.id[next] == n {
</span><span class="boring">                dfs(n, graph, next, p, list);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        for &amp;next in graph[curr].iter() {
</span><span class="boring">            if p.st.contains(next) {
</span><span class="boring">                p.low[curr] = p.low[curr].min(p.low[next]);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if p.id[curr] == p.low[curr] {
</span><span class="boring">            let mut newlist = vec![];
</span><span class="boring">            while let Some(popped) = p.st.pop() {
</span><span class="boring">                if popped == curr {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">                newlist.push(popped);
</span><span class="boring">            }
</span><span class="boring">            newlist.push(curr);
</span><span class="boring">            list.push(newlist);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Returns a list of SCCs of `graph`.
</span><span class="boring">    /// The returned list is a 2D vector of `usize`, which consists of a list of vertices within a same SCC.
</span><span class="boring">    /// The order of the SCCs in the returned list is topologically sorted.
</span><span class="boring">    ///
</span><span class="boring">    /// The implementation uses Tarjan's SCC algorithm.
</span><span class="boring">    pub fn find_scc(graph: &amp;[Vec&lt;usize&gt;]) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {
</span><span class="boring">        let n = graph.len();
</span><span class="boring">        let mut list = vec![];
</span><span class="boring">
</span><span class="boring">        let mut p = DfsPack {
</span><span class="boring">            gid: 0,
</span><span class="boring">            id: vec![n; n],
</span><span class="boring">            low: vec![usize::MAX; n],
</span><span class="boring">            st: SccStack::new(n),
</span><span class="boring">        };
</span><span class="boring">        for x in 0..n {
</span><span class="boring">            if p.id[x] != n {
</span><span class="boring">                continue;
</span><span class="boring">            }
</span><span class="boring">            dfs(n, graph, x, &amp;mut p, &amp;mut list);
</span><span class="boring">        }
</span><span class="boring">        list.reverse();
</span><span class="boring">        list
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Returns a list about what SCC each vertices are in.
</span><span class="boring">    /// `scc_list` has to be generated in advance from `find_scc`.
</span><span class="boring">    pub fn gen_scc_ids(graph: &amp;[Vec&lt;usize&gt;], scc_list: &amp;[Vec&lt;usize&gt;]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">        let mut ids = vec![0; graph.len()];
</span><span class="boring">        for (i, l) in scc_list.iter().enumerate() {
</span><span class="boring">            for &amp;v in l {
</span><span class="boring">                ids[v] = i;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ids
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Returns a graph of SCCs. The number of vertices of the new graph will be the number of SCCs in the graph.
</span><span class="boring">    /// `scc_list` and `scc_ids` have to be generated in advanced from `find_scc` and `gen_scc_ids`.
</span><span class="boring">    pub fn gen_scc_graph(graph: &amp;[Vec&lt;usize&gt;], scc_list: &amp;[Vec&lt;usize&gt;], scc_ids: &amp;[usize]) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {
</span><span class="boring">        let mut ret = vec![vec![]; scc_list.len()];
</span><span class="boring">        for u in 0..graph.len() {
</span><span class="boring">            let a = scc_ids[u];
</span><span class="boring">            for &amp;v in graph[u].iter() {
</span><span class="boring">                let b = scc_ids[v];
</span><span class="boring">                if a &lt; b {
</span><span class="boring">                    ret[a].push(b);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ret
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-17"><a class="header" href="#code-17">Code</a></h2>
<pre><code class="language-rust noplayground">mod scc {
    struct SccStack {
        stack: Vec&lt;u32&gt;,
        check: Vec&lt;u64&gt;,
    }

    impl SccStack {
        fn new(cap: usize) -&gt; Self {
            Self {
                stack: vec![0; cap],
                check: vec![0; (cap + 63) / 64],
            }
        }
        fn push(&amp;mut self, n: usize) {
            self.stack.push(n as u32);
            self.check[n / 64] |= 1 &lt;&lt; (n % 64);
        }
        fn pop(&amp;mut self) -&gt; Option&lt;usize&gt; {
            let tmp = self.stack.pop()? as usize;
            self.check[tmp / 64] &amp;= !(1 &lt;&lt; (tmp % 64));
            Some(tmp)
        }
        fn contains(&amp;self, n: usize) -&gt; bool {
            self.check[n / 64] &amp; (1 &lt;&lt; (n % 64)) != 0
        }
    }

    struct DfsPack {
        gid: usize,
        id: Vec&lt;usize&gt;,
        low: Vec&lt;usize&gt;,
        st: SccStack,
    }

    fn dfs(n: usize, graph: &amp;[Vec&lt;usize&gt;], curr: usize, p: &amp;mut DfsPack, list: &amp;mut Vec&lt;Vec&lt;usize&gt;&gt;) {
        p.st.push(curr);
        p.id[curr] = p.gid;
        p.low[curr] = p.gid;
        p.gid += 1;

        for &amp;next in graph[curr].iter() {
            if p.id[next] == n {
                dfs(n, graph, next, p, list);
            }
        }
        for &amp;next in graph[curr].iter() {
            if p.st.contains(next) {
                p.low[curr] = p.low[curr].min(p.low[next]);
            }
        }

        if p.id[curr] == p.low[curr] {
            let mut newlist = vec![];
            while let Some(popped) = p.st.pop() {
                if popped == curr {
                    break;
                }
                newlist.push(popped);
            }
            newlist.push(curr);
            list.push(newlist);
        }
    }

    /// Returns a list of SCCs of `graph`.
    /// The returned list is a 2D vector of `usize`, which consists of a list of vertices within a same SCC.
    /// The order of the SCCs in the returned list is topologically sorted.
    ///
    /// The implementation uses Tarjan's SCC algorithm.
    pub fn find_scc(graph: &amp;[Vec&lt;usize&gt;]) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {
        let n = graph.len();
        let mut list = vec![];

        let mut p = DfsPack {
            gid: 0,
            id: vec![n; n],
            low: vec![usize::MAX; n],
            st: SccStack::new(n),
        };
        for x in 0..n {
            if p.id[x] != n {
                continue;
            }
            dfs(n, graph, x, &amp;mut p, &amp;mut list);
        }
        list.reverse();
        list
    }

    /// Returns a list about what SCC each vertices are in.
    /// `scc_list` has to be generated in advance from `find_scc`.
    pub fn gen_scc_ids(graph: &amp;[Vec&lt;usize&gt;], scc_list: &amp;[Vec&lt;usize&gt;]) -&gt; Vec&lt;usize&gt; {
        let mut ids = vec![0; graph.len()];
        for (i, l) in scc_list.iter().enumerate() {
            for &amp;v in l {
                ids[v] = i;
            }
        }
        ids
    }

    /// Returns a graph of SCCs. The number of vertices of the new graph will be the number of SCCs in the graph.
    /// `scc_list` and `scc_ids` have to be generated in advanced from `find_scc` and `gen_scc_ids`.
    pub fn gen_scc_graph(graph: &amp;[Vec&lt;usize&gt;], scc_list: &amp;[Vec&lt;usize&gt;], scc_ids: &amp;[usize]) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {
        let mut ret = vec![vec![]; scc_list.len()];
        for u in 0..graph.len() {
            let a = scc_ids[u];
            for &amp;v in graph[u].iter() {
                let b = scc_ids[v];
                if a &lt; b {
                    ret[a].push(b);
                }
            }
        }
        ret
    }
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sat"><a class="header" href="#2-sat">2-SAT</a></h1>
<p>2-SAT with \(N\) clauses can be solved with time complexity of \(O(N)\). <a href="graphs/./scc.html">SCC</a> should be with this snippet in the code.</p>
<h2 id="example-18"><a class="header" href="#example-18">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use twosat::*;

<span class="boring">fn main() {
</span>// (not 0 or 1) and (not 1 or 2) and (0 or 2) and (2 or 1)
let mut ts = TwoSat::new(3);
for (a, b) in [((0, false), (1, true)), ((1, false), (2, true)), ((0, true), (2, true)), ((2, true), (1, true))] {
    ts.add_clause(a, b);
}
println!(&quot;{:?}&quot;, ts.solve()); // Some([false, true, true])

// (0 or 0) and (not 0 or not 0)
let mut ts = TwoSat::new(1);
for (a, b) in [((0, true), (0, true)), ((0, false), (0, false))] {
    ts.add_clause(a, b);
}
println!(&quot;{:?}&quot;, ts.solve()); // None
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod scc {
</span><span class="boring">    struct SccStack {
</span><span class="boring">        stack: Vec&lt;u32&gt;,
</span><span class="boring">        check: Vec&lt;u64&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl SccStack {
</span><span class="boring">        fn new(cap: usize) -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                stack: vec![0; cap],
</span><span class="boring">                check: vec![0; (cap + 63) / 64],
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn push(&amp;mut self, n: usize) {
</span><span class="boring">            self.stack.push(n as u32);
</span><span class="boring">            self.check[n / 64] |= 1 &lt;&lt; (n % 64);
</span><span class="boring">        }
</span><span class="boring">        fn pop(&amp;mut self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">            let tmp = self.stack.pop()? as usize;
</span><span class="boring">            self.check[tmp / 64] &amp;= !(1 &lt;&lt; (tmp % 64));
</span><span class="boring">            Some(tmp)
</span><span class="boring">        }
</span><span class="boring">        fn contains(&amp;self, n: usize) -&gt; bool {
</span><span class="boring">            self.check[n / 64] &amp; (1 &lt;&lt; (n % 64)) != 0
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    struct DfsPack {
</span><span class="boring">        gid: usize,
</span><span class="boring">        id: Vec&lt;usize&gt;,
</span><span class="boring">        low: Vec&lt;usize&gt;,
</span><span class="boring">        st: SccStack,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn dfs(n: usize, graph: &amp;[Vec&lt;usize&gt;], curr: usize, p: &amp;mut DfsPack, list: &amp;mut Vec&lt;Vec&lt;usize&gt;&gt;) {
</span><span class="boring">        p.st.push(curr);
</span><span class="boring">        p.id[curr] = p.gid;
</span><span class="boring">        p.low[curr] = p.gid;
</span><span class="boring">        p.gid += 1;
</span><span class="boring">
</span><span class="boring">        for &amp;next in graph[curr].iter() {
</span><span class="boring">            if p.id[next] == n {
</span><span class="boring">                dfs(n, graph, next, p, list);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        for &amp;next in graph[curr].iter() {
</span><span class="boring">            if p.st.contains(next) {
</span><span class="boring">                p.low[curr] = p.low[curr].min(p.low[next]);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if p.id[curr] == p.low[curr] {
</span><span class="boring">            let mut newlist = vec![];
</span><span class="boring">            while let Some(popped) = p.st.pop() {
</span><span class="boring">                if popped == curr {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">                newlist.push(popped);
</span><span class="boring">            }
</span><span class="boring">            newlist.push(curr);
</span><span class="boring">            list.push(newlist);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Returns a list of SCCs of `graph`.
</span><span class="boring">    /// The returned list is a 2D vector of `usize`, which consists of a list of vertices within a same SCC.
</span><span class="boring">    /// The order of the SCCs in the returned list is topologically sorted.
</span><span class="boring">    ///
</span><span class="boring">    /// The implementation uses Tarjan's SCC algorithm.
</span><span class="boring">    pub fn find_scc(graph: &amp;[Vec&lt;usize&gt;]) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {
</span><span class="boring">        let n = graph.len();
</span><span class="boring">        let mut list = vec![];
</span><span class="boring">
</span><span class="boring">        let mut p = DfsPack {
</span><span class="boring">            gid: 0,
</span><span class="boring">            id: vec![n; n],
</span><span class="boring">            low: vec![usize::MAX; n],
</span><span class="boring">            st: SccStack::new(n),
</span><span class="boring">        };
</span><span class="boring">        for x in 0..n {
</span><span class="boring">            if p.id[x] != n {
</span><span class="boring">                continue;
</span><span class="boring">            }
</span><span class="boring">            dfs(n, graph, x, &amp;mut p, &amp;mut list);
</span><span class="boring">        }
</span><span class="boring">        list.reverse();
</span><span class="boring">        list
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Returns a list about what SCC each vertices are in.
</span><span class="boring">    /// `scc_list` has to be generated in advance from `find_scc`.
</span><span class="boring">    pub fn gen_scc_ids(graph: &amp;[Vec&lt;usize&gt;], scc_list: &amp;[Vec&lt;usize&gt;]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">        let mut ids = vec![0; graph.len()];
</span><span class="boring">        for (i, l) in scc_list.iter().enumerate() {
</span><span class="boring">            for &amp;v in l {
</span><span class="boring">                ids[v] = i;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ids
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Returns a graph of SCCs. The number of vertices of the new graph will be the number of SCCs in the graph.
</span><span class="boring">    /// `scc_list` and `scc_ids` have to be generated in advanced from `find_scc` and `gen_scc_ids`.
</span><span class="boring">    pub fn gen_scc_graph(graph: &amp;[Vec&lt;usize&gt;], scc_list: &amp;[Vec&lt;usize&gt;], scc_ids: &amp;[usize]) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {
</span><span class="boring">        let mut ret = vec![vec![]; scc_list.len()];
</span><span class="boring">        for u in 0..graph.len() {
</span><span class="boring">            let a = scc_ids[u];
</span><span class="boring">            for &amp;v in graph[u].iter() {
</span><span class="boring">                let b = scc_ids[v];
</span><span class="boring">                if a &lt; b {
</span><span class="boring">                    ret[a].push(b);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ret
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod twosat {
</span><span class="boring">    use super::scc::*;
</span><span class="boring">
</span><span class="boring">    /// 2-SAT solver.
</span><span class="boring">    pub struct TwoSat {
</span><span class="boring">        n: usize,
</span><span class="boring">        graph: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TwoSat {
</span><span class="boring">        /// Creates a new instance of 2-SAT solver.
</span><span class="boring">        pub fn new(n: usize) -&gt; Self {
</span><span class="boring">            Self { n, graph: vec![vec![]; n &lt;&lt; 1] }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Adds a clause of `(i, f) &amp; (j, g)`.
</span><span class="boring">        /// For example, `self.add_clause((0, false), (1, true))` is adding a clause `~x0 &amp; x1` to the solver.
</span><span class="boring">        pub fn add_clause(&amp;mut self, (i, f): (usize, bool), (j, g): (usize, bool)) {
</span><span class="boring">            let judge = |x: bool, a: usize, b: usize| if x { a } else { b };
</span><span class="boring">            self.graph[i * 2 + judge(f, 0, 1)].push(j * 2 + judge(g, 1, 0));
</span><span class="boring">            self.graph[j * 2 + judge(g, 0, 1)].push(i * 2 + judge(f, 1, 0));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns any possible solution of the 2-SAT problem if there's any in O(N) time.
</span><span class="boring">        /// Returns `None` if the problem is unsolvable.
</span><span class="boring">        pub fn solve(&amp;self) -&gt; Option&lt;Vec&lt;bool&gt;&gt; {
</span><span class="boring">            let mut ans = vec![false; self.n];
</span><span class="boring">            let scc_list = find_scc(&amp;self.graph);
</span><span class="boring">            let ids = gen_scc_ids(&amp;self.graph, &amp;scc_list);
</span><span class="boring">            for i in 0..self.n {
</span><span class="boring">                if ids[i * 2] == ids[i * 2 + 1] {
</span><span class="boring">                    return None;
</span><span class="boring">                }
</span><span class="boring">                ans[i] = ids[i * 2] &lt; ids[i * 2 + 1];
</span><span class="boring">            }
</span><span class="boring">            Some(ans)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-18"><a class="header" href="#code-18">Code</a></h2>
<pre><code class="language-rust noplayground">mod twosat {
    use super::scc::*;

    /// 2-SAT solver.
    pub struct TwoSat {
        n: usize,
        graph: Vec&lt;Vec&lt;usize&gt;&gt;,
    }

    impl TwoSat {
        /// Creates a new instance of 2-SAT solver.
        pub fn new(n: usize) -&gt; Self {
            Self { n, graph: vec![vec![]; n &lt;&lt; 1] }
        }

        /// Adds a clause of `(i, f) &amp; (j, g)`.
        /// For example, `self.add_clause((0, false), (1, true))` is adding a clause `~x0 &amp; x1` to the solver.
        pub fn add_clause(&amp;mut self, (i, f): (usize, bool), (j, g): (usize, bool)) {
            let judge = |x: bool, a: usize, b: usize| if x { a } else { b };
            self.graph[i * 2 + judge(f, 0, 1)].push(j * 2 + judge(g, 1, 0));
            self.graph[j * 2 + judge(g, 0, 1)].push(i * 2 + judge(f, 1, 0));
        }

        /// Returns any possible solution of the 2-SAT problem if there's any in O(N) time.
        /// Returns `None` if the problem is unsolvable.
        pub fn solve(&amp;self) -&gt; Option&lt;Vec&lt;bool&gt;&gt; {
            let mut ans = vec![false; self.n];
            let scc_list = find_scc(&amp;self.graph);
            let ids = gen_scc_ids(&amp;self.graph, &amp;scc_list);
            for i in 0..self.n {
                if ids[i * 2] == ids[i * 2 + 1] {
                    return None;
                }
                ans[i] = ids[i * 2] &lt; ids[i * 2 + 1];
            }
            Some(ans)
        }
    }
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow"><a class="header" href="#flow">Flow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dinics-algorithm"><a class="header" href="#dinics-algorithm">Dinic's Algorithm</a></h1>
<p>Dinic's algorithm is a practically fast algorithm for computing the maximum flow in a flow network.</p>
<p>User can create a network instance with <code>Dinic::new(n)</code> where <code>n</code> is the number of vertices in the network,
and add edges with <code>Dinic::add_edges(&amp;mut self, src, dst, cap)</code> method where <code>cap</code> is the capacity of the edge being added.</p>
<p>Calling <code>Dinic::max_flow(&amp;mut self, src, dst)</code> calculates the maximum flow from <code>src</code> to <code>dst</code>.
After the calculation, remaining capacity of any edges can be found by directly inspecting into <code>cap</code> field of a wanted edge.</p>
<h2 id="example-19"><a class="header" href="#example-19">Example</a></h2>
<p>The example below calculates maximum flow of a flow network shown on page 5 of <a href="https://github.com/justiceHui/SSU-SCCC-Study/blob/master/2022-winter-adv/slide/02.pdf">https://github.com/justiceHui/SSU-SCCC-Study/blob/master/2022-winter-adv/slide/02.pdf</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use dinic::Dinic;
</span><span class="boring">fn main() {
</span>let mut dn = Dinic::new(4);
for (src, dst, cap) in [(0, 1, 2), (0, 2, 2), (1, 2, 1), (1, 3, 2), (2, 3, 2)] {
    dn.add_edge(src, dst, cap);
}

let (src, dst) = (0, 3);
let max_flow = dn.max_flow(src, dst);
println!(&quot;{max_flow}&quot;); // 4

// Remaining capacity of an edge from 0 to 1
let edge = dn.g[0].iter().filter(|e| e.dst == 1).next().unwrap();
println!(&quot;{}&quot;, edge.cap); // 0
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod dinic {
</span><span class="boring">    //! Reference: https://github.com/justiceHui/SSU-SCCC-Study/blob/master/2022-winter-adv/slide/04.pdf
</span><span class="boring">
</span><span class="boring">    use std::collections::VecDeque;
</span><span class="boring">
</span><span class="boring">    #[derive(Clone)]
</span><span class="boring">    pub struct Edge {
</span><span class="boring">        pub dst: u32,
</span><span class="boring">        pub opp: u32,
</span><span class="boring">        pub cap: u64,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Edge {
</span><span class="boring">        fn new(dst: usize, opp: usize, cap: u64) -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                dst: dst as u32,
</span><span class="boring">                opp: opp as u32,
</span><span class="boring">                cap,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct Dinic {
</span><span class="boring">        pub n: usize,
</span><span class="boring">        pub g: Vec&lt;Vec&lt;Edge&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Dinic {
</span><span class="boring">        pub fn new(n: usize) -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                n,
</span><span class="boring">                g: vec![vec![]; n],
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn add_edge(&amp;mut self, s: usize, e: usize, cap: u64) {
</span><span class="boring">            let sl = self.g[s].len();
</span><span class="boring">            let el = self.g[e].len();
</span><span class="boring">            self.g[s].push(Edge::new(e, el, cap));
</span><span class="boring">            self.g[e].push(Edge::new(s, sl, 0));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn bfs(&amp;mut self, s: u32, t: u32, lv: &amp;mut [u32]) -&gt; bool {
</span><span class="boring">            lv.fill(0);
</span><span class="boring">
</span><span class="boring">            let mut queue = VecDeque::new();
</span><span class="boring">            queue.push_back(s);
</span><span class="boring">            lv[s as usize] = 1;
</span><span class="boring">
</span><span class="boring">            while let Some(v) = queue.pop_front() {
</span><span class="boring">                for e in self.g[v as usize].iter() {
</span><span class="boring">                    if lv[e.dst as usize] == 0 &amp;&amp; e.cap != 0 {
</span><span class="boring">                        queue.push_back(e.dst);
</span><span class="boring">                        lv[e.dst as usize] = lv[v as usize] + 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            lv[t as usize] != 0
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn dfs(&amp;mut self, v: u32, t: u32, fl: u64, lv: &amp;[u32], idx: &amp;mut [u32]) -&gt; u64 {
</span><span class="boring">            if v == t || fl == 0 {
</span><span class="boring">                return fl;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            for i in idx[v as usize]..self.g[v as usize].len() as u32 {
</span><span class="boring">                idx[v as usize] = i;
</span><span class="boring">
</span><span class="boring">                let Edge { dst, opp, cap } = self.g[v as usize][i as usize];
</span><span class="boring">                if lv[dst as usize] != lv[v as usize] + 1 || cap == 0 {
</span><span class="boring">                    continue;
</span><span class="boring">                }
</span><span class="boring">                let now = self.dfs(dst, t, fl.min(cap), lv, idx);
</span><span class="boring">                if now == 0 {
</span><span class="boring">                    continue;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                self.g[v as usize][i as usize].cap -= now;
</span><span class="boring">                self.g[dst as usize][opp as usize].cap += now;
</span><span class="boring">                return now;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            0
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn max_flow(&amp;mut self, src: usize, dst: usize) -&gt; u64 {
</span><span class="boring">            let mut flow = 0;
</span><span class="boring">            let mut aug;
</span><span class="boring">            let mut lv = vec![0; self.n];
</span><span class="boring">            let mut idx = vec![0; self.n];
</span><span class="boring">
</span><span class="boring">            while self.bfs(src as u32, dst as u32, &amp;mut lv) {
</span><span class="boring">                idx.fill(0);
</span><span class="boring">                loop {
</span><span class="boring">                    aug = self.dfs(src as u32, dst as u32, u64::MAX, &amp;mut lv, &amp;mut idx);
</span><span class="boring">                    if aug == 0 {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                    flow += aug;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            flow
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-19"><a class="header" href="#code-19">Code</a></h2>
<pre><code class="language-rust noplayground">mod dinic {
    //! Reference: https://github.com/justiceHui/SSU-SCCC-Study/blob/master/2022-winter-adv/slide/04.pdf

    use std::collections::VecDeque;

    #[derive(Clone)]
    pub struct Edge {
        pub dst: u32,
        pub opp: u32,
        pub cap: u64,
    }

    impl Edge {
        fn new(dst: usize, opp: usize, cap: u64) -&gt; Self {
            Self {
                dst: dst as u32,
                opp: opp as u32,
                cap,
            }
        }
    }

    pub struct Dinic {
        pub n: usize,
        pub g: Vec&lt;Vec&lt;Edge&gt;&gt;,
    }

    impl Dinic {
        pub fn new(n: usize) -&gt; Self {
            Self {
                n,
                g: vec![vec![]; n],
            }
        }

        pub fn add_edge(&amp;mut self, s: usize, e: usize, cap: u64) {
            let sl = self.g[s].len();
            let el = self.g[e].len();
            self.g[s].push(Edge::new(e, el, cap));
            self.g[e].push(Edge::new(s, sl, 0));
        }

        fn bfs(&amp;mut self, s: u32, t: u32, lv: &amp;mut [u32]) -&gt; bool {
            lv.fill(0);

            let mut queue = VecDeque::new();
            queue.push_back(s);
            lv[s as usize] = 1;

            while let Some(v) = queue.pop_front() {
                for e in self.g[v as usize].iter() {
                    if lv[e.dst as usize] == 0 &amp;&amp; e.cap != 0 {
                        queue.push_back(e.dst);
                        lv[e.dst as usize] = lv[v as usize] + 1;
                    }
                }
            }

            lv[t as usize] != 0
        }

        fn dfs(&amp;mut self, v: u32, t: u32, fl: u64, lv: &amp;[u32], idx: &amp;mut [u32]) -&gt; u64 {
            if v == t || fl == 0 {
                return fl;
            }

            for i in idx[v as usize]..self.g[v as usize].len() as u32 {
                idx[v as usize] = i;

                let Edge { dst, opp, cap } = self.g[v as usize][i as usize];
                if lv[dst as usize] != lv[v as usize] + 1 || cap == 0 {
                    continue;
                }
                let now = self.dfs(dst, t, fl.min(cap), lv, idx);
                if now == 0 {
                    continue;
                }

                self.g[v as usize][i as usize].cap -= now;
                self.g[dst as usize][opp as usize].cap += now;
                return now;
            }

            0
        }

        pub fn max_flow(&amp;mut self, src: usize, dst: usize) -&gt; u64 {
            let mut flow = 0;
            let mut aug;
            let mut lv = vec![0; self.n];
            let mut idx = vec![0; self.n];

            while self.bfs(src as u32, dst as u32, &amp;mut lv) {
                idx.fill(0);
                loop {
                    aug = self.dfs(src as u32, dst as u32, u64::MAX, &amp;mut lv, &amp;mut idx);
                    if aug == 0 {
                        break;
                    }
                    flow += aug;
                }
            }
            flow
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mcmf"><a class="header" href="#mcmf">MCMF</a></h1>
<p>The APIs of this snippet is similar to those of Dinic's.</p>
<p>The algorithm used for finding shortest path for MCMF is SPFA.</p>
<h2 id="code-20"><a class="header" href="#code-20">Code</a></h2>
<pre><code class="language-rust noplayground">mod mcmf {
    //! Reference: https://github.com/justiceHui/SSU-SCCC-Study/blob/master/2022-winter-adv/slide/04.pdf

    use std::collections::VecDeque;

    #[derive(Clone)]
    pub struct Edge {
        pub dst: u32,
        pub opp: u32,
        pub cap: u64,
        pub cost: i64,
    }

    impl Edge {
        fn new(dst: usize, opp: usize, flow: u64, cost: i64) -&gt; Self {
            Self {
                dst: dst as u32,
                opp: opp as u32,
                cap: flow,
                cost,
            }
        }
    }

    pub struct Mcmf {
        pub n: usize,
        pub g: Vec&lt;Vec&lt;Edge&gt;&gt;,
    }

    impl Mcmf {
        pub fn new(n: usize) -&gt; Self {
            Self {
                n,
                g: vec![vec![]; n],
            }
        }

        pub fn add_edge(&amp;mut self, s: usize, e: usize, c: u64, d: i64) {
            let (slen, elen) = (self.g[s].len(), self.g[e].len());
            self.g[s].push(Edge::new(e, elen, c, d));
            self.g[e].push(Edge::new(s, slen, 0, -d));
        }

        fn augment(
            &amp;mut self,
            s: usize,
            t: usize,
            prv: &amp;mut [usize],
            idx: &amp;mut [usize],
            dst: &amp;mut [i64],
        ) -&gt; bool {
            let mut inn = vec![false; self.n];
            dst.fill(i64::MAX);
            let mut queue = VecDeque::new();
            inn[s] = true;
            dst[s] = 0;
            queue.push_back(s);

            while let Some(v) = queue.pop_front() {
                inn[v] = false;
                for (i, e) in self.g[v].iter().enumerate() {
                    let src = e.dst as usize;
                    if e.cap != 0 &amp;&amp; dst[src] &gt; dst[v] + e.cost {
                        dst[src] = dst[v] + e.cost;
                        prv[src] = v;
                        idx[src] = i;
                        if !inn[src] {
                            inn[src] = true;
                            queue.push_back(src);
                        }
                    }
                }
            }
            dst[t] &lt; i64::MAX
        }

        pub fn min_cost_max_flow(&amp;mut self, s: usize, t: usize) -&gt; (u64, i64) {
            use std::iter::successors;
            let mut flow = 0;
            let mut cost = 0;

            let mut prv = vec![0; self.n];
            let mut idx = vec![0; self.n];
            let mut dst = vec![0; self.n];
            while self.augment(s, t, &amp;mut prv, &amp;mut idx, &amp;mut dst) {
                let path = successors(Some(t), |&amp;i| Some(prv[i]))
                    .take_while(|&amp;i| i != s)
                    .map(|i| self.g[prv[i]][idx[i]].cap)
                    .min()
                    .unwrap();
                flow += path;
                cost += path as i64 * dst[t];
                for i in successors(Some(t), |&amp;i| Some(prv[i])).take_while(|&amp;i| i != s) {
                    self.g[prv[i]][idx[i]].cap -= path;
                    let j = self.g[prv[i]][idx[i]].opp as usize;
                    self.g[i][j].cap += path;
                }
            }

            (flow, cost)
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<p>Given an array <code>pattern</code>, <code>failure_function(pattern)</code> returns a failure function <code>failure</code> of <code>pattern</code>.</p>
<p>Given an array <code>haystack</code>, <code>kmp_search(haystack, pattern, failure)</code> returns a result of searching <code>pattern</code> in <code>haystack</code>, given that <code>failure</code> is a proper failure function of <code>pattern</code>. Denoting the returned array as <code>result</code> and the length of <code>pattern</code> as <code>n</code>, if <code>result[i + n] == n</code>, then <code>result[i..n] == pattern</code>.</p>
<p>The API looks like this, as the failure function itself is needed in many algorithm problems, rather than directly using KMP for a string searching.</p>
<h2 id="example-20"><a class="header" href="#example-20">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let pattern = b&quot;ABCDABC&quot;;
let targets = [&quot;ABDABCDABCE&quot;, &quot;ABCDABCDABCD&quot;, &quot;ABBCCABCDABDABCDABC&quot;].map(|b| b.as_bytes());

let failure = failure_function(pattern);
for &amp;t in &amp;targets {
    let result = kmp_search(t, pattern, &amp;failure);
    println!(&quot;{:?}&quot;, result);
    for i in 0..result.len() - pattern.len() {
        if result[i + pattern.len()] == pattern.len() {
            print!(&quot;{} &quot;, i);
        }
    }
    println!();
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns a failure function of `pattern`.
</span><span class="boring">fn failure_function&lt;T: PartialEq&gt;(pattern: &amp;[T]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    let n = pattern.len();
</span><span class="boring">    let mut c = vec![0, 0];
</span><span class="boring">    let mut x;
</span><span class="boring">    for i in 1..n {
</span><span class="boring">        x = c[i];
</span><span class="boring">        loop {
</span><span class="boring">            if pattern[i] == pattern[x] {
</span><span class="boring">                c.push(x + 1);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">            if x == 0 {
</span><span class="boring">                c.push(0);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">            x = c[x];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    c
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns a result of KMP search.
</span><span class="boring">/// For `n = pattern.len()`, if `result[i] == n`, then `haystack[i-n..i] == pattern`.
</span><span class="boring">fn kmp_search&lt;T: PartialEq&gt;(haystack: &amp;[T], pattern: &amp;[T], failure: &amp;[usize]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    let m = haystack.len();
</span><span class="boring">    let mut d = vec![0];
</span><span class="boring">    let mut x;
</span><span class="boring">    for i in 0..m {
</span><span class="boring">        x = d[i];
</span><span class="boring">        if x == pattern.len() {
</span><span class="boring">            x = failure[x];
</span><span class="boring">        }
</span><span class="boring">        loop {
</span><span class="boring">            if haystack[i] == pattern[x] {
</span><span class="boring">                d.push(x + 1);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">            if x == 0 {
</span><span class="boring">                d.push(0);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">            x = failure[x];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    d
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-21"><a class="header" href="#code-21">Code</a></h2>
<pre><code class="language-rust noplayground">/// Returns a failure function of `pattern`.
fn failure_function&lt;T: PartialEq&gt;(pattern: &amp;[T]) -&gt; Vec&lt;usize&gt; {
    let n = pattern.len();
    let mut c = vec![0, 0];
    let mut x;
    for i in 1..n {
        x = c[i];
        loop {
            if pattern[i] == pattern[x] {
                c.push(x + 1);
                break;
            }
            if x == 0 {
                c.push(0);
                break;
            }
            x = c[x];
        }
    }
    c
}

/// Returns a result of KMP search.
/// For `n = pattern.len()`, if `result[i] == n`, then `haystack[i-n..i] == pattern`.
fn kmp_search&lt;T: PartialEq&gt;(haystack: &amp;[T], pattern: &amp;[T], failure: &amp;[usize]) -&gt; Vec&lt;usize&gt; {
    let m = haystack.len();
    let mut d = vec![0];
    let mut x;
    for i in 0..m {
        x = d[i];
        if x == pattern.len() {
            x = failure[x];
        }
        loop {
            if haystack[i] == pattern[x] {
                d.push(x + 1);
                break;
            }
            if x == 0 {
                d.push(0);
                break;
            }
            x = failure[x];
        }
    }
    d
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<p>For an array \(A\) of length \(n\), <code>manacher(A)</code> returns a vector \(M\) where, for every \(i \in \left[0, n\right)\), \(A_{i-j} = A_{i+j}\) holds for every \(j \in \left[0, M_i \right)\).</p>
<p>Additional modification should be added by a user to use this function for finding every palindromes among subsequences of a string.</p>
<h2 id="example-21"><a class="header" href="#example-21">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = &quot;abracadacabra&quot;.as_bytes();
let man = manacher(s);
println!(&quot;{:?}&quot;, man); // [1, 1, 1, 1, 2, 1, 4, 1, 2, 1, 1, 1, 1]

for i in 0..s.len() {
    println!(
        &quot;{}&quot;,
        std::str::from_utf8(&amp;s[i + 1 - man[i]..i + man[i]]).unwrap()
    );
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn manacher&lt;T: Eq&gt;(arr: &amp;[T]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    let n = arr.len();
</span><span class="boring">    let mut mana: Vec&lt;usize&gt; = vec![1; n];
</span><span class="boring">    let mut r: usize = 1;
</span><span class="boring">    let mut p: usize = 0;
</span><span class="boring">
</span><span class="boring">    for i in 1..arr.len() {
</span><span class="boring">        if i + 1 &gt;= r {
</span><span class="boring">            mana[i] = 1;
</span><span class="boring">        } else {
</span><span class="boring">            let j = 2 * p - i;
</span><span class="boring">            mana[i] = mana[j].min(r - i);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        while mana[i] &lt;= i &amp;&amp; i + mana[i] &lt; n {
</span><span class="boring">            if arr[(i - mana[i])] != arr[(i + mana[i])] {
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">            mana[i] += 1;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if r &lt; mana[i] + i {
</span><span class="boring">            r = mana[i] + i;
</span><span class="boring">            p = i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    mana
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-22"><a class="header" href="#code-22">Code</a></h2>
<pre><code class="language-rust noplayground">fn manacher&lt;T: Eq&gt;(arr: &amp;[T]) -&gt; Vec&lt;usize&gt; {
    let n = arr.len();
    let mut mana: Vec&lt;usize&gt; = vec![1; n];
    let mut r: usize = 1;
    let mut p: usize = 0;

    for i in 1..arr.len() {
        if i + 1 &gt;= r {
            mana[i] = 1;
        } else {
            let j = 2 * p - i;
            mana[i] = mana[j].min(r - i);
        }

        while mana[i] &lt;= i &amp;&amp; i + mana[i] &lt; n {
            if arr[(i - mana[i])] != arr[(i + mana[i])] {
                break;
            }
            mana[i] += 1;
        }

        if r &lt; mana[i] + i {
            r = mana[i] + i;
            p = i;
        }
    }

    mana
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suffix-array-and-lcp-array"><a class="header" href="#suffix-array-and-lcp-array">Suffix Array and LCP Array</a></h1>
<p>For an array \(A\) of length \(n\), <code>sa_lcp(A)</code> returns two vectors \(SA\) and \(LCP\) where,</p>
<ul>
<li>\(A[SA[i] \dots]\) is the \(i\)-th suffix in lexicographical order for every \(i \in \left[0, n\right)\)</li>
</ul>
<p>and</p>
<ul>
<li>\(LCP[i]\) is the length of the longest common prefix between \(A[SA[i-1] \dots]\) and \(A[SA[i] \dots]\) for every \(i \in \left[1, n \right)\). Also, \(LCP[0] = 0\).</li>
</ul>
<p>\(SA\) and \(LCP\) are called &quot;suffix array&quot; and &quot;LCP array&quot; of \(A\) respectively.</p>
<p>For finding SA, Manber-Myers algorithm combined with counting sort is used, hence the time complexity is \(O(n\log{n})\). For LCP array, Kasai's algorithm is used, hence the time complexity is \(O(n)\). The total time complexity is \(O(n\log{n})\).</p>
<h2 id="example-22"><a class="header" href="#example-22">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = &quot;asdsdasd&quot;;
let (sa, lcp) = sa_lcp(s.as_bytes());
println!(&quot;{:?}&quot;, sa);  // [5, 0, 7, 4, 2, 6, 3, 1]
println!(&quot;{:?}&quot;, lcp); // [x, 3, 0, 1, 1, 0, 2, 2]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Suffix array and LCP array
</span><span class="boring">// Reference: http://www.secmem.org/blog/2021/07/18/suffix-array-and-lcp/
</span><span class="boring">
</span><span class="boring">fn suffix_array&lt;T: Ord&gt;(s: &amp;[T]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    use std::collections::*;
</span><span class="boring">
</span><span class="boring">    if s.len() == 0 {
</span><span class="boring">        return vec![];
</span><span class="boring">    } else if s.len() == 1 {
</span><span class="boring">        return vec![0];
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let n = s.len();
</span><span class="boring">
</span><span class="boring">    let mut r: Vec&lt;usize&gt; = vec![0; n * 2];
</span><span class="boring">    let map: BTreeMap&lt;_, _&gt; = {
</span><span class="boring">        let mut sorted: Vec&lt;_&gt; = s.iter().collect();
</span><span class="boring">        sorted.sort_unstable();
</span><span class="boring">        sorted
</span><span class="boring">            .into_iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .map(|x| (x.1, x.0 + 1))
</span><span class="boring">            .collect()
</span><span class="boring">    };
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        r[i] = *map.get(&amp;s[i]).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let m = n.max(map.len()) + 1;
</span><span class="boring">    let mut sa: Vec&lt;usize&gt; = (0..n).collect();
</span><span class="boring">    let mut nr: Vec&lt;usize&gt; = vec![0; n * 2];
</span><span class="boring">    let mut cnt: Vec&lt;usize&gt; = vec![0; m];
</span><span class="boring">    let mut idx: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">
</span><span class="boring">    for d in (0..).map(|x| 1 &lt;&lt; x).take_while(|&amp;d| d &lt; n) {
</span><span class="boring">        macro_rules! key {
</span><span class="boring">            ($i:expr) =&gt; {
</span><span class="boring">                if $i + d &gt;= n {
</span><span class="boring">                    (r[$i], 0)
</span><span class="boring">                } else {
</span><span class="boring">                    (r[$i], r[$i + d])
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        (0..m).for_each(|i| cnt[i] = 0);
</span><span class="boring">        (0..n).for_each(|i| cnt[r[i + d]] += 1);
</span><span class="boring">        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
</span><span class="boring">        for i in (0..n).rev() {
</span><span class="boring">            cnt[r[i + d]] -= 1;
</span><span class="boring">            idx[cnt[r[i + d]]] = i;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        (0..m).for_each(|i| cnt[i] = 0);
</span><span class="boring">        (0..n).for_each(|i| cnt[r[i]] += 1);
</span><span class="boring">        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
</span><span class="boring">        for i in (0..n).rev() {
</span><span class="boring">            cnt[r[idx[i]]] -= 1;
</span><span class="boring">            sa[cnt[r[idx[i]]]] = idx[i];
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        nr[sa[0]] = 1;
</span><span class="boring">        for i in 1..n {
</span><span class="boring">            nr[sa[i]] = nr[sa[i - 1]] + if key!(sa[i - 1]) &lt; key!(sa[i]) { 1 } else { 0 };
</span><span class="boring">        }
</span><span class="boring">        std::mem::swap(&amp;mut r, &amp;mut nr);
</span><span class="boring">
</span><span class="boring">        if r[sa[n - 1]] == n {
</span><span class="boring">            break;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    sa
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn sa_lcp&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
</span><span class="boring">    let n = arr.len();
</span><span class="boring">    let sa = suffix_array(arr);
</span><span class="boring">    let mut lcp: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">    let mut isa: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        isa[sa[i]] = i;
</span><span class="boring">    }
</span><span class="boring">    let mut k = 0;
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        if isa[i] != 0 {
</span><span class="boring">            let j = sa[isa[i] - 1];
</span><span class="boring">            while i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; arr[i + k] == arr[j + k] {
</span><span class="boring">                k += 1;
</span><span class="boring">            }
</span><span class="boring">            lcp[isa[i]] = if k != 0 {
</span><span class="boring">                k -= 1;
</span><span class="boring">                k + 1
</span><span class="boring">            } else {
</span><span class="boring">                0
</span><span class="boring">            };
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    (sa, lcp)
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-23"><a class="header" href="#code-23">Code</a></h2>
<pre><code class="language-rust noplayground">// Suffix array and LCP array
// Reference: http://www.secmem.org/blog/2021/07/18/suffix-array-and-lcp/

fn suffix_array&lt;T: Ord&gt;(s: &amp;[T]) -&gt; Vec&lt;usize&gt; {
    use std::collections::*;

    if s.len() == 0 {
        return vec![];
    } else if s.len() == 1 {
        return vec![0];
    }

    let n = s.len();

    let mut r: Vec&lt;usize&gt; = vec![0; n * 2];
    let map: BTreeMap&lt;_, _&gt; = {
        let mut sorted: Vec&lt;_&gt; = s.iter().collect();
        sorted.sort_unstable();
        sorted
            .into_iter()
            .enumerate()
            .map(|x| (x.1, x.0 + 1))
            .collect()
    };
    for i in 0..n {
        r[i] = *map.get(&amp;s[i]).unwrap();
    }

    let m = n.max(map.len()) + 1;
    let mut sa: Vec&lt;usize&gt; = (0..n).collect();
    let mut nr: Vec&lt;usize&gt; = vec![0; n * 2];
    let mut cnt: Vec&lt;usize&gt; = vec![0; m];
    let mut idx: Vec&lt;usize&gt; = vec![0; n];

    for d in (0..).map(|x| 1 &lt;&lt; x).take_while(|&amp;d| d &lt; n) {
        macro_rules! key {
            ($i:expr) =&gt; {
                if $i + d &gt;= n {
                    (r[$i], 0)
                } else {
                    (r[$i], r[$i + d])
                }
            };
        }

        (0..m).for_each(|i| cnt[i] = 0);
        (0..n).for_each(|i| cnt[r[i + d]] += 1);
        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
        for i in (0..n).rev() {
            cnt[r[i + d]] -= 1;
            idx[cnt[r[i + d]]] = i;
        }

        (0..m).for_each(|i| cnt[i] = 0);
        (0..n).for_each(|i| cnt[r[i]] += 1);
        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
        for i in (0..n).rev() {
            cnt[r[idx[i]]] -= 1;
            sa[cnt[r[idx[i]]]] = idx[i];
        }

        nr[sa[0]] = 1;
        for i in 1..n {
            nr[sa[i]] = nr[sa[i - 1]] + if key!(sa[i - 1]) &lt; key!(sa[i]) { 1 } else { 0 };
        }
        std::mem::swap(&amp;mut r, &amp;mut nr);

        if r[sa[n - 1]] == n {
            break;
        }
    }

    sa
}

fn sa_lcp&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
    let n = arr.len();
    let sa = suffix_array(arr);
    let mut lcp: Vec&lt;usize&gt; = vec![0; n];
    let mut isa: Vec&lt;usize&gt; = vec![0; n];
    for i in 0..n {
        isa[sa[i]] = i;
    }
    let mut k = 0;
    for i in 0..n {
        if isa[i] != 0 {
            let j = sa[isa[i] - 1];
            while i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; arr[i + k] == arr[j + k] {
                k += 1;
            }
            lcp[isa[i]] = if k != 0 {
                k -= 1;
                k + 1
            } else {
                0
            };
        }
    }
    (sa, lcp)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convex-hull"><a class="header" href="#convex-hull">Convex Hull</a></h1>
<p><code>convex_hull</code> finds a convex hull of a given array.
It's implemented based on monotone chain algorithm, a much intuitive and straightforward convex hull algorithm compared to the well-known Graham scan.</p>
<p>If <code>COLLINEAR</code> is set to <code>false</code>, then every point which lies on a vertex of a convex hull, but not at the endpoints of it, is excluded. If it's set to <code>true</code>, then those points are all included.</p>
<p>The result is sorted in clockwise direction.</p>
<p>If the input includes duplicates and those happen to be on the convex hull, then only one of them is included in the result.</p>
<h2 id="code-24"><a class="header" href="#code-24">Code</a></h2>
<pre><code class="language-rust noplayground">type I = i64;
type P = [I; 2];

fn sub(a: P, b: P) -&gt; P { [a[0] - b[0], a[1] - b[1]] }
fn cross(a: P, b: P) -&gt; I { a[0] * b[1] - a[1] * b[0] }
fn ccw(a: P, b: P, c: P) -&gt; I { cross(sub(b, a), sub(c, b)) }

/// Returns a convex hull of `arr`.
/// If `COLLINEAR` is set to `false`, then every point which lies on a vertex of a convex hull, but not at the endpoints of it, is excluded.
/// If `COLLINEAR` is set to `true`, then such points are all included.
/// The result is sorted in CCW direction.
///
/// The implementation utilizes monotone-chain convex hull algorithm.
fn convex_hull&lt;const COLLINEAR: bool&gt;(arr: &amp;[P]) -&gt; Vec&lt;P&gt; {
	let mut arr = arr.to_owned();
	arr.sort_unstable();
	arr.dedup();
	if arr.len() &lt;= 1 {
		return arr;
	}
	let mut ret = vec![];

	fn monotone&lt;const COLLINEAR: bool&gt;(it: impl Iterator&lt;Item = P&gt;) -&gt; Vec&lt;P&gt; {
		let mut dl = vec![];
		for p in it {
			while dl.len() &gt;= 2 {
				let n = dl.len();
				let v = ccw(dl[n - 2], dl[n - 1], p);
				if v &lt; 0 || (!COLLINEAR &amp;&amp; v == 0) {
					dl.pop();
				} else {
					break;
				}
			}
			dl.push(p);
		}
		dl
	}

	ret.extend(monotone::&lt;COLLINEAR&gt;(arr.iter().copied()));
	ret.pop();
	ret.extend(monotone::&lt;COLLINEAR&gt;(arr.iter().copied().rev()));
	ret.pop();

	ret
}</code></pre>
<hr />
<p>Last modified on 231203.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="line-intersection"><a class="header" href="#line-intersection">Line Intersection</a></h1>
<h2 id="code-25"><a class="header" href="#code-25">Code</a></h2>
<pre><code class="language-rust noplayground">type I = i32;
type P = [I; 2];
type L = [P; 2];
type Frac = [i128; 2];

fn sub(a: P, b: P) -&gt; P { [a[0] - b[0], a[1] - b[1]] }
fn cross(a: P, b: P) -&gt; i128 { a[0] as i128 * b[1] as i128 - a[1] as i128 * b[0] as i128 }

/// Returns `None` if `p` and `q` don't meet.
///
/// Returns `Some(Ok([x, y]))` if `p` and `q` meet in a single point `(x, y)`.
/// Here, `x` and `y` have a type of `[i128; 2]` which indicates a fraction, where its first element is a numerator and the second element is a denominator.
///
/// Returns `Some(Err([x, y]))` if `p` and `q` overlaps at a line segment.
/// Here, `x` and `y` represent both ends of the segment.
fn intersect(p: L, q: L) -&gt; Option&lt;Result&lt;[Frac; 2], L&gt;&gt; {
	use std::cmp::Ordering::*;
	let u = cross(sub(p[1], p[0]), sub(q[1], q[0]));
	let sn = cross(sub(q[0], p[0]), sub(q[1], q[0]));
	let tn = cross(sub(q[0], p[0]), sub(p[1], p[0]));
	if u != 0 {
		let int = if u &gt;= 0 { 0..=u } else { u..=0 };
		if int.contains(&amp;sn) &amp;&amp; int.contains(&amp;tn) {
			let (s, r) = (sn, u - sn);
			let [g, h] = p.map(|f| f.map(|x| x as i128));
			let [x, y] = [0, 1].map(|i| [r * g[i] + s * h[i], u]);
			Some(Ok([x, y]))
		} else {
			None
		}
	} else {
		if sn != 0 || tn != 0 {
			return None;
		}
		let (a0, a1) = (p[0].min(p[1]), p[0].max(p[1]));
		let (b0, b1) = (q[0].min(q[1]), q[0].max(q[1]));
		let (l, r) = (a0.max(b0), a1.min(b1));
		match l.cmp(&amp;r) {
			Less =&gt; Some(Err([l, r])),
			Equal =&gt; Some(Ok(l.map(|x| [x.into(), 1]))),
			Greater =&gt; None,
		}
	}
}</code></pre>
<hr />
<p>Last modified on 231203.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="point-in-a-polygon"><a class="header" href="#point-in-a-polygon">Point in a Polygon</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-compression"><a class="header" href="#value-compression">Value Compression</a></h1>
<h2 id="example-23"><a class="header" href="#example-23">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let arr: Vec&lt;i32&gt; = vec![1, 2, 4, 7, 9, 7, 4, 2, 1];

let (compressor, reevaluator) = compress_value(&amp;arr);

let compr: Vec&lt;usize&gt; = arr.iter().map(|x| *compressor.get(x).unwrap()).collect();
println!(&quot;{:?}&quot;, compr);    // [0, 1, 2, 3, 4, 3, 2, 1, 0]

let original: Vec&lt;i32&gt; = compr.iter().map(|&amp;i| *reevaluator[i]).collect();
println!(&quot;{:?}&quot;, original); // [1, 2, 4, 7, 9, 7, 4, 2, 1]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">/// compressor[original_value] = compressed_value
</span><span class="boring">/// reevaluator[compressed_value] = original_value
</span><span class="boring">fn compress_value&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (std::collections::BTreeMap&lt;&amp;T, usize&gt;, Vec&lt;&amp;T&gt;) {
</span><span class="boring">    use std::collections::*;
</span><span class="boring">    let compressor: BTreeMap&lt;&amp;T, usize&gt; = {
</span><span class="boring">        let mut sorted: Vec&lt;_&gt; = arr.iter().collect();
</span><span class="boring">        sorted.sort_unstable();
</span><span class="boring">        sorted.dedup();
</span><span class="boring">        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()
</span><span class="boring">    };
</span><span class="boring">    let reevaluator: Vec&lt;&amp;T&gt; = compressor.iter().map(|x| *x.0).collect();
</span><span class="boring">    (compressor, reevaluator)
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-26"><a class="header" href="#code-26">Code</a></h2>
<pre><code class="language-rust noplayground">/// compressor[original_value] = compressed_value
/// reevaluator[compressed_value] = original_value
fn compress_value&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (std::collections::BTreeMap&lt;&amp;T, usize&gt;, Vec&lt;&amp;T&gt;) {
    use std::collections::*;
    let compressor: BTreeMap&lt;&amp;T, usize&gt; = {
        let mut sorted: Vec&lt;_&gt; = arr.iter().collect();
        sorted.sort_unstable();
        sorted.dedup();
        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()
    };
    let reevaluator: Vec&lt;&amp;T&gt; = compressor.iter().map(|x| *x.0).collect();
    (compressor, reevaluator)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-increasing-subsequence"><a class="header" href="#longest-increasing-subsequence">Longest Increasing Subsequence</a></h1>
<h2 id="length"><a class="header" href="#length">Length</a></h2>
<pre><code class="language-rust noplayground">fn lis_len(arr: &amp;[i64]) -&gt; usize {
    let mut table: Vec&lt;i64&gt; = vec![arr[0]];
    for &amp;v in arr[1..].iter() {
        let p = table.partition_point(|&amp;x| x &lt; v);
        if p == table.len() {
            table.push(v);
        } else {
            table[p] = v;
        }
    }
    table.len()
}</code></pre>
<h2 id="sequence"><a class="header" href="#sequence">Sequence</a></h2>
<pre><code class="language-rust noplayground">fn lis(arr: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
    let n = arr.len();
    let mut seq: Vec&lt;i64&gt; = Vec::with_capacity(n + 1);
    seq.push(i64::MIN);
    seq.extend(arr.iter().copied());

    let mut back = vec![0usize; n + 1];
    let mut table = vec![0usize];

    for (i, &amp;v) in seq.iter().enumerate().skip(1) {
        let p = table.partition_point(|&amp;x| seq[x] &lt; v);
        if p == table.len() {
            table.push(i);
        } else {
            table[p] = i;
        }
        back[i] = table[p - 1];
    }

    let mut ptr = *table.last().unwrap();
    let mut ans: Vec&lt;i64&gt; = Vec::with_capacity(table.len() - 1);
    while ptr != 0 {
        ans.push(seq[ptr]);
        ptr = back[ptr];
    }

    ans.reverse();
    ans
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mos"><a class="header" href="#mos">Mo's</a></h1>
<h2 id="mos-with-hilbert-curve-optimization"><a class="header" href="#mos-with-hilbert-curve-optimization">Mo's with Hilbert Curve Optimization</a></h2>
<p>Reference: <a href="https://codeforces.com/blog/entry/61203">https://codeforces.com/blog/entry/61203</a></p>
<pre><code class="language-rust noplayground">/// max_n: maximum number of l and r
/// queries: Vec&lt;(id, l, r)&gt;
fn mos_sort(max_n: u32, queries: &amp;[(u32, u32, u32)]) -&gt; Vec&lt;&amp;(u32, u32, u32)&gt; {
    let n_bit = ceil_pow_2(max_n + 1).trailing_zeros();
    let mut arr: Vec&lt;(u64, &amp;(u32, u32, u32))&gt; = queries.iter().map(|q| (0, q)).collect();
    for q in arr.iter_mut() {
        q.0 = hilbert_order(q.1 .1, q.1 .2, n_bit, 0);
    }
    arr.sort_unstable_by_key(|q| q.0);
    arr.into_iter().map(|x| x.1).collect()
}

#[inline(always)]
fn hilbert_order(x: u32, y: u32, pow: u32, rotate: u32) -&gt; u64 {
    if pow == 0 {
        return 0;
    }
    let hpow: u32 = 1 &lt;&lt; (pow - 1);
    let mut seg: u32 = if x &lt; hpow {
        if y &lt; hpow {
            0
        } else {
            3
        }
    } else {
        if y &lt; hpow {
            1
        } else {
            2
        }
    };
    seg = (seg + rotate) &amp; 3;

    let (nx, ny) = (x &amp; (x ^ hpow), y &amp; (y ^ hpow));
    let nrot = rotate + ROTATE_DELTA[seg as usize] &amp; 3;
    let sub_square_size = 1u64 &lt;&lt; (2 * pow - 2);
    let ans = seg as u64 * sub_square_size;
    let add = hilbert_order(nx, ny, pow - 1, nrot);
    if seg == 1 || seg == 2 {
        ans + add
    } else {
        ans + sub_square_size - add - 1
    }
}

const ROTATE_DELTA: [u32; 4] = [3, 0, 0, 1];

#[inline(always)]
fn ceil_pow_2(y: u32) -&gt; u32 {
    let mut x = y;
    while x != (x &amp; ((!x) + 1)) {
        x -= x &amp; ((!x) + 1);
    }
    if x == y {
        x
    } else {
        x &lt;&lt; 1
    }
}</code></pre>
<h2 id="standard-mos"><a class="header" href="#standard-mos">Standard Mo's</a></h2>
<pre><code class="language-rust noplayground">/// queries: Vec&lt;(id, l, r)&gt;
fn mos_sort(queries: &amp;mut [(u32, u32, u32)]) {
    let nsq = isqrt(queries.len() as u32);
    queries.sort_unstable_by(|&amp;(_, l1, r1), &amp;(_, l2, r2)| {
        if l1 / nsq == l2 / nsq {
            r1.cmp(&amp;r2)
        } else {
            (l1 / nsq).cmp(&amp;(l2 / nsq))
        }
    });
}

fn isqrt(s: u32) -&gt; u32 {
    let mut x0 = s / 2;
    if x0 != 0 {
        let mut x1 = (x0 + s / x0) / 2;
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) / 2;
        }
        x0
    } else {
        s
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arbitrary-precision-integer"><a class="header" href="#arbitrary-precision-integer">Arbitrary-Precision Integer</a></h1>
<h2 id="example-24"><a class="header" href="#example-24">Example</a></h2>
<pre><code class="language-rust noplayground">use bigint::*;

let _a = Int::from(0i8);
let b = Int::from(4i16);
let c = Int::from(11i32);

let mut x = Int::from(30i64);
x *= &amp;b;
println!(&quot;{}&quot;, x);

let mut y = Int::from_str(&quot;123456789123456789123456789123456789&quot;).unwrap();
let z = &amp;y * &amp;c;
println!(&quot;{}&quot;, y);</code></pre>
<h2 id="code-27"><a class="header" href="#code-27">Code</a></h2>
<pre><code class="language-rust noplayground">mod bigint {
    use core::{
        fmt::Display,
        num::ParseIntError,
        ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign},
        str::FromStr,
    };

    const CHUNK: usize = 5;
    const TENS: i64 = 100000;

    #[derive(Clone, Default, Debug, PartialEq, Eq)]
    pub struct Uint(Vec&lt;i64&gt;);

    macro_rules! flatten {
        ($uint:expr) =&gt; {
            let mut carry: i64 = 0;
            for i in 0..$uint.0.len() {
                $uint.0[i] += carry;
                carry = $uint.0[i].div_euclid(TENS);
                $uint.0[i] -= carry * TENS;
            }
            while carry != 0 {
                $uint.0.push(carry.rem_euclid(TENS));
                carry = carry.div_euclid(TENS);
            }
            while let Some(&amp;x) = $uint.0.last() {
                if x != 0 {
                    break;
                }
                $uint.0.pop();
            }
        };
    }

    macro_rules! impl_from_for_uint {
        ($($t:ty),*) =&gt; {
            $(
                impl From&lt;$t&gt; for Uint {
                    fn from(x: $t) -&gt; Self {
                        let mut x = Self(vec![x as i64]);
                        flatten!(x);
                        x
                    }
                }
            )*
        };
    }
    impl_from_for_uint!(u8, u16, u32, u64, u128, usize);

    impl FromStr for Uint {
        type Err = ParseIntError;
        fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
            let s = s.trim_start_matches(&quot;0&quot;);
            if s.is_empty() {
                return Ok(Self(vec![]));
            }
            let mut arr: Vec&lt;i64&gt; = Vec::with_capacity(s.len() / CHUNK + 2);
            let mut s = s;
            while s.len() &gt; CHUNK {
                let (l, r) = s.split_at(s.len() - CHUNK);
                arr.push(r.parse()?);
                s = l;
            }
            arr.push(s.parse()?);
            Ok(Self(arr))
        }
    }

    impl Display for Uint {
        fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
            write!(f, &quot;{}&quot;, *self.0.last().unwrap_or(&amp;0))?;
            for &amp;v in self.0.iter().rev().skip(1) {
                write!(f, &quot;{:0CHUNK$}&quot;, v)?;
            }
            Ok(())
        }
    }

    impl PartialOrd for Uint {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;core::cmp::Ordering&gt; {
            use core::cmp::Ordering;
            match self.0.len().cmp(&amp;other.0.len()) {
                Ordering::Equal =&gt; {
                    for i in (0..self.0.len()).rev() {
                        let x = self.0[i].cmp(&amp;other.0[i]);
                        if x != Ordering::Equal {
                            return Some(x);
                        }
                    }
                    Some(Ordering::Equal)
                }
                x =&gt; Some(x),
            }
        }
    }

    impl Ord for Uint {
        fn cmp(&amp;self, other: &amp;Self) -&gt; core::cmp::Ordering {
            use core::cmp::Ordering;
            match self.0.len().cmp(&amp;other.0.len()) {
                Ordering::Equal =&gt; {
                    for i in (0..self.0.len()).rev() {
                        let x = self.0[i].cmp(&amp;other.0[i]);
                        if x != Ordering::Equal {
                            return x;
                        }
                    }
                    Ordering::Equal
                }
                x =&gt; x,
            }
        }
    }

    impl AddAssign&lt;&amp;Uint&gt; for Uint {
        fn add_assign(&amp;mut self, rhs: &amp;Uint) {
            if self.0.len() &lt; rhs.0.len() {
                for i in 0..self.0.len() {
                    self.0[i] += rhs.0[i];
                }
                self.0.extend_from_slice(&amp;rhs.0[self.0.len()..]);
            } else {
                for i in 0..rhs.0.len() {
                    self.0[i] += rhs.0[i];
                }
            }

            flatten!(self);
        }
    }

    impl Add for &amp;Uint {
        type Output = Uint;
        fn add(self, rhs: Self) -&gt; Self::Output {
            let mut c = self.clone();
            c += rhs;
            c
        }
    }

    impl SubAssign&lt;&amp;Uint&gt; for Uint {
        fn sub_assign(&amp;mut self, rhs: &amp;Uint) {
            // Panics if self.len() &lt; rhs.len(): Think it as a underflow error
            for (i, &amp;v) in rhs.0.iter().enumerate() {
                self.0[i] -= v;
            }

            flatten!(self);
        }
    }

    impl Sub for &amp;Uint {
        type Output = Uint;
        fn sub(self, rhs: Self) -&gt; Self::Output {
            let mut c = self.clone();
            c -= rhs;
            c
        }
    }

    const NTT_THRES: usize = 5000;
    const KARAT_THRES: usize = 30;

    impl Mul for &amp;Uint {
        type Output = Uint;
        fn mul(self, rhs: Self) -&gt; Self::Output {
            let max_len = self.0.len().max(rhs.0.len());
            let max_2len = polymul::ceil_pow2(max_len);

            // For performance reasons regarding vector copying, we determine whether to use
            // NTT or not here.
            let mut ans = Uint(if max_2len &gt; NTT_THRES {
                polymul::convolute(&amp;self.0, &amp;rhs.0)
            } else {
                let f: Vec&lt;i64&gt; = self
                    .0
                    .iter()
                    .copied()
                    .chain(core::iter::repeat(0))
                    .take(max_2len)
                    .collect();

                let g: Vec&lt;i64&gt; = rhs
                    .0
                    .iter()
                    .copied()
                    .chain(core::iter::repeat(0))
                    .take(max_2len)
                    .collect();

                polymul::mult_2pow(&amp;f, &amp;g)
            });

            flatten!(ans);
            ans
        }
    }

    impl MulAssign&lt;&amp;Uint&gt; for Uint {
        fn mul_assign(&amp;mut self, rhs: &amp;Uint) {
            let x = &amp;*self * rhs;
            *self = x;
        }
    }

    mod polymul {
        pub fn ceil_pow2(n: usize) -&gt; usize {
            if n == 0 {
                return 0;
            }
            let mut m = n;
            while m != m &amp; (!m + 1) {
                m -= m &amp; (!m + 1);
            }
            if n == m {
                n
            } else {
                m * 2
            }
        }

        pub fn mult_2pow(f: &amp;[i64], g: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
            if f.len() &gt; super::KARAT_THRES {
                return karatsuba(f, g);
            }

            let mut ans = vec![0; 2 * f.len()];
            for (i, &amp;a) in f.iter().enumerate() {
                for (j, &amp;b) in g.iter().enumerate() {
                    ans[i + j] += a * b;
                }
            }

            ans
        }

        // Length of f = Length of g = 2n = 2^(k+1)
        fn karatsuba(f: &amp;[i64], g: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
            if f.len() == 1 {
                return vec![f[0] * g[0]];
            }
            let n = f.len() / 2;
            let k = n.trailing_zeros();
            debug_assert_eq!(n, 1 &lt;&lt; k);

            let (fl, fr) = (&amp;f[..n], &amp;f[n..]);
            let (gl, gr) = (&amp;g[..n], &amp;g[n..]);

            let flgl = mult_2pow(fl, gl);
            let frgr = mult_2pow(fr, gr);

            let fsum: Vec&lt;_&gt; = fl.iter().zip(fr.iter()).map(|(&amp;a, &amp;b)| (a + b)).collect();
            let gsum: Vec&lt;_&gt; = gl.iter().zip(gr.iter()).map(|(&amp;a, &amp;b)| (a + b)).collect();
            let fsgs = mult_2pow(&amp;fsum, &amp;gsum);

            let mut ans: Vec&lt;_&gt; = flgl.iter().copied().chain(frgr.iter().copied()).collect();
            for i in 0..fsgs.len() {
                ans[i + n] += fsgs[i];
            }
            for (i, v) in flgl
                .iter()
                .zip(frgr.iter())
                .map(|(&amp;a, &amp;b)| (a + b))
                .enumerate()
            {
                ans[i + n] -= v;
            }

            ans
        }

        const P2INV: i64 = 253522377;

        pub fn convolute(a: &amp;[i64], b: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
            let c1 = ntt1::convolute(a, b);
            let c2 = ntt2::convolute(a, b);

            c1.into_iter()
                .zip(c2.into_iter())
                .map(|(a1, a2)| {
                    let j = ((a1 + ntt1::NTT_P as i64 - a2) * P2INV) % ntt1::NTT_P as i64;
                    ntt2::NTT_P as i64 * j + a2
                })
                .collect()
        }

        // FFT_constname convention following https://algoshitpo.github.io/2020/05/20/fft-ntt/
        macro_rules! impl_ntt {
            ($modname:ident, $nttp:expr, $ntta:expr, $nttb:expr, $nttw:expr) =&gt; {
                mod $modname {
                    pub const NTT_P: u64 = $nttp;
                    const NTT_A: u64 = $ntta;
                    const NTT_B: u32 = $nttb;
                    const NTT_W: u64 = $nttw;

                    fn ceil_pow2(n: usize) -&gt; usize {
                        let mut x: usize = 0;
                        while (1 &lt;&lt; x) &lt; n {
                            x += 1;
                        }
                        x
                    }

                    pub fn convolute(a: &amp;[i64], b: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
                        let nlen = 1 &lt;&lt; ceil_pow2(a.len() + b.len());
                        let mut arr = vec![0; nlen];
                        let mut brr = vec![0; nlen];
                        for (i, &amp;a) in a.iter().enumerate() {
                            arr[i] = a as u64;
                        }
                        for (i, &amp;b) in b.iter().enumerate() {
                            brr[i] = b as u64;
                        }

                        inplace_ntt(&amp;mut arr);
                        inplace_ntt(&amp;mut brr);
                        let mut crr: Vec&lt;_&gt; =
                            arr.iter().zip(brr.iter()).map(|(&amp;a, &amp;b)| a * b).collect();
                        inplace_intt(&amp;mut crr);
                        crr.iter().map(|&amp;x| x as i64).collect()
                    }

                    #[inline(always)]
                    fn rem_pow(mut base: u64, exp: u64) -&gt; u64 {
                        let mut result = 1u64;
                        for exp in core::iter::successors(Some(exp), |x| Some(x &gt;&gt; 1))
                            .take_while(|&amp;v| v != 0)
                        {
                            if exp &amp; 1 != 0 {
                                result *= base;
                                result %= NTT_P;
                            }
                            base *= base;
                            base %= NTT_P;
                        }
                        result
                    }

                    // unity(n, 1) ** (1&lt;&lt;n) = 1
                    fn unity(n: u32, k: u64) -&gt; u64 {
                        rem_pow(rem_pow(NTT_W, NTT_A), k &lt;&lt; (NTT_B - n))
                    }

                    fn recip(x: u64) -&gt; u64 {
                        rem_pow(x, NTT_P - 2)
                    }

                    // Reverses k trailing bits of n
                    fn reverse_trailing_bits(n: usize, k: u32) -&gt; usize {
                        let mut r: usize = 0;
                        for i in 0..k {
                            r |= ((n &gt;&gt; i) &amp; 1) &lt;&lt; (k - i - 1);
                        }
                        r
                    }

                    fn inplace_ntt(arr: &amp;mut [u64]) {
                        let n: usize = arr.len();
                        let k = n.trailing_zeros();
                        assert_eq!(n, 1 &lt;&lt; k);

                        for i in 0..n {
                            let j = reverse_trailing_bits(i, k);
                            if i &lt; j {
                                arr.swap(i, j);
                            }
                        }

                        for x in 0..k {
                            let base: u64 = unity(x + 1, 1);
                            let s = 1 &lt;&lt; x;
                            for i in (0..n).step_by(s &lt;&lt; 1) {
                                let mut mult: u64 = 1;
                                for j in 0..s {
                                    let tmp = (arr[i + j + s] * mult) % NTT_P;
                                    arr[i + j + s] = (arr[i + j] + NTT_P - tmp) % NTT_P;
                                    arr[i + j] = (arr[i + j] + tmp) % NTT_P;
                                    mult *= base;
                                    mult %= NTT_P;
                                }
                            }
                        }
                    }

                    fn inplace_intt(arr: &amp;mut [u64]) {
                        let n: usize = arr.len();
                        let k = n.trailing_zeros();
                        assert_eq!(n, 1 &lt;&lt; k);

                        for i in 0..n {
                            let j = reverse_trailing_bits(i, k);
                            if i &lt; j {
                                arr.swap(i, j);
                            }
                        }

                        for x in 0..k {
                            let base: u64 = recip(unity(x + 1, 1));
                            let s = 1 &lt;&lt; x;
                            for i in (0..n).step_by(s &lt;&lt; 1) {
                                let mut mult: u64 = 1;
                                for j in 0..s {
                                    let tmp = (arr[i + j + s] * mult) % NTT_P;
                                    arr[i + j + s] = (arr[i + j] + NTT_P - tmp) % NTT_P;
                                    arr[i + j] = (arr[i + j] + tmp) % NTT_P;
                                    mult *= base;
                                    mult %= NTT_P;
                                }
                            }
                        }

                        let r = recip(n as u64);
                        for f in arr.iter_mut() {
                            *f *= r;
                            *f %= NTT_P;
                        }
                    }
                }
            };
        }

        impl_ntt!(ntt1, 2281701377, 17, 27, 3);
        impl_ntt!(ntt2, 998244353, 119, 23, 3);
    }

    #[derive(Clone, Copy, PartialEq, Eq, Debug)]
    enum Sign {
        Neg,
        Pos, // Includes 0
    }
    use Sign::*;

    #[derive(Clone, Debug, PartialEq, Eq)]
    pub struct Int {
        sign: Sign,
        nat: Uint,
    }

    macro_rules! impl_from_for_int {
        ($($u:ty, $s:ty);*) =&gt; {
            $(
                impl From&lt;$u&gt; for Int {
                    fn from(x: $u) -&gt; Self {
                        Self { sign: Pos, nat: x.into() }
                    }
                }
                impl From&lt;$s&gt; for Int {
                    fn from(x: $s) -&gt; Self {
                        if x &lt; 0 {
                            Self { sign: Neg, nat: ((-x) as $u).into() }
                        } else {
                            Self { sign: Pos, nat: (x as $u).into() }
                        }
                    }
                }
            )*
        };
    }

    impl_from_for_int!(u8, i8; u16, i16; u32, i32; u64, i64; u128, i128; usize, isize);

    impl FromStr for Int {
        type Err = ParseIntError;
        fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
            if s.len() == 0 {
                panic!(&quot;Empty string - TODO: Add a proper error propagation&quot;);
            }
            let mut x = match s.strip_prefix(&quot;-&quot;) {
                Some(t) =&gt; Self {
                    sign: Neg,
                    nat: t.parse()?,
                },
                None =&gt; Self {
                    sign: Pos,
                    nat: s.parse()?,
                },
            };
            if x.sign == Neg &amp;&amp; x.nat.0.len() == 0 {
                x.sign = Pos;
            }
            Ok(x)
        }
    }

    impl Display for Int {
        fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
            if let Neg = self.sign {
                write!(f, &quot;-&quot;)?;
            }
            write!(f, &quot;{}&quot;, self.nat)
        }
    }

    impl PartialOrd for Int {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;core::cmp::Ordering&gt; {
            use core::cmp::Ordering;
            match (self.sign, other.sign) {
                (Neg, Neg) =&gt; other.nat.partial_cmp(&amp;self.nat),
                (Neg, Pos) =&gt; Some(Ordering::Less),
                (Pos, Neg) =&gt; Some(Ordering::Greater),
                (Pos, Pos) =&gt; self.nat.partial_cmp(&amp;other.nat),
            }
        }
    }

    impl Ord for Int {
        fn cmp(&amp;self, other: &amp;Self) -&gt; core::cmp::Ordering {
            use core::cmp::Ordering;
            match (self.sign, other.sign) {
                (Neg, Neg) =&gt; other.nat.cmp(&amp;self.nat),
                (Neg, Pos) =&gt; Ordering::Less,
                (Pos, Neg) =&gt; Ordering::Greater,
                (Pos, Pos) =&gt; self.nat.cmp(&amp;other.nat),
            }
        }
    }

    impl AddAssign&lt;&amp;Int&gt; for Int {
        fn add_assign(&amp;mut self, rhs: &amp;Int) {
            match (self.sign, rhs.sign) {
                (Neg, Neg) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
                (Neg, Pos) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Pos;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Neg) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Neg;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Pos) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
            }
        }
    }

    impl Add for &amp;Int {
        type Output = Int;
        fn add(self, rhs: Self) -&gt; Self::Output {
            let mut ans = self.clone();
            ans += rhs;
            ans
        }
    }

    impl SubAssign&lt;&amp;Int&gt; for Int {
        fn sub_assign(&amp;mut self, rhs: &amp;Int) {
            match (self.sign, rhs.sign) {
                (Neg, Pos) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
                (Neg, Neg) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Pos;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Pos) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Neg;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Neg) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
            }
        }
    }

    impl Sub for &amp;Int {
        type Output = Int;
        fn sub(self, rhs: Self) -&gt; Self::Output {
            let mut ans = self.clone();
            ans -= &amp;rhs;
            ans
        }
    }

    impl Mul for &amp;Int {
        type Output = Int;
        fn mul(self, rhs: Self) -&gt; Self::Output {
            let x = &amp;self.nat * &amp;rhs.nat;
            if x.0.len() == 0 || self.sign == rhs.sign {
                Int { sign: Pos, nat: x }
            } else {
                Int { sign: Neg, nat: x }
            }
        }
    }

    impl MulAssign&lt;&amp;Int&gt; for Int {
        fn mul_assign(&amp;mut self, rhs: &amp;Int) {
            let x = &amp;self.nat * &amp;rhs.nat;
            self.nat = x;
            if self.nat.0.len() == 0 || self.sign == rhs.sign {
                self.sign = Pos;
            } else {
                self.sign = Neg;
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fraction"><a class="header" href="#fraction">Fraction</a></h1>
<p>TODO: description</p>
<h2 id="example-25"><a class="header" href="#example-25">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>use frac::*;
let mut a = Frac::new(8374927, 2983178).simplify();
println!(&quot;{a}&quot;);

let b: i64 = 31;
a += b;
println!(&quot;{a}&quot;);

let af: f64 = a.into();
println!(&quot;{af:.5}&quot;);

let (l, r) = a.lower_den(100);
println!(&quot;{l} &lt;= {a} &lt;= {r}&quot;);
let (lf, rf): (f64, f64) = (l.into(), r.into());
println!(&quot;{lf:.5} {rf:.5}&quot;);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod frac {
</span><span class="boring">    /// Note: Basic arithmetics on the fraction types do not simplify the fraction to reduce calls of GCD.
</span><span class="boring">    /// Simplifications should all be done manually.
</span><span class="boring">    use std::{fmt::Display, ops::*};
</span><span class="boring">
</span><span class="boring">    /// Numerator type
</span><span class="boring">    pub type I = i64;
</span><span class="boring">    /// Denominator type
</span><span class="boring">    pub type U = u64;
</span><span class="boring">
</span><span class="boring">    /// Fraction type.
</span><span class="boring">    #[derive(Clone, Copy, Debug)]
</span><span class="boring">    pub struct Frac {
</span><span class="boring">        /// Numerator
</span><span class="boring">        pub num: I,
</span><span class="boring">        /// Denominator
</span><span class="boring">        pub den: U,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Frac {
</span><span class="boring">        /// Simplifies the fraction to the minimum denomicator.
</span><span class="boring">        pub fn simplify(self) -&gt; Self {
</span><span class="boring">            fn gcd(mut a: U, mut b: U) -&gt; U {
</span><span class="boring">                while b != 0 {
</span><span class="boring">                    (a, b) = (b, a % b);
</span><span class="boring">                }
</span><span class="boring">                a
</span><span class="boring">            }
</span><span class="boring">            let g = gcd(self.num.unsigned_abs(), self.den);
</span><span class="boring">            Self {
</span><span class="boring">                num: self.num / g as I,
</span><span class="boring">                den: self.den / g,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns a fraction from a given numerator and denominator
</span><span class="boring">        pub fn new(num: I, den: I) -&gt; Self {
</span><span class="boring">            debug_assert_ne!(den, 0);
</span><span class="boring">            if den &lt; 0 {
</span><span class="boring">                Self {
</span><span class="boring">                    num: -num,
</span><span class="boring">                    den: (-den) as U,
</span><span class="boring">                }
</span><span class="boring">            } else {
</span><span class="boring">                Self { num, den: den as U }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns a reciprocal of the fraction
</span><span class="boring">        pub fn recip(self) -&gt; Self {
</span><span class="boring">            use std::cmp::Ordering::*;
</span><span class="boring">            match self.num.cmp(&amp;0) {
</span><span class="boring">                Less =&gt; Self {
</span><span class="boring">                    num: -(self.den as I),
</span><span class="boring">                    den: (-self.num) as U,
</span><span class="boring">                },
</span><span class="boring">                Equal =&gt; panic!(&quot;Reciprocal of zero&quot;),
</span><span class="boring">                Greater =&gt; Self {
</span><span class="boring">                    num: self.den as I,
</span><span class="boring">                    den: self.num as U,
</span><span class="boring">                },
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns a floor of the fraction in an integer form
</span><span class="boring">        pub fn floor(self) -&gt; I {
</span><span class="boring">            let Self { num, den } = self;
</span><span class="boring">            let den = den as I;
</span><span class="boring">            num.div_euclid(den)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns a ceil of the fraction in an integer form
</span><span class="boring">        pub fn ceil(self) -&gt; I {
</span><span class="boring">            let Self { num, den } = self;
</span><span class="boring">            let den = den as I;
</span><span class="boring">            (num + den - 1).div_euclid(den)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns a rounded fraction in an integer form
</span><span class="boring">        pub fn round(self) -&gt; I {
</span><span class="boring">            let Self { num, den } = self;
</span><span class="boring">            let den = den as I;
</span><span class="boring">            (2 * num + den).div_euclid(2 * den)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns self - self.floor()
</span><span class="boring">        pub fn fract(self) -&gt; Self {
</span><span class="boring">            self - self.floor()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns two closest fractions to `x` given a maximum possible value for denominators.
</span><span class="boring">        /// If the fraction is equal to `x` when converted to f64, then the both bounds are equal.
</span><span class="boring">        /// This behavior is subject to change for more accurate approximation.
</span><span class="boring">        pub fn wrap(x: f64, max_den: U) -&gt; (Self, Self) {
</span><span class="boring">            let ipart = x.floor() as I;
</span><span class="boring">            let d = x.fract();
</span><span class="boring">            if d == 0. {
</span><span class="boring">                return (ipart.into(), ipart.into());
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let [(mut ln, mut ld), (mut rn, mut rd)]: [(U, U); 2] = [(0, 1), (1, 1)];
</span><span class="boring">            while (ln, ld) != (rn, rd) {
</span><span class="boring">                let (pl, pr) = ((ln, ld), (rn, rd));
</span><span class="boring">
</span><span class="boring">                // Update l
</span><span class="boring">                let k1 = (ld as f64 * d - ln as f64).div_euclid(rn as f64 - rd as f64 * d) as U;
</span><span class="boring">                let k2 = (max_den - ld).div_euclid(rd);
</span><span class="boring">                let k = k1.min(k2);
</span><span class="boring">                ln += k * rn;
</span><span class="boring">                ld += k * rd;
</span><span class="boring">
</span><span class="boring">                // Update r
</span><span class="boring">                let k1 = (rn as f64 - rd as f64 * d).div_euclid(ld as f64 * d - ln as f64) as U;
</span><span class="boring">                let k2 = (max_den - rd).div_euclid(ld);
</span><span class="boring">                let k = k1.min(k2);
</span><span class="boring">                rn += k * ln;
</span><span class="boring">                rd += k * ld;
</span><span class="boring">
</span><span class="boring">                if pl == (ln, ld) &amp;&amp; pr == (rn, rd) {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let l = Self::new(ln as I, ld as I) + ipart;
</span><span class="boring">            let r = Self::new(rn as I, rd as I) + ipart;
</span><span class="boring">            if x == l.into() {
</span><span class="boring">                (l, l)
</span><span class="boring">            } else if x == r.into() {
</span><span class="boring">                (r, r)
</span><span class="boring">            } else {
</span><span class="boring">                (l, r)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns two fractions `(l, r)` where `l &lt;= self`, `r &gt;= self`, and `l`, `r` both being
</span><span class="boring">        /// the closest to `self` given a maximum value of denominators. This function can be
</span><span class="boring">        /// used for approximating the fraction when the numberator or denominator is getting too
</span><span class="boring">        /// large, but you don't need an exact value of the fraction.
</span><span class="boring">        pub fn lower_den(self, max_den: U) -&gt; (Self, Self) {
</span><span class="boring">            if self.den &lt;= max_den {
</span><span class="boring">                return (self, self);
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let ipart = self.floor();
</span><span class="boring">            let Self { num: dn, den: dd } = self.fract();
</span><span class="boring">            let dn = dn as U;
</span><span class="boring">
</span><span class="boring">            let [(mut ln, mut ld), (mut rn, mut rd)]: [(U, U); 2] = [(0, 1), (1, 1)];
</span><span class="boring">            while (ln, ld) != (rn, rd) {
</span><span class="boring">                let (pl, pr) = ((ln, ld), (rn, rd));
</span><span class="boring">
</span><span class="boring">                // Update l
</span><span class="boring">                let k1 = (ld * dn - ln * dd).div_euclid(rn * dd - rd * dn);
</span><span class="boring">                let k2 = (max_den - ld).div_euclid(rd);
</span><span class="boring">                let k = k1.min(k2);
</span><span class="boring">                ln += k * rn;
</span><span class="boring">                ld += k * rd;
</span><span class="boring">
</span><span class="boring">                // Update r
</span><span class="boring">                let k1 = (rn * dd - rd * dn).div_euclid(ld * dn - ln * dd);
</span><span class="boring">                let k2 = (max_den - rd).div_euclid(ld);
</span><span class="boring">                let k = k1.min(k2);
</span><span class="boring">                rn += k * ln;
</span><span class="boring">                rd += k * ld;
</span><span class="boring">
</span><span class="boring">                if pl == (ln, ld) &amp;&amp; pr == (rn, rd) {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let l = Self::new(ln as I, ld as I) + ipart;
</span><span class="boring">            let r = Self::new(rn as I, rd as I) + ipart;
</span><span class="boring">            (l, r)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Default for Frac {
</span><span class="boring">        fn default() -&gt; Self {
</span><span class="boring">            Frac { num: 0, den: 1 }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Display for Frac {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">            write!(f, &quot;{}/{}&quot;, self.num, self.den)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl From&lt;I&gt; for Frac {
</span><span class="boring">        fn from(num: I) -&gt; Self {
</span><span class="boring">            Self { num, den: 1 }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl From&lt;Frac&gt; for f64 {
</span><span class="boring">        fn from(value: Frac) -&gt; Self {
</span><span class="boring">            value.num as f64 / value.den as f64
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Neg for Frac {
</span><span class="boring">        type Output = Self;
</span><span class="boring">        fn neg(self) -&gt; Self::Output {
</span><span class="boring">            Self {
</span><span class="boring">                num: -self.num,
</span><span class="boring">                den: self.den,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Add for Frac {
</span><span class="boring">        type Output = Self;
</span><span class="boring">        fn add(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">            Self {
</span><span class="boring">                num: self.num * rhs.den as I + self.den as I * rhs.num,
</span><span class="boring">                den: self.den * rhs.den,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Sub for Frac {
</span><span class="boring">        type Output = Self;
</span><span class="boring">        fn sub(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">            Self {
</span><span class="boring">                num: self.num * rhs.den as I - self.den as I * rhs.num,
</span><span class="boring">                den: self.den * rhs.den,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Mul for Frac {
</span><span class="boring">        type Output = Self;
</span><span class="boring">        fn mul(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">            Self {
</span><span class="boring">                num: self.num * rhs.num,
</span><span class="boring">                den: self.den * rhs.den,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Div for Frac {
</span><span class="boring">        type Output = Self;
</span><span class="boring">        fn div(self, rhs: Self) -&gt; Self::Output {
</span><span class="boring">            self * rhs.recip()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Add&lt;I&gt; for Frac {
</span><span class="boring">        type Output = Self;
</span><span class="boring">        fn add(self, rhs: I) -&gt; Self::Output {
</span><span class="boring">            let rhs: Frac = rhs.into();
</span><span class="boring">            self + rhs
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Sub&lt;I&gt; for Frac {
</span><span class="boring">        type Output = Self;
</span><span class="boring">        fn sub(self, rhs: I) -&gt; Self::Output {
</span><span class="boring">            let rhs: Frac = rhs.into();
</span><span class="boring">            self - rhs
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Mul&lt;I&gt; for Frac {
</span><span class="boring">        type Output = Self;
</span><span class="boring">        fn mul(self, rhs: I) -&gt; Self::Output {
</span><span class="boring">            let rhs: Frac = rhs.into();
</span><span class="boring">            self * rhs
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Div&lt;I&gt; for Frac {
</span><span class="boring">        type Output = Self;
</span><span class="boring">        fn div(self, rhs: I) -&gt; Self::Output {
</span><span class="boring">            let rhs: Frac = rhs.into();
</span><span class="boring">            self / rhs
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Add&lt;Frac&gt; for I {
</span><span class="boring">        type Output = Frac;
</span><span class="boring">        fn add(self, rhs: Frac) -&gt; Self::Output {
</span><span class="boring">            rhs + self
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Sub&lt;Frac&gt; for I {
</span><span class="boring">        type Output = Frac;
</span><span class="boring">        fn sub(self, rhs: Frac) -&gt; Self::Output {
</span><span class="boring">            -rhs + self
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Mul&lt;Frac&gt; for I {
</span><span class="boring">        type Output = Frac;
</span><span class="boring">        fn mul(self, rhs: Frac) -&gt; Self::Output {
</span><span class="boring">            rhs * self
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Div&lt;Frac&gt; for I {
</span><span class="boring">        type Output = Frac;
</span><span class="boring">        fn div(self, rhs: Frac) -&gt; Self::Output {
</span><span class="boring">            let lhs: Frac = self.into();
</span><span class="boring">            lhs / rhs
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl AddAssign for Frac {
</span><span class="boring">        fn add_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">            *self = *self + rhs;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl SubAssign for Frac {
</span><span class="boring">        fn sub_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">            *self = *self - rhs;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MulAssign for Frac {
</span><span class="boring">        fn mul_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">            *self = *self * rhs;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl DivAssign for Frac {
</span><span class="boring">        fn div_assign(&amp;mut self, rhs: Self) {
</span><span class="boring">            *self = *self / rhs;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl AddAssign&lt;I&gt; for Frac {
</span><span class="boring">        fn add_assign(&amp;mut self, rhs: I) {
</span><span class="boring">            *self = *self + rhs;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl SubAssign&lt;I&gt; for Frac {
</span><span class="boring">        fn sub_assign(&amp;mut self, rhs: I) {
</span><span class="boring">            *self = *self - rhs;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MulAssign&lt;I&gt; for Frac {
</span><span class="boring">        fn mul_assign(&amp;mut self, rhs: I) {
</span><span class="boring">            *self = *self * rhs;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl DivAssign&lt;I&gt; for Frac {
</span><span class="boring">        fn div_assign(&amp;mut self, rhs: I) {
</span><span class="boring">            *self = *self / rhs;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl PartialEq for Frac {
</span><span class="boring">        fn eq(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            (self.num * rhs.den as I).eq(&amp;(rhs.num * self.den as I))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Eq for Frac {}
</span><span class="boring">
</span><span class="boring">    impl PartialOrd for Frac {
</span><span class="boring">        fn partial_cmp(&amp;self, rhs: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
</span><span class="boring">            (self.num * rhs.den as I).partial_cmp(&amp;(rhs.num * self.den as I))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Ord for Frac {
</span><span class="boring">        fn cmp(&amp;self, rhs: &amp;Self) -&gt; std::cmp::Ordering {
</span><span class="boring">            (self.num * rhs.den as I).cmp(&amp;(rhs.num * self.den as I))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl PartialEq&lt;I&gt; for Frac {
</span><span class="boring">        fn eq(&amp;self, rhs: &amp;I) -&gt; bool {
</span><span class="boring">            let rhs: Frac = (*rhs).into();
</span><span class="boring">            self.eq(&amp;rhs)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl PartialOrd&lt;I&gt; for Frac {
</span><span class="boring">        fn partial_cmp(&amp;self, rhs: &amp;I) -&gt; Option&lt;std::cmp::Ordering&gt; {
</span><span class="boring">            let rhs: Frac = (*rhs).into();
</span><span class="boring">            self.partial_cmp(&amp;rhs)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl PartialEq&lt;Frac&gt; for I {
</span><span class="boring">        fn eq(&amp;self, rhs: &amp;Frac) -&gt; bool {
</span><span class="boring">            let lhs: Frac = (*self).into();
</span><span class="boring">            lhs.eq(rhs)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl PartialOrd&lt;Frac&gt; for I {
</span><span class="boring">        fn partial_cmp(&amp;self, rhs: &amp;Frac) -&gt; Option&lt;std::cmp::Ordering&gt; {
</span><span class="boring">            let lhs: Frac = (*self).into();
</span><span class="boring">            lhs.partial_cmp(rhs)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-28"><a class="header" href="#code-28">Code</a></h2>
<pre><code class="language-rust noplayground">mod frac {
    /// Note: Basic arithmetics on the fraction types do not simplify the fraction to reduce calls of GCD.
    /// Simplifications should all be done manually.
    use std::{fmt::Display, ops::*};

    /// Numerator type
    pub type I = i64;
    /// Denominator type
    pub type U = u64;

    /// Fraction type.
    #[derive(Clone, Copy, Debug)]
    pub struct Frac {
        /// Numerator
        pub num: I,
        /// Denominator
        pub den: U,
    }

    impl Frac {
        /// Simplifies the fraction to the minimum denomicator.
        pub fn simplify(self) -&gt; Self {
            fn gcd(mut a: U, mut b: U) -&gt; U {
                while b != 0 {
                    (a, b) = (b, a % b);
                }
                a
            }
            let g = gcd(self.num.unsigned_abs(), self.den);
            Self {
                num: self.num / g as I,
                den: self.den / g,
            }
        }

        /// Returns a fraction from a given numerator and denominator
        pub fn new(num: I, den: I) -&gt; Self {
            debug_assert_ne!(den, 0);
            if den &lt; 0 {
                Self {
                    num: -num,
                    den: (-den) as U,
                }
            } else {
                Self { num, den: den as U }
            }
        }

        /// Returns a reciprocal of the fraction
        pub fn recip(self) -&gt; Self {
            use std::cmp::Ordering::*;
            match self.num.cmp(&amp;0) {
                Less =&gt; Self {
                    num: -(self.den as I),
                    den: (-self.num) as U,
                },
                Equal =&gt; panic!(&quot;Reciprocal of zero&quot;),
                Greater =&gt; Self {
                    num: self.den as I,
                    den: self.num as U,
                },
            }
        }

        /// Returns a floor of the fraction in an integer form
        pub fn floor(self) -&gt; I {
            let Self { num, den } = self;
            let den = den as I;
            num.div_euclid(den)
        }

        /// Returns a ceil of the fraction in an integer form
        pub fn ceil(self) -&gt; I {
            let Self { num, den } = self;
            let den = den as I;
            (num + den - 1).div_euclid(den)
        }

        /// Returns a rounded fraction in an integer form
        pub fn round(self) -&gt; I {
            let Self { num, den } = self;
            let den = den as I;
            (2 * num + den).div_euclid(2 * den)
        }

        /// Returns self - self.floor()
        pub fn fract(self) -&gt; Self {
            self - self.floor()
        }

        /// Returns two closest fractions to `x` given a maximum possible value for denominators.
        /// If the fraction is equal to `x` when converted to f64, then the both bounds are equal.
        /// This behavior is subject to change for more accurate approximation.
        pub fn wrap(x: f64, max_den: U) -&gt; (Self, Self) {
            let ipart = x.floor() as I;
            let d = x.fract();
            if d == 0. {
                return (ipart.into(), ipart.into());
            }

            let [(mut ln, mut ld), (mut rn, mut rd)]: [(U, U); 2] = [(0, 1), (1, 1)];
            while (ln, ld) != (rn, rd) {
                let (pl, pr) = ((ln, ld), (rn, rd));

                // Update l
                let k1 = (ld as f64 * d - ln as f64).div_euclid(rn as f64 - rd as f64 * d) as U;
                let k2 = (max_den - ld).div_euclid(rd);
                let k = k1.min(k2);
                ln += k * rn;
                ld += k * rd;

                // Update r
                let k1 = (rn as f64 - rd as f64 * d).div_euclid(ld as f64 * d - ln as f64) as U;
                let k2 = (max_den - rd).div_euclid(ld);
                let k = k1.min(k2);
                rn += k * ln;
                rd += k * ld;

                if pl == (ln, ld) &amp;&amp; pr == (rn, rd) {
                    break;
                }
            }

            let l = Self::new(ln as I, ld as I) + ipart;
            let r = Self::new(rn as I, rd as I) + ipart;
            if x == l.into() {
                (l, l)
            } else if x == r.into() {
                (r, r)
            } else {
                (l, r)
            }
        }

        /// Returns two fractions `(l, r)` where `l &lt;= self`, `r &gt;= self`, and `l`, `r` both being
        /// the closest to `self` given a maximum value of denominators. This function can be
        /// used for approximating the fraction when the numberator or denominator is getting too
        /// large, but you don't need an exact value of the fraction.
        pub fn lower_den(self, max_den: U) -&gt; (Self, Self) {
            if self.den &lt;= max_den {
                return (self, self);
            }

            let ipart = self.floor();
            let Self { num: dn, den: dd } = self.fract();
            let dn = dn as U;

            let [(mut ln, mut ld), (mut rn, mut rd)]: [(U, U); 2] = [(0, 1), (1, 1)];
            while (ln, ld) != (rn, rd) {
                let (pl, pr) = ((ln, ld), (rn, rd));

                // Update l
                let k1 = (ld * dn - ln * dd).div_euclid(rn * dd - rd * dn);
                let k2 = (max_den - ld).div_euclid(rd);
                let k = k1.min(k2);
                ln += k * rn;
                ld += k * rd;

                // Update r
                let k1 = (rn * dd - rd * dn).div_euclid(ld * dn - ln * dd);
                let k2 = (max_den - rd).div_euclid(ld);
                let k = k1.min(k2);
                rn += k * ln;
                rd += k * ld;

                if pl == (ln, ld) &amp;&amp; pr == (rn, rd) {
                    break;
                }
            }

            let l = Self::new(ln as I, ld as I) + ipart;
            let r = Self::new(rn as I, rd as I) + ipart;
            (l, r)
        }
    }

    impl Default for Frac {
        fn default() -&gt; Self {
            Frac { num: 0, den: 1 }
        }
    }

    impl Display for Frac {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{}/{}&quot;, self.num, self.den)
        }
    }

    impl From&lt;I&gt; for Frac {
        fn from(num: I) -&gt; Self {
            Self { num, den: 1 }
        }
    }

    impl From&lt;Frac&gt; for f64 {
        fn from(value: Frac) -&gt; Self {
            value.num as f64 / value.den as f64
        }
    }

    impl Neg for Frac {
        type Output = Self;
        fn neg(self) -&gt; Self::Output {
            Self {
                num: -self.num,
                den: self.den,
            }
        }
    }

    impl Add for Frac {
        type Output = Self;
        fn add(self, rhs: Self) -&gt; Self::Output {
            Self {
                num: self.num * rhs.den as I + self.den as I * rhs.num,
                den: self.den * rhs.den,
            }
        }
    }

    impl Sub for Frac {
        type Output = Self;
        fn sub(self, rhs: Self) -&gt; Self::Output {
            Self {
                num: self.num * rhs.den as I - self.den as I * rhs.num,
                den: self.den * rhs.den,
            }
        }
    }

    impl Mul for Frac {
        type Output = Self;
        fn mul(self, rhs: Self) -&gt; Self::Output {
            Self {
                num: self.num * rhs.num,
                den: self.den * rhs.den,
            }
        }
    }

    impl Div for Frac {
        type Output = Self;
        fn div(self, rhs: Self) -&gt; Self::Output {
            self * rhs.recip()
        }
    }

    impl Add&lt;I&gt; for Frac {
        type Output = Self;
        fn add(self, rhs: I) -&gt; Self::Output {
            let rhs: Frac = rhs.into();
            self + rhs
        }
    }

    impl Sub&lt;I&gt; for Frac {
        type Output = Self;
        fn sub(self, rhs: I) -&gt; Self::Output {
            let rhs: Frac = rhs.into();
            self - rhs
        }
    }

    impl Mul&lt;I&gt; for Frac {
        type Output = Self;
        fn mul(self, rhs: I) -&gt; Self::Output {
            let rhs: Frac = rhs.into();
            self * rhs
        }
    }

    impl Div&lt;I&gt; for Frac {
        type Output = Self;
        fn div(self, rhs: I) -&gt; Self::Output {
            let rhs: Frac = rhs.into();
            self / rhs
        }
    }

    impl Add&lt;Frac&gt; for I {
        type Output = Frac;
        fn add(self, rhs: Frac) -&gt; Self::Output {
            rhs + self
        }
    }

    impl Sub&lt;Frac&gt; for I {
        type Output = Frac;
        fn sub(self, rhs: Frac) -&gt; Self::Output {
            -rhs + self
        }
    }

    impl Mul&lt;Frac&gt; for I {
        type Output = Frac;
        fn mul(self, rhs: Frac) -&gt; Self::Output {
            rhs * self
        }
    }

    impl Div&lt;Frac&gt; for I {
        type Output = Frac;
        fn div(self, rhs: Frac) -&gt; Self::Output {
            let lhs: Frac = self.into();
            lhs / rhs
        }
    }

    impl AddAssign for Frac {
        fn add_assign(&amp;mut self, rhs: Self) {
            *self = *self + rhs;
        }
    }

    impl SubAssign for Frac {
        fn sub_assign(&amp;mut self, rhs: Self) {
            *self = *self - rhs;
        }
    }

    impl MulAssign for Frac {
        fn mul_assign(&amp;mut self, rhs: Self) {
            *self = *self * rhs;
        }
    }

    impl DivAssign for Frac {
        fn div_assign(&amp;mut self, rhs: Self) {
            *self = *self / rhs;
        }
    }

    impl AddAssign&lt;I&gt; for Frac {
        fn add_assign(&amp;mut self, rhs: I) {
            *self = *self + rhs;
        }
    }

    impl SubAssign&lt;I&gt; for Frac {
        fn sub_assign(&amp;mut self, rhs: I) {
            *self = *self - rhs;
        }
    }

    impl MulAssign&lt;I&gt; for Frac {
        fn mul_assign(&amp;mut self, rhs: I) {
            *self = *self * rhs;
        }
    }

    impl DivAssign&lt;I&gt; for Frac {
        fn div_assign(&amp;mut self, rhs: I) {
            *self = *self / rhs;
        }
    }

    impl PartialEq for Frac {
        fn eq(&amp;self, rhs: &amp;Self) -&gt; bool {
            (self.num * rhs.den as I).eq(&amp;(rhs.num * self.den as I))
        }
    }

    impl Eq for Frac {}

    impl PartialOrd for Frac {
        fn partial_cmp(&amp;self, rhs: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
            (self.num * rhs.den as I).partial_cmp(&amp;(rhs.num * self.den as I))
        }
    }

    impl Ord for Frac {
        fn cmp(&amp;self, rhs: &amp;Self) -&gt; std::cmp::Ordering {
            (self.num * rhs.den as I).cmp(&amp;(rhs.num * self.den as I))
        }
    }

    impl PartialEq&lt;I&gt; for Frac {
        fn eq(&amp;self, rhs: &amp;I) -&gt; bool {
            let rhs: Frac = (*rhs).into();
            self.eq(&amp;rhs)
        }
    }

    impl PartialOrd&lt;I&gt; for Frac {
        fn partial_cmp(&amp;self, rhs: &amp;I) -&gt; Option&lt;std::cmp::Ordering&gt; {
            let rhs: Frac = (*rhs).into();
            self.partial_cmp(&amp;rhs)
        }
    }

    impl PartialEq&lt;Frac&gt; for I {
        fn eq(&amp;self, rhs: &amp;Frac) -&gt; bool {
            let lhs: Frac = (*self).into();
            lhs.eq(rhs)
        }
    }

    impl PartialOrd&lt;Frac&gt; for I {
        fn partial_cmp(&amp;self, rhs: &amp;Frac) -&gt; Option&lt;std::cmp::Ordering&gt; {
            let lhs: Frac = (*self).into();
            lhs.partial_cmp(rhs)
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-io"><a class="header" href="#fast-io">Fast IO</a></h1>
<h2 id="code-29"><a class="header" href="#code-29">Code</a></h2>
<pre><code class="language-rust noplayground">#![no_main]

#[allow(unused)]
use std::{cmp::*, collections::*, iter, mem::*, num::*, ops::*};

fn solve&lt;'t, It: Iterator&lt;Item = &amp;'t str&gt;&gt;(sc: &amp;mut fastio::Tokenizer&lt;It&gt;) {}

#[allow(unused)]
mod fastio {
	use super::ioutil::*;

	pub struct Tokenizer&lt;It&gt; {
		it: It,
	}

	impl&lt;'i, 's: 'i, It&gt; Tokenizer&lt;It&gt; {
		pub fn new(text: &amp;'s str, split: impl FnOnce(&amp;'i str) -&gt; It) -&gt; Self {
			Self { it: split(text) }
		}
	}

	impl&lt;'t, It: Iterator&lt;Item = &amp;'t str&gt;&gt; Tokenizer&lt;It&gt; {
		pub fn next_ok&lt;T: IterParse&lt;'t&gt;&gt;(&amp;mut self) -&gt; PRes&lt;'t, T&gt; {
			T::parse_from_iter(&amp;mut self.it)
		}

		pub fn next&lt;T: IterParse&lt;'t&gt;&gt;(&amp;mut self) -&gt; T {
			self.next_ok().unwrap()
		}

		pub fn next_map&lt;T: IterParse&lt;'t&gt;, U, const N: usize&gt;(&amp;mut self, f: impl FnMut(T) -&gt; U) -&gt; [U; N] {
			let x: [T; N] = self.next();
			x.map(f)
		}

		pub fn next_it&lt;T: IterParse&lt;'t&gt;&gt;(&amp;mut self) -&gt; impl Iterator&lt;Item = T&gt; + '_ {
			std::iter::repeat_with(move || self.next_ok().ok()).map_while(|x| x)
		}

		pub fn next_collect&lt;T: IterParse&lt;'t&gt;, V: FromIterator&lt;T&gt;&gt;(&amp;mut self, size: usize) -&gt; V {
			self.next_it().take(size).collect()
		}
	}
}

mod ioutil {
	use std::{fmt::*, num::*};

	pub enum InputError&lt;'t&gt; {
		InputExhaust,
		ParseError(&amp;'t str),
	}
	use InputError::*;

	pub type PRes&lt;'t, T&gt; = std::result::Result&lt;T, InputError&lt;'t&gt;&gt;;

	impl&lt;'t&gt; Debug for InputError&lt;'t&gt; {
		fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
			match self {
				InputExhaust =&gt; f.debug_struct(&quot;InputExhaust&quot;).finish(),
				ParseError(s) =&gt; f.debug_struct(&quot;ParseError&quot;).field(&quot;str&quot;, s).finish(),
			}
		}
	}

	pub trait Atom&lt;'t&gt;: Sized {
		fn parse(text: &amp;'t str) -&gt; PRes&lt;'t, Self&gt;;
	}

	impl&lt;'t&gt; Atom&lt;'t&gt; for &amp;'t str {
		fn parse(text: &amp;'t str) -&gt; PRes&lt;'t, Self&gt; {
			Ok(text)
		}
	}

	impl&lt;'t&gt; Atom&lt;'t&gt; for &amp;'t [u8] {
		fn parse(text: &amp;'t str) -&gt; PRes&lt;'t, Self&gt; {
			Ok(text.as_bytes())
		}
	}

	macro_rules! impl_atom {
        ($($t:ty) *) =&gt; { $(impl Atom&lt;'_&gt; for $t { fn parse(text: &amp;str) -&gt; PRes&lt;Self&gt; { text.parse().map_err(|_| ParseError(text)) } })* };
    }
	impl_atom!(u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize f32 f64 bool char String NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize);

	pub trait IterParse&lt;'t&gt;: Sized {
		fn parse_from_iter&lt;'s, It: Iterator&lt;Item = &amp;'t str&gt;&gt;(it: &amp;'s mut It) -&gt; PRes&lt;'t, Self&gt;
		where
			't: 's;
	}

	impl&lt;'t, A: Atom&lt;'t&gt;&gt; IterParse&lt;'t&gt; for A {
		fn parse_from_iter&lt;'s, It: Iterator&lt;Item = &amp;'t str&gt;&gt;(it: &amp;'s mut It) -&gt; PRes&lt;'t, Self&gt;
		where
			't: 's,
		{
			it.next().map_or(Err(InputExhaust), &lt;Self as Atom&gt;::parse)
		}
	}

	impl&lt;'t, A: IterParse&lt;'t&gt;, const N: usize&gt; IterParse&lt;'t&gt; for [A; N] {
		fn parse_from_iter&lt;'s, It: Iterator&lt;Item = &amp;'t str&gt;&gt;(it: &amp;'s mut It) -&gt; PRes&lt;'t, Self&gt;
		where
			't: 's,
		{
			use std::mem::*;
			let mut x: [MaybeUninit&lt;A&gt;; N] = unsafe { MaybeUninit::uninit().assume_init() };
			for p in x.iter_mut() {
				*p = MaybeUninit::new(A::parse_from_iter(it)?);
			}
			Ok(unsafe { transmute_copy(&amp;x) })
		}
	}

	macro_rules! impl_tuple {
        ($u:ident) =&gt; {};
        ($u:ident $($t:ident)+) =&gt; { impl&lt;'t, $u: IterParse&lt;'t&gt;, $($t: IterParse&lt;'t&gt;),+&gt; IterParse&lt;'t&gt; for ($u, $($t),+) { fn parse_from_iter&lt;'s, It: Iterator&lt;Item = &amp;'t str&gt;&gt;(_it: &amp;'s mut It) -&gt; PRes&lt;'t, Self&gt; where 't: 's { Ok(($u::parse_from_iter(_it)?, $($t::parse_from_iter(_it)?),+)) } } impl_tuple!($($t) +); };
    }

	impl_tuple!(Q W E R T Y U I O P A S D F G H J K L Z X C V B N M);
}

#[link(name = &quot;c&quot;)]
extern &quot;C&quot; {
	fn mmap(addr: usize, len: usize, p: i32, f: i32, fd: i32, o: i64) -&gt; *mut u8;
	fn fstat(fd: i32, stat: *mut usize) -&gt; i32;
}

fn get_input() -&gt; &amp;'static str {
	let mut stat = [0; 20];
	unsafe { fstat(0, stat.as_mut_ptr()) };
	let buffer = unsafe { mmap(0, stat[6], 1, 2, 0, 0) };
	unsafe { std::str::from_utf8_unchecked(std::slice::from_raw_parts(buffer, stat[6])) }
}

#[no_mangle]
unsafe fn main() -&gt; i32 {
	use std::io::*;
	let mut sc = fastio::Tokenizer::new(get_input(), |s| s.split_ascii_whitespace());
	let stdout = stdout();
	WRITER = Some(BufWriter::new(stdout.lock()));
	solve(&amp;mut sc);
	WRITER.as_mut().unwrap_unchecked().flush().ok();
	0
}

use std::io::{BufWriter, StdoutLock};
static mut WRITER: Option&lt;BufWriter&lt;StdoutLock&gt;&gt; = None;
#[macro_export]
macro_rules! print {
    ($($t:tt)*) =&gt; {{ use std::io::*; write!(unsafe{ WRITER.as_mut().unwrap_unchecked() }, $($t)*).unwrap(); }};
}
#[macro_export]
macro_rules! println {
    ($($t:tt)*) =&gt; {{ use std::io::*; writeln!(unsafe{ WRITER.as_mut().unwrap_unchecked() }, $($t)*).unwrap(); }};
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator-tools"><a class="header" href="#iterator-tools">Iterator Tools</a></h1>
<h2 id="grid-iteration"><a class="header" href="#grid-iteration">Grid Iteration</a></h2>
<p><code>gen_diriter(r, c, tr, tc)</code> returns an iterator of <code>(usize, usize)</code> which iterates through right, down, left, up from <code>(r, c)</code> in a grid of <code>tr</code> rows and <code>tc</code> columns. <code>gen_torusiter(r, c, tr, tc)</code> acts similarly, but in a grid where your position wrap up when you go out of bounds.</p>
<p>The direction of iteration can be customized by modifying <code>DR</code> and <code>DC</code>.</p>
<pre><code class="language-rust noplayground">const DR: [usize; 4] = [0, 1, 0, !0];
const DC: [usize; 4] = [1, 0, !0, 0];

fn gen_diriter(r: usize, c: usize, tr: usize, tc: usize) -&gt; impl Iterator&lt;Item = (usize, usize)&gt; {
    std::iter::zip(DR.iter(), DC.iter())
        .map(move |(&amp;dr, &amp;dc)| (r.wrapping_add(dr), c.wrapping_add(dc)))
        .filter(move |&amp;(nr, nc)| nr &lt; tr &amp;&amp; nc &lt; tc)
}

fn gen_torusiter(r: usize, c: usize, tr: usize, tc: usize) -&gt; impl Iterator&lt;Item = (usize, usize)&gt; {
    std::iter::zip(DR.iter(), DC.iter())
        .map(move |(&amp;dr, &amp;dc)| (r.wrapping_add(dr), c.wrapping_add(dc)))
        .map(move |(nr, nc)| {
            let r = if nr &gt; usize::MAX / 2 {
                let delta = (usize::MAX - nr) % tr;
                tr - 1 - delta
            } else {
                nr
            };
            let c = if nc &gt; usize::MAX / 2 {
                let delta = (usize::MAX - nc) % tc;
                tc - 1 - delta
            } else {
                nc % tc
            };
            (r, c)
        })
}</code></pre>
<h2 id="cartesian-product"><a class="header" href="#cartesian-product">Cartesian Product</a></h2>
<p><code>cart_prod(a, b)</code> returns an iterator of cartesian product of two iterators <code>a</code> and <code>b</code>.</p>
<pre><code class="language-rust noplayground">fn cart_prod&lt;I, J, S, T&gt;(a: I, b: J) -&gt; impl Iterator&lt;Item = (S, T)&gt;
where I: Iterator&lt;Item = S&gt;, J: Iterator&lt;Item = T&gt; + Clone, S: Clone {
    a.flat_map(move |a| b.clone().map(move |b| (a.clone(), b)))
}</code></pre>
<h2 id="intersperse"><a class="header" href="#intersperse">Intersperse</a></h2>
<p><code>intersperse(iter, v)</code> returns an iterator which inserts <code>v</code> between elements of <code>iter</code>.</p>
<pre><code class="language-rust noplayground">fn intersperse&lt;T: Clone&gt;(iter: impl Iterator&lt;Item = T&gt;, with: T) -&gt; impl Iterator&lt;Item = T&gt; {
    iter.map(move |v| [with.clone(), v]).flatten().skip(1)
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<h2 id="conversion-between-enum-and-u32"><a class="header" href="#conversion-between-enum-and-u32">Conversion between Enum and <code>u32</code></a></h2>
<p>Macro from <a href="https://stackoverflow.com/questions/28028854/how-do-i-match-enum-values-with-an-integer">https://stackoverflow.com/questions/28028854/how-do-i-match-enum-values-with-an-integer</a>.</p>
<h3 id="example-26"><a class="header" href="#example-26">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::convert::{TryFrom, TryInto};
</span><span class="boring">macro_rules! back_to_enum {
</span><span class="boring">    {$(#[$meta:meta])* $vis:vis enum $name:ident {
</span><span class="boring">        $($(#[$vmeta:meta])* $vname:ident $(= $val:expr)?,)*
</span><span class="boring">    }} =&gt; {
</span><span class="boring">        $(#[$meta])*
</span><span class="boring">        $vis enum $name {
</span><span class="boring">            $($(#[$vmeta])* $vname $(= $val)?,)*
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl TryFrom&lt;u32&gt; for $name {
</span><span class="boring">            type Error = ();
</span><span class="boring">
</span><span class="boring">            fn try_from(v: u32) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">                match v {
</span><span class="boring">                    $(x if x == $name::$vname as u32 =&gt; Ok($name::$vname),)*
</span><span class="boring">                    _ =&gt; Err(()),
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>back_to_enum! {
    #[derive(Clone, Copy, Debug)]
    enum Number {
        Zero,
        One,
        Two,
    }
}

<span class="boring">fn main() {
</span>let i: u32 = 1;
let n: Number = i.try_into().unwrap();
println!(&quot;{:?}&quot;, n);  // One
let i = n as i32;
println!(&quot;{}&quot;, i);    // 1
<span class="boring">}</span></code></pre></pre>
<h3 id="code-30"><a class="header" href="#code-30">Code</a></h3>
<pre><code class="language-rust noplayground">use std::convert::{TryFrom, TryInto};
macro_rules! back_to_enum {
    {$(#[$meta:meta])* $vis:vis enum $name:ident {
        $($(#[$vmeta:meta])* $vname:ident $(= $val:expr)?,)*
    }} =&gt; {
        $(#[$meta])*
        $vis enum $name {
            $($(#[$vmeta])* $vname $(= $val)?,)*
        }
        impl TryFrom&lt;u32&gt; for $name {
            type Error = ();
            fn try_from(v: u32) -&gt; Result&lt;Self, Self::Error&gt; {
                match v {
                    $(x if x == $name::$vname as u32 =&gt; Ok($name::$vname),)*
                    _ =&gt; Err(()),
                }
            }
        }
    }
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adjacency-list-graph-representation"><a class="header" href="#adjacency-list-graph-representation">Adjacency List Graph Representation</a></h1>
<p>Deprecated because it's way easier to use <code>Vec&lt;Vec&lt;(usize, T)&gt;&gt;</code>. The performance gain isn't worth giving up usability.</p>
<p>Credits to kiwiyou</p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Graph&lt;T&gt; {
    n: usize,
    first: Vec&lt;u32&gt;,
    edge: Vec&lt;(u32, u32, T)&gt;, // (to, prev, data)
}

impl&lt;T&gt; Graph&lt;T&gt; {
    fn new(n: usize, e: usize) -&gt; Self {
        Self {
            n,
            first: vec![u32::MAX; n],
            edge: Vec::with_capacity(e),
        }
    }

    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len() as u32);
        self.edge.push((to as u32, prev, data));
    }

    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
        Neighbor {
            graph: self,
            next_edge: self.first[of],
        }
    }
}

struct Neighbor&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    next_edge: u32,
}

impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
    type Item = (usize, &amp;'g T);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (to, next_edge, data) = self.graph.edge.get(self.next_edge as usize)?;
        self.next_edge = *next_edge;
        Some((*to as usize, data))
    }
}</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zeroone-trait"><a class="header" href="#zeroone-trait">Zero/One Trait</a></h1>
<p>Deprecated because letting the generic type to implement either <code>From&lt;u8&gt;</code> or <code>From&lt;i8&gt;</code> is enough.</p>
<pre><code class="language-rust noplayground">pub trait ZeroOne: Sized + Copy {
    fn zero() -&gt; Self;
    fn one() -&gt; Self;
}

macro_rules! impl_zero_one {
    ($($ty:ty) *) =&gt; { $(
        impl ZeroOne for $ty {
            #[inline(always)]
            fn one() -&gt; Self {1}
            #[inline(always)]
            fn zero() -&gt; Self {0}
        }
    )+ };
}

impl_zero_one!(isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128);</code></pre>
<hr />
<p>Last modified on 231008.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deprecated-macros"><a class="header" href="#deprecated-macros">Deprecated Macros</a></h1>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<p>Deprecated because it's better to utilize the fact that <code>HashMap&lt;K, V&gt;</code> is <code>From&lt;[(K, V); N]&gt;</code> for data hardcoding of a hashmap.</p>
<pre><code class="language-rust noplayground">macro_rules! count_tts {
    () =&gt; { 0 };
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 };
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 };
}

// let map: HashMap&lt;i64, i64&gt; = hashmap![1,1; 2,2; 3,3];
macro_rules! hashmap {
    ($($k:expr,$v:expr);*) =&gt; {{
        let mut map = HashMap::with_capacity(count_tts![$($k )*]);
        $( map.insert($k, $v); )*
        map
    }}
}</code></pre>
<hr />
<p>Last modified on 231008.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
