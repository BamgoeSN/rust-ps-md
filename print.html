<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js nord_light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Snippets for Competitive Programming</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "nord_dark" : "nord_light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('nord_light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Algebra</li><li class="chapter-item expanded "><a href="algebra/gcd.html"><strong aria-hidden="true">1.</strong> GCD, LCM</a></li><li class="chapter-item expanded "><a href="algebra/extgcd.html"><strong aria-hidden="true">2.</strong> Extended Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="algebra/crt.html"><strong aria-hidden="true">3.</strong> Chinese Remainder Theorem</a></li><li class="chapter-item expanded "><a href="algebra/millerrabin.html"><strong aria-hidden="true">4.</strong> Deterministic Miller-Rabin Primality Test</a></li><li class="chapter-item expanded "><a href="algebra/pollardrho.html"><strong aria-hidden="true">5.</strong> Pollard's Rho Algorithm</a></li><li class="chapter-item expanded "><a href="algebra/ntt.html"><strong aria-hidden="true">6.</strong> Number Theoretic Transform</a></li><li class="chapter-item expanded affix "><li class="part-title">Numerical Algorithms</li><li class="chapter-item expanded "><a href="numerical/isqrt.html"><strong aria-hidden="true">7.</strong> Integer Square Root</a></li><li class="chapter-item expanded "><a href="numerical/sieve.html"><strong aria-hidden="true">8.</strong> Sieve</a></li><li class="chapter-item expanded "><a href="numerical/linrec/intro.html"><strong aria-hidden="true">9.</strong> Linear Recurrence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="numerical/linrec/berlekamp.html"><strong aria-hidden="true">9.1.</strong> Berlekamp-Massey</a></li><li class="chapter-item expanded "><a href="numerical/linrec/kitamasa.html"><strong aria-hidden="true">9.2.</strong> Kitamasa</a></li><li class="chapter-item expanded "><a href="numerical/linrec/bostanmori.html"><strong aria-hidden="true">9.3.</strong> Bostan-Mori</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Data Structures</li><li class="chapter-item expanded "><a href="datastructure/bitarray.html"><strong aria-hidden="true">10.</strong> Bitset</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/intro.html"><strong aria-hidden="true">11.</strong> Segment Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datastructure/segtree/segtree.html"><strong aria-hidden="true">11.1.</strong> Segment Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/fenwick.html"><strong aria-hidden="true">11.2.</strong> Fenwick Tree</a></li><li class="chapter-item expanded "><a href="datastructure/segtree/lazyseg.html"><strong aria-hidden="true">11.3.</strong> Lazy Segment Tree</a></li></ol></li><li class="chapter-item expanded "><a href="datastructure/rope.html"><strong aria-hidden="true">12.</strong> Rope</a></li><li class="chapter-item expanded affix "><li class="part-title">Graphs</li><li class="chapter-item expanded "><a href="graphs/adjlist.html"><strong aria-hidden="true">13.</strong> Adjacency List Graph Representation</a></li><li class="chapter-item expanded "><a href="graphs/dijkstra.html"><strong aria-hidden="true">14.</strong> Dijkstra</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphs/dial.html"><strong aria-hidden="true">14.1.</strong> Dial</a></li></ol></li><li class="chapter-item expanded "><a href="graphs/dsu.html"><strong aria-hidden="true">15.</strong> Disjoint Set Union</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphs/wdsu.html"><strong aria-hidden="true">15.1.</strong> Weighted DSU</a></li></ol></li><li class="chapter-item expanded "><a href="graphs/scc.html"><strong aria-hidden="true">16.</strong> Strongly Connected Components</a></li><li class="chapter-item expanded "><a href="graphs/2sat.html"><strong aria-hidden="true">17.</strong> 2-SAT</a></li><li class="chapter-item expanded affix "><li class="part-title">Strings</li><li class="chapter-item expanded "><a href="strings/kmp.html"><strong aria-hidden="true">18.</strong> KMP</a></li><li class="chapter-item expanded "><a href="strings/manacher.html"><strong aria-hidden="true">19.</strong> Manacher</a></li><li class="chapter-item expanded "><a href="strings/salcp.html"><strong aria-hidden="true">20.</strong> Suffix Array and LCP Array</a></li><li class="chapter-item expanded affix "><li class="part-title">Geometry</li><li class="chapter-item expanded "><a href="geometry/convexhull.html"><strong aria-hidden="true">21.</strong> Convex Hull</a></li><li class="chapter-item expanded affix "><li class="part-title">Unclassified</li><li class="chapter-item expanded "><a href="unclass/valcomp.html"><strong aria-hidden="true">22.</strong> Value Compression</a></li><li class="chapter-item expanded "><a href="unclass/lis.html"><strong aria-hidden="true">23.</strong> Longest Increasing Subsequence</a></li><li class="chapter-item expanded "><a href="unclass/mos.html"><strong aria-hidden="true">24.</strong> Mo's</a></li><li class="chapter-item expanded "><a href="unclass/bigint.html"><strong aria-hidden="true">25.</strong> Arbitrary-Precision Integer</a></li><li class="chapter-item expanded affix "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="misc/fastio.html"><strong aria-hidden="true">26.</strong> Fast IO</a></li><li class="chapter-item expanded "><a href="misc/macro.html"><strong aria-hidden="true">27.</strong> Macros</a></li><li class="chapter-item expanded "><a href="misc/zero_one_trait.html"><strong aria-hidden="true">28.</strong> Zero/One Trait (Deprecated)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="nord_light">Nord Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="nord_dark">Nord Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Snippets for Competitive Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BamgoeSN/rust-ps-md" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is a collection of snippets for competitive programming and problem solving with Rust. All you have to do for using snippets is simply copying snippets you need and pasting them into your code.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Each snippet can be easily copied by clicking on the copy icon <i class="fa fa-copy"></i> at the top right corner of a code block.</p>
<p>Clicking on the search icon <i class="fa fa-search"></i> in the menu bar, or pressing the <code>S</code> key on the keyboard will open an input box for entering search terms. Any keywords included in this book can be searched by typing it in the box.</p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other Resources</a></h2>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<ul>
<li><a href="https://blog.shahjalalshohag.com/topic-list/">The Ultimate Topic List by Shahjalal Shohag</a></li>
</ul>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<ul>
<li><a href="https://github.com/EbTech/rust-algorithms">Contest Algorithms in Rust by EbTech</a></li>
<li><a href="https://snippets.kiwiyou.dev/">kiwiyou's Snippets Collection</a></li>
</ul>
<h3 id="c"><a class="header" href="#c">C++</a></h3>
<ul>
<li><a href="https://github.com/Aeren1564/Algorithms">aeren1564 Bible</a></li>
<li>AtCoder Library: <a href="https://atcoder.github.io/ac-library/production/document_en/">Doc</a>, <a href="https://github.com/atcoder/ac-library">GitHub</a></li>
<li><a href="https://github.com/koosaga/olympiad/tree/master/Library">koosaga's Library</a></li>
<li><a href="https://github.com/justiceHui/icpc-teamnote">justiceHui's Teamnote</a></li>
</ul>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<ul>
<li><a href="https://github.com/cheran-senthil/PyRival">PyRival</a></li>
</ul>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p><strong>None of the codes from this document should be used in any other fields besides competitive programming!</strong> Every code here is strictly designed for CP, and none of these codes are for actual production codes.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Unless stated otherwise, or there is another license included in the code, every snippets here is under Unlicense.</p>
<blockquote>
<p>This is free and unencumbered software released into the public domain.</p>
<p>Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.</p>
<p>In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.</p>
<p>For more information, please refer to <a href="http://unlicense.org/">http://unlicense.org/</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcd-lcm"><a class="header" href="#gcd-lcm">GCD, LCM</a></h1>
<p><code>gcd(x, y)</code> returns the greatest common divisor (GCD) of <code>x</code> and <code>y</code>. <br />
<code>lcm(x, y)</code> returns the least common multiple (LCM) of <code>x</code> and <code>y</code>.</p>
<p><code>gcd</code> is implemented using Euclidean algorithm, whose time complexity is \(O( \log _{\phi} x )\) where \(\phi\) is a golden ratio.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let (x, y) = (10, 25);

let g = gcd(x, y);
println!(&quot;{}&quot;, g); // 5

let l = lcm(x, y);
println!(&quot;{}&quot;, l); // 50
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn gcd(x: u64, y: u64) -&gt; u64 {
</span><span class="boring">   if y == 0 {
</span><span class="boring">       x
</span><span class="boring">   } else {
</span><span class="boring">       gcd(y, x % y)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn lcm(x: u64, y: u64) -&gt; u64 {
</span><span class="boring">   x / gcd(x, y) * y
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-rust noplayground">fn gcd(x: u64, y: u64) -&gt; u64 {
    if y == 0 {
        x
    } else {
        gcd(y, x % y)
    }
}

fn lcm(x: u64, y: u64) -&gt; u64 {
    x / gcd(x, y) * y
}</code></pre>
<h2 id="generic-version"><a class="header" href="#generic-version">Generic Version</a></h2>
<p>The function below works for any primitive unsigned integer types.</p>
<pre><code class="language-rust noplayground">pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy + PartialEq + PartialOrd + std::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
{
    if y == 0.into() {
        x
    } else {
        let v = x % y;
        gcd(y, v)
    }
}

pub fn lcm&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy
        + PartialEq
        + PartialOrd
        + std::ops::Rem&lt;Output = T&gt;
        + std::ops::Div&lt;Output = T&gt;
        + std::ops::Mul&lt;Output = T&gt;
        + From&lt;u8&gt;,
{
    x / gcd(x, y) * y
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extended-euclidean-algorithm"><a class="header" href="#extended-euclidean-algorithm">Extended Euclidean Algorithm</a></h1>
<p><code>ext_gcd(a, b)</code> returns \(g, s, t\) such that \(g = \gcd(a, b)\) and \(as+bt=g\).</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let (a, b) = (4, 11);
let (g, s, t) = ext_gcd(a, b);
println!(&quot;{} {} {}&quot;, g, s, t); // 1 3 -1
println!(&quot;{} == {}&quot;, g, a * s + b * t);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Extended Euclidean Algorithm
</span><span class="boring">// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/gcd.py
</span><span class="boring">
</span><span class="boring">fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
</span><span class="boring">    let (mut s, mut old_s) = (0, 1);
</span><span class="boring">    let (mut g, mut old_g) = (b, a);
</span><span class="boring">    while g != 0 {
</span><span class="boring">        let q = old_g / g;
</span><span class="boring">        let (new_r, new_s) = (old_g - q * g, old_s - q * s);
</span><span class="boring">        old_g = g; // Not using destructuring to support low version
</span><span class="boring">        g = new_r; // AtCoder is using 1.42.0
</span><span class="boring">        old_s = s;
</span><span class="boring">        s = new_s;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    (
</span><span class="boring">        old_g,
</span><span class="boring">        old_s,
</span><span class="boring">        if b != 0 { (old_g - old_s * a) / b } else { 0 },
</span><span class="boring">    )
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<pre><code class="language-rust noplayground">// Extended Euclidean Algorithm
// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/gcd.py

fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut g, mut old_g) = (b, a);
    while g != 0 {
        let q = old_g / g;
        let (new_r, new_s) = (old_g - q * g, old_s - q * s);
        old_g = g; // Not using destructuring to support low version
        g = new_r; // AtCoder is using 1.42.0
        old_s = s;
        s = new_s;
    }

    (
        old_g,
        old_s,
        if b != 0 { (old_g - old_s * a) / b } else { 0 },
    )
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chinese-remainder-theorem"><a class="header" href="#chinese-remainder-theorem">Chinese Remainder Theorem</a></h1>
<p><code>crt(r, m)</code> returns <code>Some(x)</code> such that \(x \equiv r_i \pmod {m_i}\) for all \(i\). If such \(x\) does not exist, then it returns <code>None</code>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let r: Vec&lt;i64&gt; = vec![1, 2, 3];
let m: Vec&lt;i64&gt; = vec![3, 5, 7];
let x = crt(&amp;r, &amp;m);
println!(&quot;{:?}&quot;, x); // Some(52)

let r: Vec&lt;i64&gt; = vec![2, 5];
let m: Vec&lt;i64&gt; = vec![10, 25];
let x = crt(&amp;r, &amp;m);
println!(&quot;{:?}&quot;, x); // None
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Chinese remainder theorem
</span><span class="boring">// Reference: PyRival &lt;https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py&gt;
</span><span class="boring">
</span><span class="boring">fn gcd(x: i64, y: i64) -&gt; i64 {
</span><span class="boring">    if y == 0 {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        gcd(y, x % y)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns gcd(a, b), s, r s.t. a*s + b*r = gcd(a, b)
</span><span class="boring">#[inline(always)]
</span><span class="boring">fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
</span><span class="boring">    let (mut s, mut old_s) = (0, 1);
</span><span class="boring">    let (mut r, mut old_r) = (b, a);
</span><span class="boring">    while r != 0 {
</span><span class="boring">        let q = old_r / r;
</span><span class="boring">        let (new_r, new_s) = (old_r - q * r, old_s - q * s);
</span><span class="boring">        old_r = r; // Not using destructuring to support low version
</span><span class="boring">        r = new_r; // AtCoder is using 1.42.0
</span><span class="boring">        old_s = s;
</span><span class="boring">        s = new_s;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    (
</span><span class="boring">        old_r,
</span><span class="boring">        old_s,
</span><span class="boring">        if b != 0 { (old_r - old_s * a) / b } else { 0 },
</span><span class="boring">    )
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Returns $x$ s.t. $x=r_i (mod m_i)$ for all $i$
</span><span class="boring">fn crt(r: &amp;[i64], m: &amp;[i64]) -&gt; Option&lt;i64&gt; {
</span><span class="boring">    let (mut x, mut m_prod) = (0, 1);
</span><span class="boring">    for (bi, mi) in r.iter().zip(m.iter()) {
</span><span class="boring">        let (g, s, _) = ext_gcd(m_prod, *mi);
</span><span class="boring">        if ((bi - x) % mi).rem_euclid(g) != 0 {
</span><span class="boring">            return None;
</span><span class="boring">        }
</span><span class="boring">        x += m_prod * ((s * ((bi - x).rem_euclid(*mi))).div_euclid(g));
</span><span class="boring">        m_prod = (m_prod * mi).div_euclid(gcd(m_prod, *mi));
</span><span class="boring">    }
</span><span class="boring">    Some(x.rem_euclid(m_prod))
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-2"><a class="header" href="#code-2">Code</a></h2>
<pre><code class="language-rust noplayground">// Chinese remainder theorem
// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py

fn gcd(x: i64, y: i64) -&gt; i64 {
    if y == 0 {
        x
    } else {
        gcd(y, x % y)
    }
}

/// Returns gcd(a, b), s, t s.t. a*s + b*t = gcd(a, b)
#[inline(always)]
fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut r, mut old_r) = (b, a);
    while r != 0 {
        let q = old_r / r;
        let (new_r, new_s) = (old_r - q * r, old_s - q * s);
        old_r = r; // Not using destructuring to support low version
        r = new_r; // AtCoder is using 1.42.0
        old_s = s;
        s = new_s;
    }

    (
        old_r,
        old_s,
        if b != 0 { (old_r - old_s * a) / b } else { 0 },
    )
}

/// Returns x s.t. x=r_i (mod m_i) for all i
fn crt(r: &amp;[i64], m: &amp;[i64]) -&gt; Option&lt;i64&gt; {
    let (mut x, mut m_prod) = (0, 1);
    for (bi, mi) in r.iter().zip(m.iter()) {
        let (g, s, _) = ext_gcd(m_prod, *mi);
        if ((bi - x) % mi).rem_euclid(g) != 0 {
            return None;
        }
        x += m_prod * ((s * ((bi - x).rem_euclid(*mi))).div_euclid(g));
        m_prod = (m_prod * mi).div_euclid(gcd(m_prod, *mi));
    }
    Some(x.rem_euclid(m_prod))
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deterministic-miller-rabin-primality-test"><a class="header" href="#deterministic-miller-rabin-primality-test">Deterministic Miller-Rabin Primality Test</a></h1>
<p>Deterministic Miller-Rabin primality test determines whether a certain unsigned integer is a prime in a time complexity of \(O(\log{n})\). This test only works for integers under \(2^{64}\).</p>
<p><code>x.is_prime()</code> chooses a roughly faster algorithm among naive primality test and Miller-Rabin test, and returns <code>true</code> if <code>x</code> is a prime, <code>false</code> if not.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use miller_rabin::MillerRabin;

<span class="boring">
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, 3284729387909u64.is_prime()); // true
println!(&quot;{}&quot;, 3284729387911u64.is_prime()); // false 53Ã—61976026187
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod miller_rabin {
</span><span class="boring">    pub trait MillerRabin: From&lt;u8&gt; + PartialOrd {
</span><span class="boring">        const MR_THRES: Self;
</span><span class="boring">        fn naive_primality(self) -&gt; bool;
</span><span class="boring">        fn miller_rabin_test(self, a: Self) -&gt; bool;
</span><span class="boring">        fn miller_primality(self) -&gt; bool;
</span><span class="boring">        fn is_prime(self) -&gt; bool {
</span><span class="boring">            if self &lt;= 1.into() {
</span><span class="boring">                false
</span><span class="boring">            } else if self &lt;= Self::MR_THRES {
</span><span class="boring">                self.naive_primality()
</span><span class="boring">            } else {
</span><span class="boring">                self.miller_primality()
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    macro_rules! impl_millerrabin {
</span><span class="boring">        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
</span><span class="boring">            impl MillerRabin for $t {
</span><span class="boring">                const MR_THRES: Self = $thres;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn naive_primality(self) -&gt; bool {
</span><span class="boring">                    (2..).take_while(|&amp;i| i * i &lt;= self).all(|i| self % i != 0)
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn miller_rabin_test(self, a: Self) -&gt; bool {
</span><span class="boring">                    let d = self - 1;
</span><span class="boring">                    let mut p = d &gt;&gt; (d.trailing_zeros());
</span><span class="boring">
</span><span class="boring">                    let mut t = {
</span><span class="boring">                        let mut base = a as $u;
</span><span class="boring">                        let mut exp = p as $u;
</span><span class="boring">                        let rem = self as $u;
</span><span class="boring">                        let mut ret: $u = 1;
</span><span class="boring">                        while exp != 0 {
</span><span class="boring">                            if exp &amp; 1 != 0 {
</span><span class="boring">                                ret = ret * base % rem;
</span><span class="boring">                            }
</span><span class="boring">                            base = base * base % rem;
</span><span class="boring">                            exp &gt;&gt;= 1;
</span><span class="boring">                        }
</span><span class="boring">                        ret as $t
</span><span class="boring">                    };
</span><span class="boring">
</span><span class="boring">                    let at_last = t == d || t == 1;
</span><span class="boring">
</span><span class="boring">                    while p != d {
</span><span class="boring">                        p &lt;&lt;= 1;
</span><span class="boring">                        t = ((t as $u * t as $u) % self as $u) as $t;
</span><span class="boring">                        if t == self - 1 {
</span><span class="boring">                            return true;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    at_last
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                fn miller_primality(self) -&gt; bool {
</span><span class="boring">                    $(
</span><span class="boring">                        if !self.miller_rabin_test($x) { return false; }
</span><span class="boring">                    )*
</span><span class="boring">                    true
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl_millerrabin!(u8, u16, 254, 2);
</span><span class="boring">    impl_millerrabin!(u16, u32, 2000, 2, 3);
</span><span class="boring">    impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
</span><span class="boring">    impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-3"><a class="header" href="#code-3">Code</a></h2>
<pre><code class="language-rust noplayground">mod miller_rabin {
    pub trait MillerRabin: From&lt;u8&gt; + PartialOrd {
        const MR_THRES: Self;
        fn naive_primality(self) -&gt; bool;
        fn miller_rabin_test(self, a: Self) -&gt; bool;
        fn miller_primality(self) -&gt; bool;
        fn is_prime(self) -&gt; bool {
            if self &lt;= 1.into() {
                false
            } else if self &lt;= Self::MR_THRES {
                self.naive_primality()
            } else {
                self.miller_primality()
            }
        }
    }

    macro_rules! impl_millerrabin {
        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
            impl MillerRabin for $t {
                const MR_THRES: Self = $thres;

                #[inline(always)]
                fn naive_primality(self) -&gt; bool {
                    (2..).take_while(|&amp;i| i * i &lt;= self).all(|i| self % i != 0)
                }

                #[inline(always)]
                fn miller_rabin_test(self, a: Self) -&gt; bool {
                    let d = self - 1;
                    let mut p = d &gt;&gt; (d.trailing_zeros());

                    let mut t = {
                        let mut base = a as $u;
                        let mut exp = p as $u;
                        let rem = self as $u;
                        let mut ret: $u = 1;
                        while exp != 0 {
                            if exp &amp; 1 != 0 {
                                ret = ret * base % rem;
                            }
                            base = base * base % rem;
                            exp &gt;&gt;= 1;
                        }
                        ret as $t
                    };

                    let at_last = t == d || t == 1;

                    while p != d {
                        p &lt;&lt;= 1;
                        t = ((t as $u * t as $u) % self as $u) as $t;
                        if t == self - 1 {
                            return true;
                        }
                    }
                    at_last
                }

                fn miller_primality(self) -&gt; bool {
                    $(
                        if !self.miller_rabin_test($x) { return false; }
                    )*
                    true
                }
            }
        };
    }

    impl_millerrabin!(u8, u16, 254, 2);
    impl_millerrabin!(u16, u32, 2000, 2, 3);
    impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
    impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pollards-rho-algorithm"><a class="header" href="#pollards-rho-algorithm">Pollard's Rho Algorithm</a></h1>
<p>Pollard rho algorithm is a randomized algorithm which factorizes a number in an average time complexity of \(O(n^{1/4})\).</p>
<p><code>x.factorize()</code> factorizes <code>x</code> and returns a vector with the factors. The order of factors in the vector is undefined.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut rng = rng::RNG::new(15163487);
let a: u32 = 1237172;
let mut factors = a.factorize(&amp;mut rng);
factors.sort_unstable();
println!(&quot;{:?}&quot;, factors); // [2, 2, 309293]
println!(&quot;{}&quot;, factors.iter().product::&lt;u32&gt;()); // 1237172
<span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PollardRho: MillerRabin + std::ops::ShrAssign + std::ops::BitAnd&lt;Output = Self&gt; + Clone {
</span><span class="boring">    fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG);
</span><span class="boring">    fn factorize(mut self, rng: &amp;mut rng::RNG) -&gt; Vec&lt;Self&gt; {
</span><span class="boring">        let mut arr: Vec&lt;Self&gt; = Vec::new();
</span><span class="boring">        if self &lt;= 1.into() {
</span><span class="boring">            return arr;
</span><span class="boring">        }
</span><span class="boring">        while self.clone() &amp; 1.into() == 0.into() {
</span><span class="boring">            self &gt;&gt;= 1.into();
</span><span class="boring">            arr.push(2.into());
</span><span class="boring">        }
</span><span class="boring">        self.rho(&amp;mut arr, rng);
</span><span class="boring">        arr
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! impl_pollardrho {
</span><span class="boring">    ($t:ty, $u:ty, $reset:expr) =&gt; {
</span><span class="boring">        impl PollardRho for $t {
</span><span class="boring">            fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG) {
</span><span class="boring">                if self &lt;= 1 {
</span><span class="boring">                    return;
</span><span class="boring">                } else if self.is_prime() {
</span><span class="boring">                    arr.push(self);
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                let mut i: u64 = 0;
</span><span class="boring">                let mut x: $t = (rng.next_u64() % self as u64) as $t;
</span><span class="boring">                let mut y: $t = x;
</span><span class="boring">                let mut k: u64 = 2;
</span><span class="boring">                let mut d: $t;
</span><span class="boring">                let mut reset_limit: u64 = $reset;
</span><span class="boring">
</span><span class="boring">                loop {
</span><span class="boring">                    i += 1;
</span><span class="boring">                    x = (((x as $u * x as $u % self as $u) + (self - 1) as $u) % self as $u) as $t;
</span><span class="boring">                    d = gcd(y.abs_diff(x), self);
</span><span class="boring">                    if d == self || i &gt;= reset_limit {
</span><span class="boring">                        // Reset
</span><span class="boring">                        reset_limit = reset_limit * 3 / 2;
</span><span class="boring">                        i = 0;
</span><span class="boring">                        x = (rng.next_u64() % self as u64) as $t;
</span><span class="boring">                        y = x;
</span><span class="boring">                    }
</span><span class="boring">                    if d != 1 {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                    if i == k {
</span><span class="boring">                        y = x;
</span><span class="boring">                        k &lt;&lt;= 1;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                if d != self {
</span><span class="boring">                    d.rho(arr, rng);
</span><span class="boring">                    (self / d).rho(arr, rng);
</span><span class="boring">                    return;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                let mut i = 3;
</span><span class="boring">                while i * i &lt;= self {
</span><span class="boring">                    if self % i == 0 {
</span><span class="boring">                        i.rho(arr, rng);
</span><span class="boring">                        (d / i).rho(arr, rng);
</span><span class="boring">                        return;
</span><span class="boring">                    }
</span><span class="boring">                    i += 2;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl_pollardrho!(u8, u16, 100000);
</span><span class="boring">impl_pollardrho!(u16, u32, 100000);
</span><span class="boring">impl_pollardrho!(u32, u64, 100000);
</span><span class="boring">impl_pollardrho!(u64, u128, 100000);
</span><span class="boring">
</span><span class="boring">trait MillerRabin: From&lt;u8&gt; + PartialOrd {
</span><span class="boring">    const MR_THRES: Self;
</span><span class="boring">    fn naive_primality(self) -&gt; bool;
</span><span class="boring">    fn miller_rabin_test(self, a: Self) -&gt; bool;
</span><span class="boring">    fn miller_primality(self) -&gt; bool;
</span><span class="boring">    fn is_prime(self) -&gt; bool {
</span><span class="boring">        if self &lt;= 1.into() {
</span><span class="boring">            false
</span><span class="boring">        } else if self &lt;= Self::MR_THRES {
</span><span class="boring">            self.naive_primality()
</span><span class="boring">        } else {
</span><span class="boring">            self.miller_primality()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! impl_millerrabin {
</span><span class="boring">        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
</span><span class="boring">            impl MillerRabin for $t {
</span><span class="boring">                const MR_THRES: Self = $thres;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn naive_primality(self) -&gt; bool {
</span><span class="boring">                    for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
</span><span class="boring">                        if self % i == 0 {
</span><span class="boring">                            return false;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    true
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn miller_rabin_test(self, a: Self) -&gt; bool {
</span><span class="boring">                    let d = self - 1;
</span><span class="boring">                    let mut p = d &gt;&gt; (d.trailing_zeros());
</span><span class="boring">
</span><span class="boring">                    let mut t = {
</span><span class="boring">                        let mut base = a as $u;
</span><span class="boring">                        let mut exp = p as $u;
</span><span class="boring">                        let rem = self as $u;
</span><span class="boring">                        let mut ret: $u = 1;
</span><span class="boring">                        while exp != 0 {
</span><span class="boring">                            if exp &amp; 1 != 0 {
</span><span class="boring">                                ret = ret * base % rem;
</span><span class="boring">                            }
</span><span class="boring">                            base = base*base%rem;
</span><span class="boring">                            exp &gt;&gt;= 1;
</span><span class="boring">                        }
</span><span class="boring">                        ret as $t
</span><span class="boring">                    };
</span><span class="boring">
</span><span class="boring">                    let at_last = t == d || t == 1;
</span><span class="boring">
</span><span class="boring">                    while p != d {
</span><span class="boring">                        p &lt;&lt;= 1;
</span><span class="boring">                        t = ((t as $u * t as $u) % self as $u) as $t;
</span><span class="boring">                        if t == self - 1 {
</span><span class="boring">                            return true;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    at_last
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                fn miller_primality(self) -&gt; bool {
</span><span class="boring">                    $(
</span><span class="boring">                        if !self.miller_rabin_test($x) {
</span><span class="boring">                            return false;
</span><span class="boring">                        }
</span><span class="boring">                    )*
</span><span class="boring">                    true
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl_millerrabin!(u8, u16, 254, 2);
</span><span class="boring">impl_millerrabin!(u16, u32, 2000, 2, 3);
</span><span class="boring">impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
</span><span class="boring">impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);
</span><span class="boring">
</span><span class="boring">pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
</span><span class="boring">where
</span><span class="boring">    T: Copy + PartialEq + PartialOrd + std::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
</span><span class="boring">{
</span><span class="boring">    if y == 0.into() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        let v = x % y;
</span><span class="boring">        gcd(y, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod rng {
</span><span class="boring">    pub struct RNG {
</span><span class="boring">        val: u64,
</span><span class="boring">    }
</span><span class="boring">    impl RNG {
</span><span class="boring">        pub fn new(seed: u64) -&gt; Self {
</span><span class="boring">            Self { val: seed }
</span><span class="boring">        }
</span><span class="boring">        pub fn next_u64(&amp;mut self) -&gt; u64 {
</span><span class="boring">            let mut x = self.val;
</span><span class="boring">            x ^= x &lt;&lt; 13;
</span><span class="boring">            x ^= x &gt;&gt; 7;
</span><span class="boring">            x ^= x &lt;&lt; 17;
</span><span class="boring">            self.val = x;
</span><span class="boring">            x
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-4"><a class="header" href="#code-4">Code</a></h2>
<pre><code class="language-rust noplayground">trait PollardRho: MillerRabin + std::ops::ShrAssign + std::ops::BitAnd&lt;Output = Self&gt; + Clone {
    fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG);
    fn factorize(mut self, rng: &amp;mut rng::RNG) -&gt; Vec&lt;Self&gt; {
        let mut arr: Vec&lt;Self&gt; = Vec::new();
        if self &lt;= 1.into() {
            return arr;
        }
        while self.clone() &amp; 1.into() == 0.into() {
            self &gt;&gt;= 1.into();
            arr.push(2.into());
        }
        self.rho(&amp;mut arr, rng);
        arr
    }
}

macro_rules! impl_pollardrho {
    ($t:ty, $u:ty, $reset:expr) =&gt; {
        impl PollardRho for $t {
            fn rho(self, arr: &amp;mut Vec&lt;Self&gt;, rng: &amp;mut rng::RNG) {
                if self &lt;= 1 {
                    return;
                } else if self.is_prime() {
                    arr.push(self);
                    return;
                }

                let mut i: u64 = 0;
                let mut x: $t = (rng.next_u64() % self as u64) as $t;
                let mut y: $t = x;
                let mut k: u64 = 2;
                let mut d: $t;
                let mut reset_limit: u64 = $reset;

                loop {
                    i += 1;
                    x = (((x as $u * x as $u % self as $u) + (self - 1) as $u) % self as $u) as $t;
                    d = gcd(y.abs_diff(x), self);
                    if d == self || i &gt;= reset_limit {
                        // Reset
                        reset_limit = reset_limit * 3 / 2;
                        i = 0;
                        x = (rng.next_u64() % self as u64) as $t;
                        y = x;
                    }
                    if d != 1 {
                        break;
                    }
                    if i == k {
                        y = x;
                        k &lt;&lt;= 1;
                    }
                }

                if d != self {
                    d.rho(arr, rng);
                    (self / d).rho(arr, rng);
                    return;
                }

                let mut i = 3;
                while i * i &lt;= self {
                    if self % i == 0 {
                        i.rho(arr, rng);
                        (d / i).rho(arr, rng);
                        return;
                    }
                    i += 2;
                }
            }
        }
    };
}

impl_pollardrho!(u8, u16, 100000);
impl_pollardrho!(u16, u32, 100000);
impl_pollardrho!(u32, u64, 100000);
impl_pollardrho!(u64, u128, 100000);

trait MillerRabin: From&lt;u8&gt; + PartialOrd {
    const MR_THRES: Self;
    fn naive_primality(self) -&gt; bool;
    fn miller_rabin_test(self, a: Self) -&gt; bool;
    fn miller_primality(self) -&gt; bool;
    fn is_prime(self) -&gt; bool {
        if self &lt;= 1.into() {
            false
        } else if self &lt;= Self::MR_THRES {
            self.naive_primality()
        } else {
            self.miller_primality()
        }
    }
}

macro_rules! impl_millerrabin {
        ($t:ty, $u:ty, $thres:expr, $($x:expr),*) =&gt; {
            impl MillerRabin for $t {
                const MR_THRES: Self = $thres;

                #[inline(always)]
                fn naive_primality(self) -&gt; bool {
                    for i in (2..).take_while(|&amp;i| i * i &lt;= self) {
                        if self % i == 0 {
                            return false;
                        }
                    }
                    true
                }

                #[inline(always)]
                fn miller_rabin_test(self, a: Self) -&gt; bool {
                    let d = self - 1;
                    let mut p = d &gt;&gt; (d.trailing_zeros());

                    let mut t = {
                        let mut base = a as $u;
                        let mut exp = p as $u;
                        let rem = self as $u;
                        let mut ret: $u = 1;
                        while exp != 0 {
                            if exp &amp; 1 != 0 {
                                ret = ret * base % rem;
                            }
                            base = base*base%rem;
                            exp &gt;&gt;= 1;
                        }
                        ret as $t
                    };

                    let at_last = t == d || t == 1;

                    while p != d {
                        p &lt;&lt;= 1;
                        t = ((t as $u * t as $u) % self as $u) as $t;
                        if t == self - 1 {
                            return true;
                        }
                    }
                    at_last
                }

                fn miller_primality(self) -&gt; bool {
                    $(
                        if !self.miller_rabin_test($x) {
                            return false;
                        }
                    )*
                    true
                }
            }
        };
    }

impl_millerrabin!(u8, u16, 254, 2);
impl_millerrabin!(u16, u32, 2000, 2, 3);
impl_millerrabin!(u32, u64, 7000, 2, 7, 61);
impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);

pub fn gcd&lt;T&gt;(x: T, y: T) -&gt; T
where
    T: Copy + PartialEq + PartialOrd + std::ops::Rem&lt;Output = T&gt; + From&lt;u8&gt;,
{
    if y == 0.into() {
        x
    } else {
        let v = x % y;
        gcd(y, v)
    }
}

mod rng {
    pub struct RNG {
        val: u64,
    }
    impl RNG {
        pub fn new(seed: u64) -&gt; Self {
            Self { val: seed }
        }
        pub fn next_u64(&amp;mut self) -&gt; u64 {
            let mut x = self.val;
            x ^= x &lt;&lt; 13;
            x ^= x &gt;&gt; 7;
            x ^= x &lt;&lt; 17;
            self.val = x;
            x
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-theoretic-transform-ntt"><a class="header" href="#number-theoretic-transform-ntt">Number Theoretic Transform (NTT)</a></h1>
<p>Number Theoretic Transform (NTT) is an alternative of FFT where the domain of numbers is \(\mathbb{Z}_p\) where \(p\) is a prime with a form of \(p = a \times 2^b + 1\).</p>
<p><code>ntt::convolute(&amp;[u64], &amp;[u64]) -&gt; Vec&lt;u64&gt;</code> convolutes two slices using two NTTs on two different primes and CRT, within a range that none of the numbers in the result exceed the range of <code>u64</code>.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a: Vec&lt;u64&gt; = vec![1, 2];
let b: Vec&lt;u64&gt; = vec![3, 4, 5];
println!(&quot;{:?}&quot;, ntt::convolute(&amp;a, &amp;b)); // [3, 10, 13, 10, 0, 0, 0, 0]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Not compatible with Rust 1.42.0
</span><span class="boring">mod ntt {
</span><span class="boring">    // FFT_constname convention following https://algoshitpo.github.io/2020/05/20/fft-ntt/
</span><span class="boring">    // p: prime for modulo
</span><span class="boring">    // w: primitive root of p
</span><span class="boring">    // p = a * 2^b + 1
</span><span class="boring">
</span><span class="boring">    //             p  ntt_a ntt_b   ntt_w
</span><span class="boring">    //   998,244,353    119    23       3
</span><span class="boring">    // 2,281,701,377    17     27       3
</span><span class="boring">    // 2,483,027,969    37     26       3
</span><span class="boring">    // 2,113,929,217    63     25       5
</span><span class="boring">    //   104,857,601    25     22       3
</span><span class="boring">    // 1,092,616,193    521    21       3
</span><span class="boring">
</span><span class="boring">    fn ceil_pow2(n: usize) -&gt; usize {
</span><span class="boring">        let mut x: usize = 0;
</span><span class="boring">        while (1 &lt;&lt; x) &lt; n {
</span><span class="boring">            x += 1;
</span><span class="boring">        }
</span><span class="boring">        x
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Reverses k trailing bits of n.
</span><span class="boring">    const fn reverse_trailing_bits(n: usize, k: u32) -&gt; usize {
</span><span class="boring">        let mut r = 0;
</span><span class="boring">        let mut i = 0;
</span><span class="boring">        while i &lt; k {
</span><span class="boring">            r |= ((n &gt;&gt; i) &amp; 1) &lt;&lt; (k - i - 1);
</span><span class="boring">            i += 1;
</span><span class="boring">        }
</span><span class="boring">        r
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Clone, Debug)]
</span><span class="boring">    pub struct Ntt&lt;const P: u64&gt; {
</span><span class="boring">        pub arr: Vec&lt;u64&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;const P: u64&gt; Ntt&lt;P&gt; {
</span><span class="boring">        pub const fn ntt_a() -&gt; u64 {
</span><span class="boring">            let mut p = P - 1;
</span><span class="boring">            while p &amp; 1 == 0 {
</span><span class="boring">                p &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">            p
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub const fn ntt_b() -&gt; u32 {
</span><span class="boring">            let mut p = P - 1;
</span><span class="boring">            let mut ret = 0;
</span><span class="boring">            while p &amp; 1 == 0 {
</span><span class="boring">                p &gt;&gt;= 1;
</span><span class="boring">                ret += 1;
</span><span class="boring">            }
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub const fn ntt_w() -&gt; u64 {
</span><span class="boring">            match P {
</span><span class="boring">                998244353 | 2281701377 | 2483027969 | 104857601 | 1092616193 =&gt; 3,
</span><span class="boring">                2113929217 =&gt; 5,
</span><span class="boring">                _ =&gt; todo!(),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        const fn pow(base: u64, exp: u64) -&gt; u64 {
</span><span class="boring">            let mut base = base;
</span><span class="boring">            let mut exp = exp;
</span><span class="boring">            let mut ret = 1;
</span><span class="boring">            while exp != 0 {
</span><span class="boring">                if exp &amp; 1 != 0 {
</span><span class="boring">                    ret = ret * base % P;
</span><span class="boring">                }
</span><span class="boring">                base = base * base % P;
</span><span class="boring">                exp &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // unity(n, 1) ^ (1&lt;&lt;n) == 1
</span><span class="boring">        const fn unity(n: u32, k: u64) -&gt; u64 {
</span><span class="boring">            Self::pow(
</span><span class="boring">                Self::pow(Self::ntt_w(), Self::ntt_a()),
</span><span class="boring">                k &lt;&lt; (Self::ntt_b() - n),
</span><span class="boring">            )
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        const fn recip(x: u64) -&gt; u64 {
</span><span class="boring">            Self::pow(x, P - 2)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn new(arr: Vec&lt;u64&gt;) -&gt; Self {
</span><span class="boring">            Self { arr }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn ntt(&amp;mut self) {
</span><span class="boring">            let n: usize = self.arr.len();
</span><span class="boring">            let k = n.trailing_zeros();
</span><span class="boring">            debug_assert_eq!(n, 1 &lt;&lt; k);
</span><span class="boring">
</span><span class="boring">            for i in 0..n {
</span><span class="boring">                let j = reverse_trailing_bits(i, k);
</span><span class="boring">                if i &lt; j {
</span><span class="boring">                    self.arr.swap(i, j);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            for x in 0..k {
</span><span class="boring">                let base: u64 = Self::unity(x + 1, 1);
</span><span class="boring">                let s = 1 &lt;&lt; x;
</span><span class="boring">                for i in (0..n).step_by(s &lt;&lt; 1) {
</span><span class="boring">                    let mut mult: u64 = 1;
</span><span class="boring">                    for j in 0..s {
</span><span class="boring">                        let tmp = (self.arr[i + j + s] * mult) % P;
</span><span class="boring">                        self.arr[i + j + s] = (self.arr[i + j] + P - tmp) % P;
</span><span class="boring">                        self.arr[i + j] = (self.arr[i + j] + tmp) % P;
</span><span class="boring">                        mult *= base;
</span><span class="boring">                        mult %= P;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn intt(&amp;mut self) {
</span><span class="boring">            let n: usize = self.arr.len();
</span><span class="boring">            let k = n.trailing_zeros();
</span><span class="boring">            debug_assert_eq!(n, 1 &lt;&lt; k);
</span><span class="boring">
</span><span class="boring">            for i in 0..n {
</span><span class="boring">                let j = reverse_trailing_bits(i, k);
</span><span class="boring">                if i &lt; j {
</span><span class="boring">                    self.arr.swap(i, j);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            for x in 0..k {
</span><span class="boring">                let base: u64 = Self::recip(Self::unity(x + 1, 1));
</span><span class="boring">                let s = 1 &lt;&lt; x;
</span><span class="boring">                for i in (0..n).step_by(s &lt;&lt; 1) {
</span><span class="boring">                    let mut mult: u64 = 1;
</span><span class="boring">                    for j in 0..s {
</span><span class="boring">                        let tmp = (self.arr[i + j + s] * mult) % P;
</span><span class="boring">                        self.arr[i + j + s] = (self.arr[i + j] + P - tmp) % P;
</span><span class="boring">                        self.arr[i + j] = (self.arr[i + j] + tmp) % P;
</span><span class="boring">                        mult *= base;
</span><span class="boring">                        mult %= P;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let r = Self::recip(n as u64);
</span><span class="boring">            for f in self.arr.iter_mut() {
</span><span class="boring">                *f *= r;
</span><span class="boring">                *f %= P;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn convolute(a: &amp;[u64], b: &amp;[u64]) -&gt; Self {
</span><span class="boring">            let nlen = 1 &lt;&lt; ceil_pow2(a.len() + b.len());
</span><span class="boring">            let pad = |a: &amp;[u64]| {
</span><span class="boring">                a.iter()
</span><span class="boring">                    .copied()
</span><span class="boring">                    .chain(std::iter::repeat(0))
</span><span class="boring">                    .take(nlen)
</span><span class="boring">                    .collect()
</span><span class="boring">            };
</span><span class="boring">            let arr = pad(a);
</span><span class="boring">            let brr = pad(b);
</span><span class="boring">
</span><span class="boring">            let mut arr = Self::new(arr);
</span><span class="boring">            let mut brr = Self::new(brr);
</span><span class="boring">            arr.ntt();
</span><span class="boring">            brr.ntt();
</span><span class="boring">
</span><span class="boring">            let crr: Vec&lt;_&gt; = arr
</span><span class="boring">                .arr
</span><span class="boring">                .iter()
</span><span class="boring">                .zip(brr.arr.iter())
</span><span class="boring">                .map(|(&amp;a, &amp;b)| a * b % P)
</span><span class="boring">                .collect();
</span><span class="boring">            let mut crr = Self::new(crr);
</span><span class="boring">            crr.intt();
</span><span class="boring">            crr
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn merge&lt;const P: u64, const Q: u64&gt;(one: &amp;[u64], two: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">        let p: u64 = Ntt::&lt;Q&gt;::recip(P);
</span><span class="boring">        let q: u64 = Ntt::&lt;P&gt;::recip(Q);
</span><span class="boring">        let r: u64 = P * Q;
</span><span class="boring">        one.iter()
</span><span class="boring">            .zip(two.iter())
</span><span class="boring">            .map(|(&amp;a1, &amp;a2)| {
</span><span class="boring">                ((a1 as u128 * q as u128 * Q as u128 + a2 as u128 * p as u128 * P as u128)
</span><span class="boring">                    % r as u128) as u64
</span><span class="boring">            })
</span><span class="boring">            .collect()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn convolute(a: &amp;[u64], b: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">        const P: u64 = 2281701377;
</span><span class="boring">        const Q: u64 = 998244353;
</span><span class="boring">        let a: Vec&lt;u64&gt; = a.iter().copied().collect();
</span><span class="boring">        let b: Vec&lt;u64&gt; = b.iter().copied().collect();
</span><span class="boring">
</span><span class="boring">        let arr = Ntt::&lt;P&gt;::convolute(&amp;a, &amp;b);
</span><span class="boring">        let brr = Ntt::&lt;Q&gt;::convolute(&amp;a, &amp;b);
</span><span class="boring">        merge::&lt;P, Q&gt;(&amp;arr.arr, &amp;brr.arr)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-5"><a class="header" href="#code-5">Code</a></h2>
<pre><code class="language-rust noplayground">// Not compatible with Rust 1.42.0
mod ntt {
    // FFT_constname convention following https://algoshitpo.github.io/2020/05/20/fft-ntt/
    // p: prime for modulo
    // w: primitive root of p
    // p = a * 2^b + 1

    //             p  ntt_a ntt_b   ntt_w
    //   998,244,353    119    23       3
    // 2,281,701,377    17     27       3
    // 2,483,027,969    37     26       3
    // 2,113,929,217    63     25       5
    //   104,857,601    25     22       3
    // 1,092,616,193    521    21       3

    fn ceil_pow2(n: usize) -&gt; usize {
        let mut x: usize = 0;
        while (1 &lt;&lt; x) &lt; n {
            x += 1;
        }
        x
    }

    /// Reverses k trailing bits of n.
    const fn reverse_trailing_bits(n: usize, k: u32) -&gt; usize {
        let mut r = 0;
        let mut i = 0;
        while i &lt; k {
            r |= ((n &gt;&gt; i) &amp; 1) &lt;&lt; (k - i - 1);
            i += 1;
        }
        r
    }

    #[derive(Clone, Debug)]
    pub struct Ntt&lt;const P: u64&gt; {
        pub arr: Vec&lt;u64&gt;,
    }

    impl&lt;const P: u64&gt; Ntt&lt;P&gt; {
        pub const fn ntt_a() -&gt; u64 {
            let mut p = P - 1;
            while p &amp; 1 == 0 {
                p &gt;&gt;= 1;
            }
            p
        }

        pub const fn ntt_b() -&gt; u32 {
            let mut p = P - 1;
            let mut ret = 0;
            while p &amp; 1 == 0 {
                p &gt;&gt;= 1;
                ret += 1;
            }
            ret
        }

        pub const fn ntt_w() -&gt; u64 {
            match P {
                998244353 | 2281701377 | 2483027969 | 104857601 | 1092616193 =&gt; 3,
                2113929217 =&gt; 5,
                _ =&gt; todo!(),
            }
        }

        const fn pow(base: u64, exp: u64) -&gt; u64 {
            let mut base = base;
            let mut exp = exp;
            let mut ret = 1;
            while exp != 0 {
                if exp &amp; 1 != 0 {
                    ret = ret * base % P;
                }
                base = base * base % P;
                exp &gt;&gt;= 1;
            }
            ret
        }

        // unity(n, 1) ^ (1&lt;&lt;n) == 1
        const fn unity(n: u32, k: u64) -&gt; u64 {
            Self::pow(
                Self::pow(Self::ntt_w(), Self::ntt_a()),
                k &lt;&lt; (Self::ntt_b() - n),
            )
        }

        const fn recip(x: u64) -&gt; u64 {
            Self::pow(x, P - 2)
        }

        pub fn new(arr: Vec&lt;u64&gt;) -&gt; Self {
            Self { arr }
        }

        pub fn ntt(&amp;mut self) {
            let n: usize = self.arr.len();
            let k = n.trailing_zeros();
            debug_assert_eq!(n, 1 &lt;&lt; k);

            for i in 0..n {
                let j = reverse_trailing_bits(i, k);
                if i &lt; j {
                    self.arr.swap(i, j);
                }
            }

            for x in 0..k {
                let base: u64 = Self::unity(x + 1, 1);
                let s = 1 &lt;&lt; x;
                for i in (0..n).step_by(s &lt;&lt; 1) {
                    let mut mult: u64 = 1;
                    for j in 0..s {
                        let tmp = (self.arr[i + j + s] * mult) % P;
                        self.arr[i + j + s] = (self.arr[i + j] + P - tmp) % P;
                        self.arr[i + j] = (self.arr[i + j] + tmp) % P;
                        mult *= base;
                        mult %= P;
                    }
                }
            }
        }

        pub fn intt(&amp;mut self) {
            let n: usize = self.arr.len();
            let k = n.trailing_zeros();
            debug_assert_eq!(n, 1 &lt;&lt; k);

            for i in 0..n {
                let j = reverse_trailing_bits(i, k);
                if i &lt; j {
                    self.arr.swap(i, j);
                }
            }

            for x in 0..k {
                let base: u64 = Self::recip(Self::unity(x + 1, 1));
                let s = 1 &lt;&lt; x;
                for i in (0..n).step_by(s &lt;&lt; 1) {
                    let mut mult: u64 = 1;
                    for j in 0..s {
                        let tmp = (self.arr[i + j + s] * mult) % P;
                        self.arr[i + j + s] = (self.arr[i + j] + P - tmp) % P;
                        self.arr[i + j] = (self.arr[i + j] + tmp) % P;
                        mult *= base;
                        mult %= P;
                    }
                }
            }

            let r = Self::recip(n as u64);
            for f in self.arr.iter_mut() {
                *f *= r;
                *f %= P;
            }
        }

        pub fn convolute(a: &amp;[u64], b: &amp;[u64]) -&gt; Self {
            let nlen = 1 &lt;&lt; ceil_pow2(a.len() + b.len());
            let pad = |a: &amp;[u64]| {
                a.iter()
                    .copied()
                    .chain(std::iter::repeat(0))
                    .take(nlen)
                    .collect()
            };
            let arr = pad(a);
            let brr = pad(b);

            let mut arr = Self::new(arr);
            let mut brr = Self::new(brr);
            arr.ntt();
            brr.ntt();

            let crr: Vec&lt;_&gt; = arr
                .arr
                .iter()
                .zip(brr.arr.iter())
                .map(|(&amp;a, &amp;b)| a * b % P)
                .collect();
            let mut crr = Self::new(crr);
            crr.intt();
            crr
        }
    }

    fn merge&lt;const P: u64, const Q: u64&gt;(one: &amp;[u64], two: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
        let p: u64 = Ntt::&lt;Q&gt;::recip(P);
        let q: u64 = Ntt::&lt;P&gt;::recip(Q);
        let r: u64 = P * Q;
        one.iter()
            .zip(two.iter())
            .map(|(&amp;a1, &amp;a2)| {
                ((a1 as u128 * q as u128 * Q as u128 + a2 as u128 * p as u128 * P as u128)
                    % r as u128) as u64
            })
            .collect()
    }

    pub fn convolute(a: &amp;[u64], b: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
        const P: u64 = 2281701377;
        const Q: u64 = 998244353;
        let a: Vec&lt;u64&gt; = a.iter().copied().collect();
        let b: Vec&lt;u64&gt; = b.iter().copied().collect();

        let arr = Ntt::&lt;P&gt;::convolute(&amp;a, &amp;b);
        let brr = Ntt::&lt;Q&gt;::convolute(&amp;a, &amp;b);
        merge::&lt;P, Q&gt;(&amp;arr.arr, &amp;brr.arr)
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-square-root"><a class="header" href="#integer-square-root">Integer Square Root</a></h1>
<p><code>isqrt(s)</code> returns \( \left\lfloor \sqrt{s} \right\rfloor \). It runs much faster than the typical binary search method, but slower than casting the result from <code>std::f64::sqrt</code>. If the value can be perfectly represented with <code>f64</code> and the memory limit isn't too short, it's better to use the <code>f64</code> square root function from <code>std</code>.</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let x: u64 = 10002;
let sq = isqrt(x);
println!(&quot;{}&quot;, sq); // 100
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn isqrt(s: u64) -&gt; u64 {
</span><span class="boring">    let mut x0 = s &gt;&gt; 1;
</span><span class="boring">    if x0 != 0 {
</span><span class="boring">        let mut x1 = (x0 + s / x0) &gt;&gt; 1;
</span><span class="boring">        while x1 &lt; x0 {
</span><span class="boring">            x0 = x1;
</span><span class="boring">            x1 = (x0 + s / x0) &gt;&gt; 1
</span><span class="boring">        }
</span><span class="boring">        x0
</span><span class="boring">    } else {
</span><span class="boring">        s
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-6"><a class="header" href="#code-6">Code</a></h2>
<pre><code class="language-rust noplayground">fn isqrt(s: u64) -&gt; u64 {
    let mut x0 = s &gt;&gt; 1;
    if x0 != 0 {
        let mut x1 = (x0 + s / x0) &gt;&gt; 1;
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) &gt;&gt; 1
        }
        x0
    } else {
        s
    }
}</code></pre>
<h2 id="generic-version-1"><a class="header" href="#generic-version-1">Generic Version</a></h2>
<p>The function below works for any primitive unsigned integer types.</p>
<pre><code class="language-rust noplayground">fn isqrt&lt;T&gt;(s: T) -&gt; T
where
    T: Copy
        + std::ops::Shr&lt;Output = T&gt;
        + std::ops::Add&lt;Output = T&gt;
        + std::ops::Div&lt;Output = T&gt;
        + PartialOrd
        + From&lt;u8&gt;,
{
    let mut x0 = s &gt;&gt; 1.into();
    if x0 != 0.into() {
        let mut x1 = (x0 + s / x0) &gt;&gt; 1.into();
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) &gt;&gt; 1.into();
        }
        x0
    } else {
        s
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sieve"><a class="header" href="#sieve">Sieve</a></h1>
<p>Linear sieve can find primes below \(N\) in \(O(N)\) time. With searching for primes, it can also calculate values of multiplicative functions for values below \(N\) in linear time.</p>
<h2 id="finding-primes"><a class="header" href="#finding-primes">Finding primes</a></h2>
<pre><code class="language-rust noplayground">fn sieve(max_val: usize) -&gt; (Vec&lt;bool&gt;, Vec&lt;usize&gt;) {
    let mut primes = vec![];
    let mut is_prime = vec![true; max_val + 1];
    is_prime[0] = false;
    is_prime[1] = false;

    for i in 2..=max_val {
        if is_prime[i] {
            primes.push(i);
        }
        for &amp;p in primes.iter() {
            let v = i * p;
            if v &gt; max_val {
                break;
            }
            is_prime[v] = false;
            if i % p == 0 {
                break;
            }
        }
    }

    (is_prime, primes)
}</code></pre>
<h2 id="with-euler-phi-function"><a class="header" href="#with-euler-phi-function">With Euler Phi Function</a></h2>
<pre><code class="language-rust noplayground">fn phi_sieve(max_val: usize) -&gt; (Vec&lt;bool&gt;, Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
    let mut primes = vec![];
    let mut is_prime = vec![true; max_val + 1];
    is_prime[0] = false;
    is_prime[1] = false;
    let mut phi = vec![0; max_val + 1];

    for i in 2..=max_val {
        if is_prime[i] {
            primes.push(i);
            phi[i] = i - 1;
        }
        for &amp;p in primes.iter() {
            let v = i * p;
            if v &gt; max_val {
                break;
            }
            is_prime[v] = false;
            if i % p == 0 {
                phi[v] = phi[i] * p;
                break;
            } else {
                phi[v] = phi[i] * phi[p]
            }
        }
    }

    (is_prime, phi, primes)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-recurrence"><a class="header" href="#linear-recurrence">Linear Recurrence</a></h1>
<p>Algorithms related to linear recurrences</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="berlekamp-massey"><a class="header" href="#berlekamp-massey">Berlekamp-Massey</a></h1>
<p><code>berlekamp_massey(A, m)</code> returns a vector <code>C</code> of length \(n\) which satisfies
\[ \begin{aligned}
A_x &amp;= \sum_{i=0}^{i=k-1} {C_i A_{x-k+i}} \\
&amp;= C_0 A_{x-k} + C_1 A_{x-k+1} + \cdots + C_{k-1} A_{x-1}
\end{aligned} \]
with minimum \(n\) under <strong>prime</strong> modulo \(m\). It is safe to have the length of <code>vals</code> as at least \(3n\).</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>// vals[x] = vals[x-3] + 2*vals[x-2] + 3*vals[x-1]
let m: u64 = 1000000007;
let mut vals: Vec&lt;u64&gt; = vec![1, 2, 3];
for x in 3..20 {
    vals.push((vals[x - 3] + 2 * vals[x - 2] + 3 * vals[x - 1]) % m);
}

let rec = berlekamp_massey(&amp;vals, m);
println!(&quot;{:?}&quot;, rec); // [1, 2, 3]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Berlekamp-Massey
</span><span class="boring">// References
</span><span class="boring">// https://blog.naver.com/jinhan814/222140081932
</span><span class="boring">// https://koosaga.com/231
</span><span class="boring">
</span><span class="boring">fn rem_pow(mut base: i64, mut exp: i64, m: i64) -&gt; i64 {
</span><span class="boring">    let mut result = 1;
</span><span class="boring">    while exp != 0 {
</span><span class="boring">        if exp &amp; 1 != 0 {
</span><span class="boring">            result = (result * base) % m;
</span><span class="boring">        }
</span><span class="boring">        exp &gt;&gt;= 1;
</span><span class="boring">        base = (base * base) % m;
</span><span class="boring">    }
</span><span class="boring">    result
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Finds rec[n] which satisfies
</span><span class="boring">/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rec[d-1]vals[d-1]
</span><span class="boring">/// with minimum n.
</span><span class="boring">fn berlekamp_massey(vals: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">    let m = m as i64;
</span><span class="boring">    let mut cur: Vec&lt;i64&gt; = Vec::new();
</span><span class="boring">    let (mut lf, mut ld) = (0, 0);
</span><span class="boring">    let mut ls: Vec&lt;i64&gt; = Vec::new();
</span><span class="boring">    for i in 0..vals.len() {
</span><span class="boring">        let mut t = 0;
</span><span class="boring">        for (j, v) in cur.iter().enumerate() {
</span><span class="boring">            t = (t + vals[i - j - 1] as i64 * v) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if (t - vals[i] as i64) % m == 0 {
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if cur.len() == 0 {
</span><span class="boring">            cur = vec![0; i + 1];
</span><span class="boring">            lf = i;
</span><span class="boring">            ld = (t - vals[i] as i64) % m;
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;
</span><span class="boring">        let mut c: Vec&lt;i64&gt; = vec![0; i - lf + ls.len()];
</span><span class="boring">        c[i - lf - 1] = k as i64;
</span><span class="boring">        for (p, j) in ls.iter().enumerate() {
</span><span class="boring">            c[i - lf + p] = -j * k % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if c.len() &lt; cur.len() {
</span><span class="boring">            c.extend((0..(cur.len() - c.len())).map(|_| 0));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        for j in 0..cur.len() {
</span><span class="boring">            c[j] = (c[j] + cur[j]) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if i - lf + ls.len() &gt;= cur.len() {
</span><span class="boring">            ls = cur;
</span><span class="boring">            lf = i;
</span><span class="boring">            ld = (t - vals[i] as i64) % m;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        cur = c;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    for i in 0..cur.len() {
</span><span class="boring">        cur[i] = (cur[i] % m + m) % m;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    cur.into_iter().rev().map(|x| x as u64).collect()
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-7"><a class="header" href="#code-7">Code</a></h2>
<pre><code class="language-rust noplayground">// Berlekamp-Massey
// References
// https://blog.naver.com/jinhan814/222140081932
// https://koosaga.com/231

fn rem_pow(mut base: i64, mut exp: i64, m: i64) -&gt; i64 {
    let mut result = 1;
    while exp != 0 {
        if exp &amp; 1 != 0 {
            result = (result * base) % m;
        }
        exp &gt;&gt;= 1;
        base = (base * base) % m;
    }
    result
}

/// Finds rec[n] which satisfies
/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rec[d-1]vals[d-1]
/// with minimum n.
fn berlekamp_massey(vals: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let m = m as i64;
    let mut cur: Vec&lt;i64&gt; = Vec::new();
    let (mut lf, mut ld) = (0, 0);
    let mut ls: Vec&lt;i64&gt; = Vec::new();
    for i in 0..vals.len() {
        let mut t = 0;
        for (j, v) in cur.iter().enumerate() {
            t = (t + vals[i - j - 1] as i64 * v) % m;
        }

        if (t - vals[i] as i64) % m == 0 {
            continue;
        }

        if cur.len() == 0 {
            cur = vec![0; i + 1];
            lf = i;
            ld = (t - vals[i] as i64) % m;
            continue;
        }

        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;
        let mut c: Vec&lt;i64&gt; = vec![0; i - lf + ls.len()];
        c[i - lf - 1] = k as i64;
        for (p, j) in ls.iter().enumerate() {
            c[i - lf + p] = -j * k % m;
        }

        if c.len() &lt; cur.len() {
            c.extend((0..(cur.len() - c.len())).map(|_| 0));
        }

        for j in 0..cur.len() {
            c[j] = (c[j] + cur[j]) % m;
        }

        if i - lf + ls.len() &gt;= cur.len() {
            ls = cur;
            lf = i;
            ld = (t - vals[i] as i64) % m;
        }

        cur = c;
    }

    for i in 0..cur.len() {
        cur[i] = (cur[i] % m + m) % m;
    }

    cur.into_iter().rev().map(|x| x as u64).collect()
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kitamasa"><a class="header" href="#kitamasa">Kitamasa</a></h1>
<p><code>kitamasa(C, A, n, m)</code> returns \(A_n\) where
\[ \begin{aligned}
A_x &amp;= \sum_{i=0}^{i=k-1} {C_i A_{x-k+i}} \\
&amp;= C_0 A_{x-k} + C_1 A_{x-k+1} + \cdots + C_{k-1} A_{x-1}
\end{aligned} \]
in a time complexity of \( O(T(k) \log{n}) \), where \(O(T(k))\) is a time complexity taken for multiplying two polynomials of order \(k\), and \(k\) is a length of \(C\).</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>// vals[x] = vals[x-3] + 2*vals[x-2] + 3*vals[x-1]
// 1, 2, 3, 14, 50, 181, 657, 2383, 8644, 31355, 113736, 412562, 1496513, 5428399, 19690785, 71425666, ...
let m: u64 = 1000000007;
let vals: Vec&lt;u64&gt; = vec![1, 2, 3];
let rec: Vec&lt;u64&gt; = vec![1, 2, 3];

let v = kitamasa(&amp;rec, &amp;vals, 15, m);
println!(&quot;{}&quot;, v); // 71425666
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Kitamasas
</span><span class="boring">// Reference: https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/
</span><span class="boring">
</span><span class="boring">fn poly_mul(v: &amp;[u64], w: &amp;[u64], rec: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
</span><span class="boring">    let mut t = vec![0; 2 * v.len()];
</span><span class="boring">
</span><span class="boring">    for j in 0..v.len() {
</span><span class="boring">        for k in 0..w.len() {
</span><span class="boring">            t[j + k] += v[j] * w[k] % m;
</span><span class="boring">            if t[j + k] &gt;= m {
</span><span class="boring">                t[j + k] -= m;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    for j in (v.len()..2 * v.len()).rev() {
</span><span class="boring">        for k in 1..=v.len() {
</span><span class="boring">            t[j - k] += t[j] * rec[k - 1] % m;
</span><span class="boring">            if t[j - k] &gt;= m {
</span><span class="boring">                t[j - k] -= m;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    t[..v.len()].iter().map(|x| *x).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Finds arr[n] where
</span><span class="boring">/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
</span><span class="boring">/// under modulo m where d=rec.len()=arr.len()
</span><span class="boring">fn kitamasa(rec: &amp;[u64], vals: &amp;[u64], mut n: u64, m: u64) -&gt; u64 {
</span><span class="boring">    let recurr: Vec&lt;_&gt; = rec.iter().rev().copied().collect();
</span><span class="boring">    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);
</span><span class="boring">    s[0] = 1;
</span><span class="boring">    if recurr.len() != 1 {
</span><span class="boring">        t[1] = 1;
</span><span class="boring">    } else {
</span><span class="boring">        t[0] = recurr[0];
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    while n != 0 {
</span><span class="boring">        if n &amp; 1 != 0 {
</span><span class="boring">            s = poly_mul(&amp;s, &amp;t, &amp;recurr, m);
</span><span class="boring">        }
</span><span class="boring">        t = poly_mul(&amp;t, &amp;t, &amp;recurr, m);
</span><span class="boring">        n &gt;&gt;= 1;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let mut ret = 0u64;
</span><span class="boring">    for i in 0..recurr.len() {
</span><span class="boring">        ret += s[i] * vals[i] % m;
</span><span class="boring">        if ret &gt;= m {
</span><span class="boring">            ret -= m;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    ret
</span><span class="boring">}</span></code></pre></pre>
<h2 id="ok2-logn-implementation"><a class="header" href="#ok2-logn-implementation">\(O(k^2 \log{n})\) Implementation</a></h2>
<p>The implementation below uses naive polynomial multiplication.</p>
<pre><code class="language-rust noplayground">// Kitamasa
// Reference: JusticeHui's Blog: &lt;https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/&gt;

fn poly_mul(v: &amp;[u64], w: &amp;[u64], rec: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut t = vec![0; 2 * v.len()];

    for j in 0..v.len() {
        for k in 0..w.len() {
            t[j + k] += v[j] * w[k] % m;
            if t[j + k] &gt;= m {
                t[j + k] -= m;
            }
        }
    }

    for j in (v.len()..2 * v.len()).rev() {
        for k in 1..=v.len() {
            t[j - k] += t[j] * rec[k - 1] % m;
            if t[j - k] &gt;= m {
                t[j - k] -= m;
            }
        }
    }

    t[..v.len()].iter().map(|x| *x).collect()
}

/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under modulo m where d=rec.len()=arr.len()
fn kitamasa(rec: &amp;[u64], vals: &amp;[u64], mut n: u64, m: u64) -&gt; u64 {
    let recurr: Vec&lt;_&gt; = rec.iter().rev().copied().collect();
    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);
    s[0] = 1;
    if recurr.len() != 1 {
        t[1] = 1;
    } else {
        t[0] = recurr[0];
    }

    while n != 0 {
        if n &amp; 1 != 0 {
            s = poly_mul(&amp;s, &amp;t, &amp;recurr, m);
        }
        t = poly_mul(&amp;t, &amp;t, &amp;recurr, m);
        n &gt;&gt;= 1;
    }

    let mut ret = 0u64;
    for i in 0..recurr.len() {
        ret += s[i] * vals[i] % m;
        if ret &gt;= m {
            ret -= m;
        }
    }
    ret
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bostan-mori"><a class="header" href="#bostan-mori">Bostan-Mori</a></h1>
<p>Reference - <a href="https://hal.inria.fr/hal-02917827v2/document">Alin Bostan, Ryuhei Mori. A Simple and Fast Algorithm for Computing the N-th Term of a Linearly Recurrent Sequence. SOSAâ€™21 (SIAM Symposium on Simplicity in Algorithms), Jan 2021, Alexandria, United States. ffhal-02917827v2f</a></p>
<h2 id="calculating-one-value-of-the-sequence"><a class="header" href="#calculating-one-value-of-the-sequence">Calculating one value of the sequence</a></h2>
<h3 id="naive-multiplication-under-prime-modulo"><a class="header" href="#naive-multiplication-under-prime-modulo">Naive multiplication, under prime modulo</a></h3>
<pre><code class="language-rust noplayground">/// Returns g, s, t s.t. g=gcd(a,b) and as+bt=r
#[inline(always)]
fn ext_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    let (mut s, mut old_s) = (0, 1);
    let (mut r, mut old_r) = (b, a);
    while r != 0 {
        let q = old_r / r;

        let new_r = old_r - q * r;
        old_r = r;
        r = new_r;

        let new_s = old_s - q * s;
        old_s = s;
        s = new_s;
    }

    (
        old_r,
        old_s,
        if b != 0 { (old_r - old_s * a) / b } else { 0 },
    )
}

fn mod_inv(a: u64, m: u64) -&gt; u64 {
    let (_, mut x, _) = ext_gcd((a % m) as i64, m as i64);
    if x &lt; 0 {
        x += m as i64;
    }
    x as u64 % m
}

/// f = f[0] + f[1]x + f[2]x2 + ...
#[inline(always)]
fn poly_mul(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; f.len() + g.len() - 1];
    for (i, &amp;u) in f.iter().enumerate() {
        // u*x**i
        for (j, &amp;v) in g.iter().enumerate() {
            // v*x**j
            h[i + j] += u * v;
            h[i + j] %= m;
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

#[inline(always)]
fn poly_mul_even_order(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; (f.len() + g.len()) / 2 + 2];
    for (i, &amp;u) in f.iter().enumerate() {
        if i &amp; 1 == 0 {
            for (j, &amp;v) in g.iter().enumerate().step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        } else {
            for (j, &amp;v) in g.iter().enumerate().skip(1).step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

#[inline(always)]
fn poly_mul_odd_order(f: &amp;[u64], g: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    let mut h: Vec&lt;u64&gt; = vec![0; (f.len() + g.len()) / 2 + 2];
    for (i, &amp;u) in f.iter().enumerate() {
        if i &amp; 1 != 0 {
            for (j, &amp;v) in g.iter().enumerate().step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        } else {
            for (j, &amp;v) in g.iter().enumerate().skip(1).step_by(2) {
                h[(i + j) &gt;&gt; 1] += u * v;
                h[(i + j) &gt;&gt; 1] %= m;
            }
        }
    }
    while let Some(&amp;v) = h.last() {
        if v != 0 {
            break;
        }
        h.pop();
    }
    h
}

/// f(x) -&gt; f(-x)
#[inline(always)]
fn get_neg_x(f: &amp;[u64], m: u64) -&gt; Vec&lt;u64&gt; {
    f.iter()
        .enumerate()
        .map(|(i, &amp;v)| if i &amp; 1 == 0 { v } else { m - v })
        .collect()
}

/// Finds arr[n] where
/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]
/// under modulo m where d=rec.len()=arr.len()
fn bostan_mori(rec: &amp;[u64], vals: &amp;[u64], n: u64, m: u64) -&gt; u64 {
    if vals.len() as u64 &gt; n {
        return vals[n as usize];
    }
    let d = rec.len();

    let mut q: Vec&lt;u64&gt; = Vec::with_capacity(d + 1);
    q.push(1);
    q.extend(rec.iter().map(|&amp;v| m - v).rev());

    let mut p = poly_mul(vals, &amp;q, m);
    p.truncate(d);

    let mut n = n;
    while n &gt;= 1 {
        let mq = get_neg_x(&amp;q, m);
        if n &amp; 1 == 0 {
            p = poly_mul_even_order(&amp;p, &amp;mq, m);
        } else {
            p = poly_mul_odd_order(&amp;p, &amp;mq, m);
        }
        q = poly_mul_even_order(&amp;q, &amp;mq, m);
        n &gt;&gt;= 1;
    }
    p[0] * mod_inv(q[0], m) // Requires GCD(q[0], m) = 1, it's safe to have m as a prime
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitset"><a class="header" href="#bitset">Bitset</a></h1>
<p><code>BitSet</code> is equivalent to a fixed-size array of booleans. Each boolean value is packed as a bit of <code>u64</code>.</p>
<p>For auto-vectorization, each <code>u64</code> are packed as <code>[u64; 4]</code> so that it can act as a &quot;SIMD lane&quot;.</p>
<p>As this snippet is purely for PS and CP, it does not contain many necessary checks, such as checking if two bitset as an argument of a function has the same length.
For any other purpose, I highly recommend the <a href="https://docs.rs/bitset-core/latest/bitset_core/">bitset_core crate</a> which highly inspired this snippet.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>An array of <code>[u64; 4]</code> implements <code>BitSetOps</code> trait, therefore is recognized as a bitset. The number of booleans packed into the bitset can be found with <code>fn bit_len(&amp;self) -&gt; usize</code>.</p>
<p>Refer to the <a href="datastructure/bitarray.html#apis">APIs</a> for further information.</p>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use bitset::*;
<span class="boring">
</span><span class="boring">fn main() {
</span>const MAX_VAL: usize = 1000000;

let mut is_prime = [[0u64; 4]; (MAX_VAL + 256) / 256];
println!(&quot;{}&quot;, is_prime.bit_len()); // 1000192

is_prime.bit_init(true);
is_prime.bit_reset(0);
is_prime.bit_reset(1);

for i in (2..=MAX_VAL).take_while(|&amp;i| i * i &lt;= MAX_VAL) {
    if is_prime.bit_get(i) {
        for j in (i * i..=MAX_VAL).step_by(i) {
            is_prime.bit_reset(j);
        }
    }
}

println!(
    &quot;{}&quot;,
    is_prime.bit_count_ones() - (is_prime.bit_len() - (MAX_VAL + 1))
); // 78498
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod bitset {
</span><span class="boring">    /* Copyright (c) 2020 Casper &lt;CasualX@users.noreply.github.com&gt;
</span><span class="boring">     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
</span><span class="boring">     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
</span><span class="boring">     * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</span><span class="boring">     */
</span><span class="boring">
</span><span class="boring">    //! This module is purely for PS and CP. Thus it skips safety checks such as checking if
</span><span class="boring">    //! self.len() and rhs.len() are equal, and it may panic if shift overflow (for the whole
</span><span class="boring">    //! bitset) happens.
</span><span class="boring">
</span><span class="boring">    // DO NOT CHANGE THESE VALUES
</span><span class="boring">    // The full generalization for bitset is not done.
</span><span class="boring">    type ElemTy = u64;
</span><span class="boring">    const ELEM_BIT: usize = ElemTy::BITS as usize;
</span><span class="boring">    const ELEM_LEN: usize = 4;
</span><span class="boring">    const BITS_PER_WORD: usize = ELEM_BIT * ELEM_LEN;
</span><span class="boring">
</span><span class="boring">    pub type BitSet = [[ElemTy; ELEM_LEN]];
</span><span class="boring">
</span><span class="boring">    pub trait BitSetOps {
</span><span class="boring">        fn bit_len(&amp;self) -&gt; usize;
</span><span class="boring">        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_get(&amp;self, idx: usize) -&gt; bool;
</span><span class="boring">        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_all(&amp;self) -&gt; bool;
</span><span class="boring">        fn bit_any(&amp;self) -&gt; bool;
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_none(&amp;self) -&gt; bool {
</span><span class="boring">            !self.bit_any()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool;
</span><span class="boring">        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool;
</span><span class="boring">        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool;
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_superset(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            rhs.bit_subset(self)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_not(&amp;mut self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_count_ones(&amp;self) -&gt; usize;
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_count_zeros(&amp;self) -&gt; usize {
</span><span class="boring">            self.bit_len() - self.bit_count_ones()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_fmt(&amp;self) -&gt; &amp;BitFmt&lt;Self&gt; {
</span><span class="boring">            unsafe { &amp;*(self as *const _ as *const _) }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl BitSetOps for BitSet {
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_len(&amp;self) -&gt; usize {
</span><span class="boring">            self.len() * BITS_PER_WORD
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self {
</span><span class="boring">            let val = [ElemTy::wrapping_add(!(val as ElemTy), 1); ELEM_LEN];
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i] = val;
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_get(&amp;self, idx: usize) -&gt; bool {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] &amp; (1 &lt;&lt; bit) != 0
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] |= 1 &lt;&lt; bit;
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] &amp;= !(1 &lt;&lt; bit);
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] ^= 1 &lt;&lt; bit;
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            let mask = 1 &lt;&lt; bit;
</span><span class="boring">            self[block][lane] =
</span><span class="boring">                (self[block][lane] &amp; !mask) | (ElemTy::wrapping_add(!(val as ElemTy), 1) &amp; mask);
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_all(&amp;self) -&gt; bool {
</span><span class="boring">            self.iter()
</span><span class="boring">                .all(|block| block[0] == !0 &amp;&amp; block[1] == !0 &amp;&amp; block[2] == !0 &amp;&amp; block[3] == !0)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_any(&amp;self) -&gt; bool {
</span><span class="boring">            self.iter()
</span><span class="boring">                .all(|block| block[0] == 0 &amp;&amp; block[1] == 0 &amp;&amp; block[2] == 0 &amp;&amp; block[3] == 0)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
</span><span class="boring">                lblk[0] == rblk[0] &amp;&amp; lblk[1] == rblk[1] &amp;&amp; lblk[2] == rblk[2] &amp;&amp; lblk[3] == rblk[3]
</span><span class="boring">            })
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
</span><span class="boring">                lblk[0] &amp; rblk[0] == 0
</span><span class="boring">                    &amp;&amp; lblk[1] &amp; rblk[1] == 0
</span><span class="boring">                    &amp;&amp; lblk[2] &amp; rblk[2] == 0
</span><span class="boring">                    &amp;&amp; lblk[3] &amp; rblk[3] == 0
</span><span class="boring">            })
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
</span><span class="boring">                rblk[0] == rblk[0] | lblk[0]
</span><span class="boring">                    &amp;&amp; rblk[1] == rblk[1] | lblk[1]
</span><span class="boring">                    &amp;&amp; rblk[2] == rblk[2] | lblk[2]
</span><span class="boring">                    &amp;&amp; rblk[3] == rblk[3] | lblk[3]
</span><span class="boring">            })
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] |= rhs[i][0];
</span><span class="boring">                self[i][1] |= rhs[i][1];
</span><span class="boring">                self[i][2] |= rhs[i][2];
</span><span class="boring">                self[i][3] |= rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] &amp;= rhs[i][0];
</span><span class="boring">                self[i][1] &amp;= rhs[i][1];
</span><span class="boring">                self[i][2] &amp;= rhs[i][2];
</span><span class="boring">                self[i][3] &amp;= rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] &amp;= !rhs[i][0];
</span><span class="boring">                self[i][1] &amp;= !rhs[i][1];
</span><span class="boring">                self[i][2] &amp;= !rhs[i][2];
</span><span class="boring">                self[i][3] &amp;= !rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] ^= rhs[i][0];
</span><span class="boring">                self[i][1] ^= rhs[i][1];
</span><span class="boring">                self[i][2] ^= rhs[i][2];
</span><span class="boring">                self[i][3] ^= rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_not(&amp;mut self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] = !self[i][0];
</span><span class="boring">                self[i][1] = !self[i][1];
</span><span class="boring">                self[i][2] = !self[i][2];
</span><span class="boring">                self[i][3] = !self[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] = self[i][0] &amp; !mask[i][0] | rhs[i][0] &amp; mask[i][0];
</span><span class="boring">                self[i][1] = self[i][1] &amp; !mask[i][1] | rhs[i][1] &amp; mask[i][1];
</span><span class="boring">                self[i][2] = self[i][2] &amp; !mask[i][2] | rhs[i][2] &amp; mask[i][2];
</span><span class="boring">                self[i][3] = self[i][3] &amp; !mask[i][3] | rhs[i][3] &amp; mask[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let elem_move = by / ELEM_BIT;
</span><span class="boring">            let bit_move = by % ELEM_BIT;
</span><span class="boring">
</span><span class="boring">            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
</span><span class="boring">            slice.copy_within(..slice.len() - elem_move, elem_move);
</span><span class="boring">            slice[..elem_move].fill(0);
</span><span class="boring">
</span><span class="boring">            if bit_move != 0 {
</span><span class="boring">                let mut carry: ElemTy = 0;
</span><span class="boring">                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
</span><span class="boring">                for i in 0..self.len() {
</span><span class="boring">                    tmp[0] = self[i][0] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[1] = self[i][1] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[2] = self[i][2] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[3] = self[i][3] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    self[i][0] &lt;&lt;= bit_move;
</span><span class="boring">                    self[i][1] &lt;&lt;= bit_move;
</span><span class="boring">                    self[i][2] &lt;&lt;= bit_move;
</span><span class="boring">                    self[i][3] &lt;&lt;= bit_move;
</span><span class="boring">                    let tmpc = tmp[ELEM_LEN - 1];
</span><span class="boring">                    tmp.copy_within(..ELEM_LEN - 1, 1);
</span><span class="boring">                    tmp[0] = carry;
</span><span class="boring">                    self[i][0] |= tmp[0];
</span><span class="boring">                    self[i][1] |= tmp[1];
</span><span class="boring">                    self[i][2] |= tmp[2];
</span><span class="boring">                    self[i][3] |= tmp[3];
</span><span class="boring">                    carry = tmpc;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let elem_move = by / ELEM_BIT;
</span><span class="boring">            let bit_move = by % ELEM_BIT;
</span><span class="boring">
</span><span class="boring">            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
</span><span class="boring">            slice.copy_within(elem_move.., 0);
</span><span class="boring">            let sl = slice.len();
</span><span class="boring">            slice[sl - elem_move..].fill(0);
</span><span class="boring">
</span><span class="boring">            if bit_move != 0 {
</span><span class="boring">                let mut carry: ElemTy = 0;
</span><span class="boring">                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
</span><span class="boring">                for i in 0..self.len() {
</span><span class="boring">                    tmp[0] = self[i][0] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[1] = self[i][1] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[2] = self[i][2] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[3] = self[i][3] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    self[i][0] &gt;&gt;= bit_move;
</span><span class="boring">                    self[i][1] &gt;&gt;= bit_move;
</span><span class="boring">                    self[i][2] &gt;&gt;= bit_move;
</span><span class="boring">                    self[i][3] &gt;&gt;= bit_move;
</span><span class="boring">                    let tmpc = tmp[0];
</span><span class="boring">                    tmp.copy_within(1.., 0);
</span><span class="boring">                    tmp[ELEM_LEN - 1] = carry;
</span><span class="boring">                    carry = tmpc;
</span><span class="boring">                    self[i][0] |= tmp[0];
</span><span class="boring">                    self[i][1] |= tmp[1];
</span><span class="boring">                    self[i][2] |= tmp[2];
</span><span class="boring">                    self[i][3] |= tmp[3];
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_count_ones(&amp;self) -&gt; usize {
</span><span class="boring">            self.iter()
</span><span class="boring">                .map(|chunk| {
</span><span class="boring">                    chunk[0].count_ones() as usize
</span><span class="boring">                        + chunk[1].count_ones() as usize
</span><span class="boring">                        + chunk[2].count_ones() as usize
</span><span class="boring">                        + chunk[3].count_ones() as usize
</span><span class="boring">                })
</span><span class="boring">                .sum()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    mod fmt {
</span><span class="boring">        use super::BitSetOps as BitSet;
</span><span class="boring">        use std::fmt;
</span><span class="boring">
</span><span class="boring">        #[repr(transparent)]
</span><span class="boring">        pub struct BitFmt&lt;T: ?Sized&gt;(T);
</span><span class="boring">
</span><span class="boring">        fn bitstring&lt;T: ?Sized + BitSet&gt;(this: &amp;T, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">            const ALPHABET: [u8; 2] = [b'0', b'1'];
</span><span class="boring">            let mut buf = [0u8; 9];
</span><span class="boring">            let mut first = true;
</span><span class="boring">            buf[0] = b'_';
</span><span class="boring">            let mut i = 0;
</span><span class="boring">            while i &lt; this.bit_len() {
</span><span class="boring">                buf[1] = ALPHABET[this.bit_get(i + 0) as usize];
</span><span class="boring">                buf[2] = ALPHABET[this.bit_get(i + 1) as usize];
</span><span class="boring">                buf[3] = ALPHABET[this.bit_get(i + 2) as usize];
</span><span class="boring">                buf[4] = ALPHABET[this.bit_get(i + 3) as usize];
</span><span class="boring">                buf[5] = ALPHABET[this.bit_get(i + 4) as usize];
</span><span class="boring">                buf[6] = ALPHABET[this.bit_get(i + 5) as usize];
</span><span class="boring">                buf[7] = ALPHABET[this.bit_get(i + 6) as usize];
</span><span class="boring">                buf[8] = ALPHABET[this.bit_get(i + 7) as usize];
</span><span class="boring">                let s = unsafe { &amp;*((&amp;buf[first as usize..]) as *const _ as *const str) };
</span><span class="boring">                f.write_str(s)?;
</span><span class="boring">                i += 8;
</span><span class="boring">                first = false;
</span><span class="boring">            }
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl&lt;T: ?Sized + BitSet&gt; fmt::Display for BitFmt&lt;T&gt; {
</span><span class="boring">            fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">                bitstring(&amp;self.0, f)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub use self::fmt::BitFmt;
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-8"><a class="header" href="#code-8">Code</a></h2>
<pre><code class="language-rust noplayground">mod bitset {
    /* Copyright (c) 2020 Casper &lt;CasualX@users.noreply.github.com&gt;
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */

    //! This module is purely for PS and CP. Thus it skips safety checks such as checking if
    //! self.len() and rhs.len() are equal, and it may panic if shift overflow (for the whole
    //! bitset) happens.

    // DO NOT CHANGE THESE VALUES
    // The full generalization for bitset is not done.
    type ElemTy = u64;
    const ELEM_BIT: usize = ElemTy::BITS as usize;
    const ELEM_LEN: usize = 4;
    const BITS_PER_WORD: usize = ELEM_BIT * ELEM_LEN;

    pub type BitSet = [[ElemTy; ELEM_LEN]];

    pub trait BitSetOps {
        fn bit_len(&amp;self) -&gt; usize;
        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self;

        fn bit_get(&amp;self, idx: usize) -&gt; bool;
        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self;

        fn bit_all(&amp;self) -&gt; bool;
        fn bit_any(&amp;self) -&gt; bool;
        #[inline]
        fn bit_none(&amp;self) -&gt; bool {
            !self.bit_any()
        }

        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool;
        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool;
        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool;
        #[inline]
        fn bit_superset(&amp;self, rhs: &amp;Self) -&gt; bool {
            rhs.bit_subset(self)
        }

        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_not(&amp;mut self) -&gt; &amp;mut Self;
        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self;

        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self;
        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self;

        fn bit_count_ones(&amp;self) -&gt; usize;
        #[inline]
        fn bit_count_zeros(&amp;self) -&gt; usize {
            self.bit_len() - self.bit_count_ones()
        }

        #[inline]
        fn bit_fmt(&amp;self) -&gt; &amp;BitFmt&lt;Self&gt; {
            unsafe { &amp;*(self as *const _ as *const _) }
        }
    }

    impl BitSetOps for BitSet {
        #[inline]
        fn bit_len(&amp;self) -&gt; usize {
            self.len() * BITS_PER_WORD
        }

        #[inline]
        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self {
            let val = [ElemTy::wrapping_add(!(val as ElemTy), 1); ELEM_LEN];
            for i in 0..self.len() {
                self[i] = val;
            }
            self
        }

        #[inline]
        fn bit_get(&amp;self, idx: usize) -&gt; bool {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] &amp; (1 &lt;&lt; bit) != 0
        }

        #[inline]
        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] |= 1 &lt;&lt; bit;
            self
        }

        #[inline]
        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] &amp;= !(1 &lt;&lt; bit);
            self
        }

        #[inline]
        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] ^= 1 &lt;&lt; bit;
            self
        }

        #[inline]
        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            let mask = 1 &lt;&lt; bit;
            self[block][lane] =
                (self[block][lane] &amp; !mask) | (ElemTy::wrapping_add(!(val as ElemTy), 1) &amp; mask);
            self
        }

        #[inline]
        fn bit_all(&amp;self) -&gt; bool {
            self.iter()
                .all(|block| block[0] == !0 &amp;&amp; block[1] == !0 &amp;&amp; block[2] == !0 &amp;&amp; block[3] == !0)
        }

        #[inline]
        fn bit_any(&amp;self) -&gt; bool {
            self.iter()
                .all(|block| block[0] == 0 &amp;&amp; block[1] == 0 &amp;&amp; block[2] == 0 &amp;&amp; block[3] == 0)
        }

        #[inline]
        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
                lblk[0] == rblk[0] &amp;&amp; lblk[1] == rblk[1] &amp;&amp; lblk[2] == rblk[2] &amp;&amp; lblk[3] == rblk[3]
            })
        }

        #[inline]
        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
                lblk[0] &amp; rblk[0] == 0
                    &amp;&amp; lblk[1] &amp; rblk[1] == 0
                    &amp;&amp; lblk[2] &amp; rblk[2] == 0
                    &amp;&amp; lblk[3] &amp; rblk[3] == 0
            })
        }

        /// Returns if self is a subset of rhs
        #[inline]
        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
                rblk[0] == rblk[0] | lblk[0]
                    &amp;&amp; rblk[1] == rblk[1] | lblk[1]
                    &amp;&amp; rblk[2] == rblk[2] | lblk[2]
                    &amp;&amp; rblk[3] == rblk[3] | lblk[3]
            })
        }

        #[inline]
        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] |= rhs[i][0];
                self[i][1] |= rhs[i][1];
                self[i][2] |= rhs[i][2];
                self[i][3] |= rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] &amp;= rhs[i][0];
                self[i][1] &amp;= rhs[i][1];
                self[i][2] &amp;= rhs[i][2];
                self[i][3] &amp;= rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] &amp;= !rhs[i][0];
                self[i][1] &amp;= !rhs[i][1];
                self[i][2] &amp;= !rhs[i][2];
                self[i][3] &amp;= !rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] ^= rhs[i][0];
                self[i][1] ^= rhs[i][1];
                self[i][2] ^= rhs[i][2];
                self[i][3] ^= rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_not(&amp;mut self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] = !self[i][0];
                self[i][1] = !self[i][1];
                self[i][2] = !self[i][2];
                self[i][3] = !self[i][3];
            }
            self
        }

        #[inline]
        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] = self[i][0] &amp; !mask[i][0] | rhs[i][0] &amp; mask[i][0];
                self[i][1] = self[i][1] &amp; !mask[i][1] | rhs[i][1] &amp; mask[i][1];
                self[i][2] = self[i][2] &amp; !mask[i][2] | rhs[i][2] &amp; mask[i][2];
                self[i][3] = self[i][3] &amp; !mask[i][3] | rhs[i][3] &amp; mask[i][3];
            }
            self
        }

        #[inline]
        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self {
            let elem_move = by / ELEM_BIT;
            let bit_move = by % ELEM_BIT;

            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
            slice.copy_within(..slice.len() - elem_move, elem_move);
            slice[..elem_move].fill(0);

            if bit_move != 0 {
                let mut carry: ElemTy = 0;
                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
                for i in 0..self.len() {
                    tmp[0] = self[i][0] &gt;&gt; (ELEM_BIT - bit_move);
                    tmp[1] = self[i][1] &gt;&gt; (ELEM_BIT - bit_move);
                    tmp[2] = self[i][2] &gt;&gt; (ELEM_BIT - bit_move);
                    tmp[3] = self[i][3] &gt;&gt; (ELEM_BIT - bit_move);
                    self[i][0] &lt;&lt;= bit_move;
                    self[i][1] &lt;&lt;= bit_move;
                    self[i][2] &lt;&lt;= bit_move;
                    self[i][3] &lt;&lt;= bit_move;
                    let tmpc = tmp[ELEM_LEN - 1];
                    tmp.copy_within(..ELEM_LEN - 1, 1);
                    tmp[0] = carry;
                    self[i][0] |= tmp[0];
                    self[i][1] |= tmp[1];
                    self[i][2] |= tmp[2];
                    self[i][3] |= tmp[3];
                    carry = tmpc;
                }
            }

            self
        }

        #[inline]
        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self {
            let elem_move = by / ELEM_BIT;
            let bit_move = by % ELEM_BIT;

            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
            slice.copy_within(elem_move.., 0);
            let sl = slice.len();
            slice[sl - elem_move..].fill(0);

            if bit_move != 0 {
                let mut carry: ElemTy = 0;
                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
                for i in 0..self.len() {
                    tmp[0] = self[i][0] &lt;&lt; (ELEM_BIT - bit_move);
                    tmp[1] = self[i][1] &lt;&lt; (ELEM_BIT - bit_move);
                    tmp[2] = self[i][2] &lt;&lt; (ELEM_BIT - bit_move);
                    tmp[3] = self[i][3] &lt;&lt; (ELEM_BIT - bit_move);
                    self[i][0] &gt;&gt;= bit_move;
                    self[i][1] &gt;&gt;= bit_move;
                    self[i][2] &gt;&gt;= bit_move;
                    self[i][3] &gt;&gt;= bit_move;
                    let tmpc = tmp[0];
                    tmp.copy_within(1.., 0);
                    tmp[ELEM_LEN - 1] = carry;
                    carry = tmpc;
                    self[i][0] |= tmp[0];
                    self[i][1] |= tmp[1];
                    self[i][2] |= tmp[2];
                    self[i][3] |= tmp[3];
                }
            }

            self
        }

        #[inline]
        fn bit_count_ones(&amp;self) -&gt; usize {
            self.iter()
                .map(|chunk| {
                    chunk[0].count_ones() as usize
                        + chunk[1].count_ones() as usize
                        + chunk[2].count_ones() as usize
                        + chunk[3].count_ones() as usize
                })
                .sum()
        }
    }

    mod fmt {
        use super::BitSetOps as BitSet;
        use std::fmt;

        #[repr(transparent)]
        pub struct BitFmt&lt;T: ?Sized&gt;(T);

        fn bitstring&lt;T: ?Sized + BitSet&gt;(this: &amp;T, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            const ALPHABET: [u8; 2] = [b'0', b'1'];
            let mut buf = [0u8; 9];
            let mut first = true;
            buf[0] = b'_';
            let mut i = 0;
            while i &lt; this.bit_len() {
                buf[1] = ALPHABET[this.bit_get(i + 0) as usize];
                buf[2] = ALPHABET[this.bit_get(i + 1) as usize];
                buf[3] = ALPHABET[this.bit_get(i + 2) as usize];
                buf[4] = ALPHABET[this.bit_get(i + 3) as usize];
                buf[5] = ALPHABET[this.bit_get(i + 4) as usize];
                buf[6] = ALPHABET[this.bit_get(i + 5) as usize];
                buf[7] = ALPHABET[this.bit_get(i + 6) as usize];
                buf[8] = ALPHABET[this.bit_get(i + 7) as usize];
                let s = unsafe { &amp;*((&amp;buf[first as usize..]) as *const _ as *const str) };
                f.write_str(s)?;
                i += 8;
                first = false;
            }
            Ok(())
        }

        impl&lt;T: ?Sized + BitSet&gt; fmt::Display for BitFmt&lt;T&gt; {
            fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
                bitstring(&amp;self.0, f)
            }
        }
    }
    pub use self::fmt::BitFmt;
}</code></pre>
<h2 id="simd-auto-vectorization-and-rustc-optimization-level"><a class="header" href="#simd-auto-vectorization-and-rustc-optimization-level">SIMD, Auto-vectorization and <code>rustc</code> Optimization Level</a></h2>
<p>To fully enable the power of aggressive SIMD optimization, the <code>opt-level</code> for compilation should be 3.
When the level is 2, despite many of vectorizations still happen, the occurence noticably decreases.</p>
<p>As most of the OJs compile Rust codes with <code>opt-level</code> of 2, to fully enable the power of SIMD, you need to hardcode the machine code into Rust.
As this is virtually impossible to do manually in actual PS/CP, using third-party tools like <a href="https://github.com/kiwiyou/basm-rs">basm-rs</a> is highly recommended.</p>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<p>The behavior of APIs having multiple bitsets as arguments, when their length are not equal to each other, is unspecified.</p>
<ul>
<li>
<p><code>pub type BitSet</code></p>
<p><code>[u64; 4]</code> is defined as a <code>type BitSet</code>.
As this is a dynamically sized type, when declaring a bitset you cannot use <code>BitSet</code> in its type declaration.
Instead, you need to do like the below example.</p>
<pre><code class="language-rust noplayground">let mut bitset</code></pre>
</li>
<li>
<p><code>fn bit_len(&amp;self) -&gt; usize</code></p>
<p>Returns the number of boolean values included in the set.</p>
</li>
<li>
<p><code>fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self</code></p>
<p>Initializes every boolean value of <code>self</code> as <code>val</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_get(&amp;self, idx: usize) -&gt; bool</code></p>
<p>Returns the <code>idx</code>th boolean value of <code>self</code>.</p>
</li>
<li>
<p><code>fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self</code></p>
<p>Sets the <code>idx</code>th boolean value to <code>true</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self</code></p>
<p>Sets the <code>idx</code>th boolean value to <code>false</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self</code></p>
<p>Flips the <code>idx</code>th boolean value, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self</code></p>
<p>Sets the <code>idx</code>th boolean value to <code>val</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_all(&amp;self) -&gt; bool</code></p>
<p>Returns <code>true</code> if every boolean value of <code>self</code> is <code>true</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_none(&amp;self) -&gt; bool</code></p>
<p>Returns <code>true</code> if every boolean value of <code>self</code> is <code>false</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool</code></p>
<p>Returns <code>true</code> if every bit of <code>self</code> turned on is not in <code>rhs</code>, and vice versa. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool</code></p>
<p>Returns <code>true</code> if <code>self</code> is a subset of <code>rhs</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_superset(&amp;self, rhs: &amp;Self) -&gt; bool</code></p>
<p>Returns <code>true</code> if <code>self</code> is a superset of <code>rhs</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self | rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self &amp; rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self &amp; !rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self ^ rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_not(&amp;mut self) -&gt; &amp;mut Self</code></p>
<p>Reverses every bits of <code>self</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>(self &amp; !mask) | (rhs &amp; mask)</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self</code></p>
<p>Shifts <code>self</code> right by <code>by</code>. The direction of shifting is to the lower index.
The empty bits are filled with <code>0</code>, and the overflowed bits disappear.</p>
</li>
<li>
<p><code>fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self</code></p>
<p>Shifts <code>self</code> left by <code>by</code>. The direction of shifting is to the lower index.
The empty bits are filled with <code>0</code>, and the overflowed bits disappear.</p>
</li>
<li>
<p><code>fn bit_count_ones(&amp;self) -&gt; usize</code></p>
<p>Returns the number of boolean values that is <code>true</code>.</p>
</li>
<li>
<p><code>fn bit_count_zeros(&amp;self) -&gt; usize</code></p>
<p>Returns the number of boolean values that is <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_fmt(&amp;self) -&gt; &amp;BitFmt&lt;Self&gt;</code></p>
<p>Used for printing out the bitset.</p>
<pre><code class="language-rust noplayground">println!(&quot;{}&quot;, bitset.bit_fmt());</code></pre>
</li>
</ul>
<h2 id="license-1"><a class="header" href="#license-1">License</a></h2>
<p>This code is protected under MIT license, holded by 
Casper <a href="mailto:datastructure/CasualX@users.noreply.github.com">CasualX@users.noreply.github.com</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-trees"><a class="header" href="#segment-trees">Segment Trees</a></h1>
<p>Segment trees are a category of data structures which can handle range queries efficiently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A segment tree is a data structure for monoids \( (S, \cdot : S \times S \rightarrow S, e \in S) \). A monoid is an algebraic structure which follows the following conditions:</p>
<ul>
<li>\(\cdot\) is associative. That is, \( (a \cdot b) \cdot c = a \cdot (b \cdot c) \) for all \( a, b, c \in S \).</li>
<li>There is the identity element \(e\) such that \( a \cdot e = e \cdot a = a \) for all \( a \in S \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(S\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Update an element</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use segtree::*;
</span><span class="boring">
</span>// Range sum segment tree
impl Monoid for i32 {
    fn e() -&gt; Self { 0 }
    fn opr_lhs(&amp;mut self, rhs: &amp;Self) { *self += rhs; }
    fn opr_rhs(&amp;mut self, lhs: &amp;Self) { *self += lhs; }
}

<span class="boring">fn main() {
</span>let mut st = SegTree::new(vec![0i32, 4, 0, 0, 0, 0, 0, 0, 0]);
st.set(2, 5);
st.set(4, 8);

println!(&quot;{}&quot;, st[2]);         // 5
println!(&quot;{}&quot;, st.prod(0..3)); // 9
println!(&quot;{}&quot;, st.prod(..));   // 17

let r = st.max_right(2, |&amp;x| x &lt; 13);
println!(&quot;{}&quot;, r);             // 4
let l = st.min_left(st.len(), |&amp;x| x &lt; 100);
println!(&quot;{}&quot;, l);             // 0
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod segtree {
</span><span class="boring">    use std::ops::{Index, RangeBounds};
</span><span class="boring">
</span><span class="boring">    fn ceil_pow2(n: usize) -&gt; u32 {
</span><span class="boring">        let mut x = 0;
</span><span class="boring">        while 1 &lt;&lt; x &lt; n {
</span><span class="boring">            x += 1;
</span><span class="boring">        }
</span><span class="boring">        x
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub trait Monoid: Sized {
</span><span class="boring">        fn e() -&gt; Self;
</span><span class="boring">        fn opr_lhs(&amp;mut self, rhs: &amp;Self);
</span><span class="boring">        fn opr_rhs(&amp;mut self, lhs: &amp;Self);
</span><span class="boring">        fn opr(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
</span><span class="boring">            let mut ret = Self::e();
</span><span class="boring">            ret.opr_rhs(lhs);
</span><span class="boring">            ret.opr_lhs(rhs);
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">        fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
</span><span class="boring">            *self = Self::opr(lhs, rhs);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct SegTree&lt;S&gt; {
</span><span class="boring">        n: usize,
</span><span class="boring">        size: usize,
</span><span class="boring">        log: u32,
</span><span class="boring">        data: Vec&lt;S&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;S: Monoid&gt; SegTree&lt;S&gt; {
</span><span class="boring">        fn update(&amp;mut self, k: usize) {
</span><span class="boring">            let mut ret = S::e();
</span><span class="boring">            ret.opr_set(&amp;self.data[k &lt;&lt; 1], &amp;self.data[(k &lt;&lt; 1) + 1]);
</span><span class="boring">            self.data[k] = ret;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn new(arr: Vec&lt;S&gt;) -&gt; Self {
</span><span class="boring">            let n = arr.len();
</span><span class="boring">            let log = ceil_pow2(n);
</span><span class="boring">            let size = 1 &lt;&lt; log;
</span><span class="boring">            let stsize = 1 &lt;&lt; (log + 1);
</span><span class="boring">
</span><span class="boring">            let mut data = Vec::with_capacity(stsize);
</span><span class="boring">            data.extend((0..size).map(|_| S::e()));
</span><span class="boring">            data.extend(arr.into_iter());
</span><span class="boring">            data.extend((data.len()..stsize).map(|_| S::e()));
</span><span class="boring">
</span><span class="boring">            let mut st = Self { n, size, log, data };
</span><span class="boring">            for i in (1..size).rev() {
</span><span class="boring">                st.update(i);
</span><span class="boring">            }
</span><span class="boring">            st
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">            self.n
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn set(&amp;mut self, i: usize, v: S) {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            self.data[i] = v;
</span><span class="boring">            for j in 1..=self.log {
</span><span class="boring">                self.update(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn get(&amp;self, i: usize) -&gt; &amp;S {
</span><span class="boring">            &amp;self.data[i + self.size]
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn prod(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; S {
</span><span class="boring">            use std::ops::Bound::*;
</span><span class="boring">            let (mut sml, mut smr) = (S::e(), S::e());
</span><span class="boring">            let mut l = match range.start_bound() {
</span><span class="boring">                Included(&amp;v) =&gt; v,
</span><span class="boring">                Excluded(&amp;v) =&gt; v + 1,
</span><span class="boring">                Unbounded =&gt; 0,
</span><span class="boring">            } + self.size;
</span><span class="boring">            let mut r = match range.end_bound() {
</span><span class="boring">                Included(&amp;v) =&gt; v + 1,
</span><span class="boring">                Excluded(&amp;v) =&gt; v,
</span><span class="boring">                Unbounded =&gt; self.n,
</span><span class="boring">            } + self.size;
</span><span class="boring">
</span><span class="boring">            if (l, r) == (0, self.n) {
</span><span class="boring">                let mut ret = S::e();
</span><span class="boring">                ret.opr_lhs(&amp;self.data[1]);
</span><span class="boring">                return ret;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            while l &lt; r {
</span><span class="boring">                if l &amp; 1 == 1 {
</span><span class="boring">                    sml.opr_lhs(&amp;self.data[l]);
</span><span class="boring">                    l += 1;
</span><span class="boring">                }
</span><span class="boring">                if r &amp; 1 == 1 {
</span><span class="boring">                    r -= 1;
</span><span class="boring">                    smr.opr_rhs(&amp;self.data[r]);
</span><span class="boring">                }
</span><span class="boring">                l &gt;&gt;= 1;
</span><span class="boring">                r &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            sml.opr_lhs(&amp;smr);
</span><span class="boring">            sml
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Given an index l and a check function f, max_right finds an index r that satisfies
</span><span class="boring">        ///   (r == l || f(self.prod(l..r)) &amp;&amp; (r == n || !f(self.prod(l..=r)))
</span><span class="boring">        /// If f is monotone, this is the maximum r that satisfies f(self.prod(l..r)).
</span><span class="boring">        /// It should be guaranteed that f(S::e()) is true, 0 &lt;= l and l &lt;= n.
</span><span class="boring">        pub fn max_right(&amp;self, l: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
</span><span class="boring">            if l == self.n {
</span><span class="boring">                return self.n;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut l = l + self.size;
</span><span class="boring">            let mut sm = S::e();
</span><span class="boring">
</span><span class="boring">            loop {
</span><span class="boring">                l &gt;&gt;= l.trailing_zeros();
</span><span class="boring">                if !f(&amp;S::opr(&amp;sm, &amp;self.data[l])) {
</span><span class="boring">                    while l &lt; self.size {
</span><span class="boring">                        l &lt;&lt;= 1;
</span><span class="boring">                        let tmp = S::opr(&amp;sm, &amp;self.data[l]);
</span><span class="boring">                        if f(&amp;tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            l += 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return l - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm.opr_lhs(&amp;self.data[l]);
</span><span class="boring">                l += 1;
</span><span class="boring">
</span><span class="boring">                if l &amp; ((!l) + 1) == l {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            self.n
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Given an index r and a check function f, min_left finds an index l that satisfies
</span><span class="boring">        ///   (l == r || f(self.prod(l..r))) &amp;&amp; (l == 0 || !f(self.prod(l-1..r)))
</span><span class="boring">        /// If f is monotone, this is the minimum l that satisfies f(self.prod(l..r)).
</span><span class="boring">        /// It should be guaranteed that f(S::e()) is true, 0 &lt;= r and r &lt;= n.
</span><span class="boring">        pub fn min_left(&amp;self, r: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
</span><span class="boring">            if r == 0 {
</span><span class="boring">                return 0;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut r = r + self.size;
</span><span class="boring">            let mut sm = S::e();
</span><span class="boring">
</span><span class="boring">            loop {
</span><span class="boring">                r -= 1;
</span><span class="boring">                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
</span><span class="boring">                    r &gt;&gt;= 1;
</span><span class="boring">                }
</span><span class="boring">                if !f(&amp;S::opr(&amp;self.data[r], &amp;sm)) {
</span><span class="boring">                    while r &lt; self.size {
</span><span class="boring">                        r = (r &lt;&lt; 1) + 1;
</span><span class="boring">                        let tmp = S::opr(&amp;self.data[r], &amp;sm);
</span><span class="boring">                        if f(&amp;tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            r -= 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return r + 1 - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm.opr_rhs(&amp;self.data[r]);
</span><span class="boring">
</span><span class="boring">                if r &amp; ((!r) + 1) == r {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            0
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;S: Monoid&gt; Index&lt;usize&gt; for SegTree&lt;S&gt; {
</span><span class="boring">        type Output = S;
</span><span class="boring">        fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
</span><span class="boring">            self.get(index)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-9"><a class="header" href="#code-9">Code</a></h2>
<pre><code class="language-rust noplayground">mod segtree {
    use std::ops::{Index, RangeBounds};

    fn ceil_pow2(n: usize) -&gt; u32 {
        let mut x = 0;
        while 1 &lt;&lt; x &lt; n {
            x += 1;
        }
        x
    }

    pub trait Monoid: Sized {
        fn e() -&gt; Self;
        fn opr_lhs(&amp;mut self, rhs: &amp;Self);
        fn opr_rhs(&amp;mut self, lhs: &amp;Self);
        fn opr(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
            let mut ret = Self::e();
            ret.opr_rhs(lhs);
            ret.opr_lhs(rhs);
            ret
        }
        fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
            *self = Self::opr(lhs, rhs);
        }
    }

    pub struct SegTree&lt;S&gt; {
        n: usize,
        size: usize,
        log: u32,
        data: Vec&lt;S&gt;,
    }

    impl&lt;S: Monoid&gt; SegTree&lt;S&gt; {
        fn update(&amp;mut self, k: usize) {
            let mut ret = S::e();
            ret.opr_set(&amp;self.data[k &lt;&lt; 1], &amp;self.data[(k &lt;&lt; 1) + 1]);
            self.data[k] = ret;
        }

        pub fn new(arr: Vec&lt;S&gt;) -&gt; Self {
            let n = arr.len();
            let log = ceil_pow2(n);
            let size = 1 &lt;&lt; log;
            let stsize = 1 &lt;&lt; (log + 1);

            let mut data = Vec::with_capacity(stsize);
            data.extend((0..size).map(|_| S::e()));
            data.extend(arr.into_iter());
            data.extend((data.len()..stsize).map(|_| S::e()));

            let mut st = Self { n, size, log, data };
            for i in (1..size).rev() {
                st.update(i);
            }
            st
        }

        pub fn len(&amp;self) -&gt; usize {
            self.n
        }

        pub fn get(&amp;self, i: usize) -&gt; &amp;S {
            &amp;self.data[i + self.size]
        }

        pub fn set(&amp;mut self, i: usize, v: S) {
            let i = i + self.size;
            self.data[i] = v;
            for j in 1..=self.log {
                self.update(i &gt;&gt; j);
            }
        }

        pub fn prod(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; S {
            use std::ops::Bound::*;
            let (mut sml, mut smr) = (S::e(), S::e());
            let mut l = match range.start_bound() {
                Included(&amp;v) =&gt; v,
                Excluded(&amp;v) =&gt; v + 1,
                Unbounded =&gt; 0,
            } + self.size;
            let mut r = match range.end_bound() {
                Included(&amp;v) =&gt; v + 1,
                Excluded(&amp;v) =&gt; v,
                Unbounded =&gt; self.n,
            } + self.size;

            if (l, r) == (0, self.n) {
                let mut ret = S::e();
                ret.opr_lhs(&amp;self.data[1]);
                return ret;
            }

            while l &lt; r {
                if l &amp; 1 == 1 {
                    sml.opr_lhs(&amp;self.data[l]);
                    l += 1;
                }
                if r &amp; 1 == 1 {
                    r -= 1;
                    smr.opr_rhs(&amp;self.data[r]);
                }
                l &gt;&gt;= 1;
                r &gt;&gt;= 1;
            }

            sml.opr_lhs(&amp;smr);
            sml
        }

        /// Given an index l and a check function f, max_right finds an index r that satisfies
        ///   (r == l || f(self.prod(l..r)) &amp;&amp; (r == n || !f(self.prod(l..=r)))
        /// If f is monotone, this is the maximum r that satisfies f(self.prod(l..r)).
        /// It should be guaranteed that f(S::e()) is true, 0 &lt;= l and l &lt;= n.
        pub fn max_right(&amp;self, l: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
            if l == self.n {
                return self.n;
            }

            let mut l = l + self.size;
            let mut sm = S::e();

            loop {
                l &gt;&gt;= l.trailing_zeros();
                if !f(&amp;S::opr(&amp;sm, &amp;self.data[l])) {
                    while l &lt; self.size {
                        l &lt;&lt;= 1;
                        let tmp = S::opr(&amp;sm, &amp;self.data[l]);
                        if f(&amp;tmp) {
                            sm = tmp;
                            l += 1;
                        }
                    }
                    return l - self.size;
                }
                sm.opr_lhs(&amp;self.data[l]);
                l += 1;

                if l &amp; ((!l) + 1) == l {
                    break;
                }
            }
            self.n
        }

        /// Given an index r and a check function f, min_left finds an index l that satisfies
        ///   (l == r || f(self.prod(l..r))) &amp;&amp; (l == 0 || !f(self.prod(l-1..r)))
        /// If f is monotone, this is the minimum l that satisfies f(self.prod(l..r)).
        /// It should be guaranteed that f(S::e()) is true, 0 &lt;= r and r &lt;= n.
        pub fn min_left(&amp;self, r: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
            if r == 0 {
                return 0;
            }

            let mut r = r + self.size;
            let mut sm = S::e();

            loop {
                r -= 1;
                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                    r &gt;&gt;= 1;
                }
                if !f(&amp;S::opr(&amp;self.data[r], &amp;sm)) {
                    while r &lt; self.size {
                        r = (r &lt;&lt; 1) + 1;
                        let tmp = S::opr(&amp;self.data[r], &amp;sm);
                        if f(&amp;tmp) {
                            sm = tmp;
                            r -= 1;
                        }
                    }
                    return r + 1 - self.size;
                }
                sm.opr_rhs(&amp;self.data[r]);

                if r &amp; ((!r) + 1) == r {
                    break;
                }
            }
            0
        }
    }

    impl&lt;S: Monoid&gt; Index&lt;usize&gt; for SegTree&lt;S&gt; {
        type Output = S;
        fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
            self.get(index)
        }
    }
}</code></pre>
<h2 id="apis-1"><a class="header" href="#apis-1">APIs</a></h2>
<ul>
<li>
<p><code>trait Monoid</code> represents a monoid \(S\) explained above. Three methods <code>e</code>, <code>opr_lhs</code>, <code>opr_rhs</code> are required to be implemented. Implementing <code>opr</code> and <code>opr_set</code> is optional.</p>
<ul>
<li><code>fn e() -&gt; Self</code> returns an identity element of the monoid.</li>
<li><code>fn opr_lhs(&amp;mut self, rhs: &amp;Self)</code> calculates the product of <code>self</code> and <code>rhs</code> in this order, and sets <code>self</code> with it.</li>
<li><code>fn opr_rhs(&amp;mut self, lhs: &amp;Self)</code> calculates the product of <code>lhs</code> and <code>self</code> in this order, and sets <code>self</code> with it.</li>
<li>(Optional) <code>fn opr(lhs: &amp;Self, rhs: &amp;Self)</code> calculates the product of <code>lhs</code> and <code>rhs</code> and returns it.</li>
<li>(Optional) <code>fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self)</code> calculates the product of <code>lhs</code> and <code>rhs</code> and sets <code>self</code> with it.</li>
</ul>
</li>
<li>
<p><code>fn new(arr: Vec&lt;S&gt;) -&gt; Self</code> generates a segment tree from <code>arr</code>.</p>
</li>
<li>
<p><code>fn len(&amp;self) -&gt; usize</code> returns the length of the segment tree, which is equal to the length of the array used for constructing the segment tree.</p>
</li>
<li>
<p><code>fn get(&amp;self, i: usize) -&gt; &amp;S</code> returns the reference to the <code>i</code>th element of the segment tree.</p>
</li>
<li>
<p><code>fn set(&amp;mut self, i: usize, v: S)</code> sets the <code>i</code>th element of the segment tree with <code>v</code>.</p>
</li>
<li>
<p><code>fn prod(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; S</code> returns the product of values of the segment tree within the given range.</p>
<ul>
<li>Example: <code>let v = st.prod(3..10);</code> <code>let u = st.prod(..7);</code></li>
</ul>
</li>
<li>
<p><code>fn max_right(&amp;self, l: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize</code> returns an index <code>r</code> such that <code>(r == l || f(self.prod(l..r)) &amp;&amp; (r == n || !f(self.prod(l..=r)))</code>. If <code>f</code> is monotone, this is the maximum <code>r</code> that makes <code>f(self.prod(l..r)</code> true. It must be guaranteed that <code>f(S::e())</code> is true, and <code>0 &lt;= l &lt;= n</code>. This method is basically equivalent to <code>partition_point</code> of a slice type, but with a set left bound.</p>
</li>
<li>
<p><code>fn min_left(&amp;self, r: usize, f: impl Fn(&amp;S) -&gt; bool) -&gt; usize</code> returns an index <code>l</code> such that <code>(l == r || f(self.prod(l..r))) &amp;&amp; (l == 0 || !f(self.prod(l-1..r)))</code>. If <code>f</code> is monotone, this is the minimum <code>l</code> that makes <code>f(self.prod(l..r))</code> true. It must be guaranteed that <code>f(S::e())</code> is true, and <code>0 &lt;= r &lt;= n</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fenwick-tree"><a class="header" href="#fenwick-tree">Fenwick Tree</a></h1>
<p>Given an integer array \(A\) of length \(n\), a Fenwick tree processes the following queries in \(O(\log{n})\) time:</p>
<ul>
<li>Add a certain amount to an element</li>
<li>Calculate the sum of the elements of an interval</li>
</ul>
<p>A Fenwick tree uses half the memory of a segment tree, but the performance in terms of time is just about the same.</p>
<p>A type of elements of \(A\) must be a primitive signed integer type, such as <code>i32</code> and <code>i64</code>, and floats such as <code>f64</code>. Unsigned integer types like <code>u64</code> do not work. Specifically, the type should implement <code>From&lt;i8&gt;</code>.</p>
<h2 id="example-11"><a class="header" href="#example-11">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut fw: Fenwick&lt;i32&gt; = Fenwick::new(10);
for i in 0..10 {
    print!(&quot;{} &quot;, fw.get(i));
}
println!(); // 0 0 0 0 0 0 0 0 0 0
fw.add(2, 10);
fw.add(5, 100);
fw.add(3, -1);
for i in 0..10 {
    print!(&quot;{} &quot;, fw.get(i));
}
println!(); // 0 0 10 -1 0 100 0 0 0 0
println!(&quot;{}&quot;, fw.sum(3..8)); // 99
<span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Fenwick&lt;T&gt; {
</span><span class="boring">    n: usize,
</span><span class="boring">    data: Vec&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Copy + From&lt;i8&gt; + std::ops::AddAssign + std::ops::Sub&lt;Output = T&gt;&gt; Fenwick&lt;T&gt; {
</span><span class="boring">    fn new(n: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            data: vec![0.into(); n],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add(&amp;mut self, idx: usize, val: T) {
</span><span class="boring">        let mut idx = idx + 1;
</span><span class="boring">        while idx &lt;= self.n {
</span><span class="boring">            self.data[idx - 1] += val;
</span><span class="boring">            idx += idx &amp; (!idx + 1);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self, idx: usize) -&gt; T {
</span><span class="boring">        self.sum(idx..=idx)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn sum(&amp;self, range: impl std::ops::RangeBounds&lt;usize&gt;) -&gt; T {
</span><span class="boring">        use std::ops::Bound::*;
</span><span class="boring">        let l = match range.start_bound() {
</span><span class="boring">            Included(&amp;v) =&gt; v,
</span><span class="boring">            Excluded(&amp;v) =&gt; v + 1,
</span><span class="boring">            Unbounded =&gt; 0,
</span><span class="boring">        };
</span><span class="boring">        let r = match range.end_bound() {
</span><span class="boring">            Included(&amp;v) =&gt; v + 1,
</span><span class="boring">            Excluded(&amp;v) =&gt; v,
</span><span class="boring">            Unbounded =&gt; self.n,
</span><span class="boring">        };
</span><span class="boring">        self.inner_sum(r) - self.inner_sum(l)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn inner_sum(&amp;self, mut r: usize) -&gt; T {
</span><span class="boring">        let mut s: T = 0.into();
</span><span class="boring">        while r &gt; 0 {
</span><span class="boring">            s += self.data[r - 1];
</span><span class="boring">            r -= r &amp; (!r + 1);
</span><span class="boring">        }
</span><span class="boring">        s
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-10"><a class="header" href="#code-10">Code</a></h2>
<pre><code class="language-rust noplayground#[derive(Clone  Debug)]">struct Fenwick&lt;T&gt; {
    n: usize,
    data: Vec&lt;T&gt;,
}

impl&lt;T: Copy + From&lt;i8&gt; + std::ops::AddAssign + std::ops::Sub&lt;Output = T&gt;&gt; Fenwick&lt;T&gt; {
    fn new(n: usize) -&gt; Self {
        Self {
            n,
            data: vec![0.into(); n],
        }
    }

    fn add(&amp;mut self, idx: usize, val: T) {
        let mut idx = idx + 1;
        while idx &lt;= self.n {
            self.data[idx - 1] += val;
            idx += idx &amp; (!idx + 1);
        }
    }

    fn get(&amp;self, idx: usize) -&gt; T {
        self.sum(idx..=idx)
    }

    fn sum(&amp;self, range: impl std::ops::RangeBounds&lt;usize&gt;) -&gt; T {
        use std::ops::Bound::*;
        let l = match range.start_bound() {
            Included(&amp;v) =&gt; v,
            Excluded(&amp;v) =&gt; v + 1,
            Unbounded =&gt; 0,
        };
        let r = match range.end_bound() {
            Included(&amp;v) =&gt; v + 1,
            Excluded(&amp;v) =&gt; v,
            Unbounded =&gt; self.n,
        };
        self.inner_sum(r) - self.inner_sum(l)
    }

    fn inner_sum(&amp;self, mut r: usize) -&gt; T {
        let mut s: T = 0.into();
        while r &gt; 0 {
            s += self.data[r - 1];
            r -= r &amp; (!r + 1);
        }
        s
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-segment-tree"><a class="header" href="#lazy-segment-tree">Lazy Segment Tree</a></h1>
<p>Reference: AtCoder library <a href="https://atcoder.github.io/ac-library/production/document_en/index.html">https://atcoder.github.io/ac-library/production/document_en/index.html</a></p>
<p>A lazy segment tree is a data struture for a pair of <a href="datastructure/segtree/./segtree.html">a monoid</a> \( (S, \cdot : S \times S \rightarrow S, e \in S) \) and a set \(F\) of \(S \rightarrow S\) mappings that satisfies the following properties:</p>
<ul>
<li>\(F\) contains the identity mapping \(Id\) such that \( Id(x) = x \) for all \(x\in S\).</li>
<li>\(F\) is closed under composition. That is, \( f \circ g \in F \) for all \( f, g \in F \).</li>
<li>\( f (x \cdot y) = f(x) \cdot f(y) \) hold for all \(f \in F \) and \( x, y \in S \).</li>
</ul>
<p>Given an array \(A\) of length \(n\) consists of the monoid \(S\) as described above, a segment tree on it can process the following queries in \(O (\log{n})\) time:</p>
<ul>
<li>Apply the mapping \( f \in F \) on all the elements of an interval</li>
<li>Calculate the product of the elements of an interval</li>
</ul>
<p>assuming that calculating the product of two elements takes \(O(1)\) time.</p>
<h2 id="example-12"><a class="header" href="#example-12">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use lazyseg::*;
</span><span class="boring">
</span>// ax+b lazy segment tree
type P = (i64, i64);

// P = (sum, len)
impl LzMonoid for P {
    fn e() -&gt; Self { (0, 0) }
    fn opr_lhs(&amp;mut self, rhs: &amp;Self) {
        self.0 += rhs.0; self.1 += rhs.1;
    }
    fn opr_rhs(&amp;mut self, lhs: &amp;Self) {
        self.0 += lhs.0; self.1 += lhs.1;
    }
}

// P = (a, b) equiv. to applying ax+b on LzMonoids
impl LzMap&lt;P&gt; for P {
    fn id() -&gt; Self { (1, 0) }
    fn map(&amp;self, apply: &amp;mut P) {
        apply.0 = self.0 * apply.0 + self.1 * apply.1;
    }
    fn compos_lhs(&amp;mut self, rhs: &amp;Self) {
        let (a, b, c, d) = (self.0, self.1, rhs.0, rhs.1);
        *self = (a * c, a * d + b);
    }
    fn compos_rhs(&amp;mut self, lhs: &amp;Self) {
        let (a, b, c, d) = (lhs.0, lhs.1, self.0, self.1);
        *self = (a * c, a * d + b);
    }
}

<span class="boring">fn main() {
</span>let mut st: LazySeg&lt;_, P&gt; = LazySeg::new((0..10).map(|v| (v, 1)).collect());
println!(&quot;{}&quot;, st.get(3).0); // 3
println!(&quot;{}&quot;, st.prod(2..6).0); // 14

// Add 5 to 1..6
st.apply_range(1..6, &amp;(1, 5));
// Multiply 6.. by 4
st.apply_range(6.., &amp;(4, 0));
// 0 6 7 8 9 10 24 28 32 36

let r = st.max_right(4, |&amp;(v, _)| v &lt; 43);
println!(&quot;{}&quot;, r); // 6
let l = st.min_left(6, |&amp;(v, _)| v &lt; 32);
println!(&quot;{}&quot;, l); // 3
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod lazyseg {
</span><span class="boring">    use std::ops::RangeBounds;
</span><span class="boring">
</span><span class="boring">    fn ceil_pow2(n: usize) -&gt; u32 {
</span><span class="boring">        let mut x = 0;
</span><span class="boring">        while 1 &lt;&lt; x &lt; n {
</span><span class="boring">            x += 1;
</span><span class="boring">        }
</span><span class="boring">        x
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn range_to_bounds(n: usize, range: impl RangeBounds&lt;usize&gt;) -&gt; (usize, usize) {
</span><span class="boring">        use std::ops::Bound::*;
</span><span class="boring">
</span><span class="boring">        let l = match range.start_bound() {
</span><span class="boring">            Included(&amp;v) =&gt; v,
</span><span class="boring">            Excluded(&amp;v) =&gt; v + 1,
</span><span class="boring">            Unbounded =&gt; 0,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let r = match range.end_bound() {
</span><span class="boring">            Included(&amp;v) =&gt; v + 1,
</span><span class="boring">            Excluded(&amp;v) =&gt; v,
</span><span class="boring">            Unbounded =&gt; n,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        (l, r)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub trait LzMonoid: Sized {
</span><span class="boring">        fn e() -&gt; Self;
</span><span class="boring">        fn opr_lhs(&amp;mut self, rhs: &amp;Self);
</span><span class="boring">        fn opr_rhs(&amp;mut self, lhs: &amp;Self);
</span><span class="boring">        fn opr(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
</span><span class="boring">            let mut ret = Self::e();
</span><span class="boring">            ret.opr_rhs(lhs);
</span><span class="boring">            ret.opr_lhs(rhs);
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">        fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
</span><span class="boring">            *self = Self::opr(lhs, rhs);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub trait LzMap&lt;S&gt;: Sized {
</span><span class="boring">        fn id() -&gt; Self;
</span><span class="boring">        fn map(&amp;self, apply: &amp;mut S);
</span><span class="boring">        fn compos_lhs(&amp;mut self, rhs: &amp;Self);
</span><span class="boring">        fn compos_rhs(&amp;mut self, lhs: &amp;Self);
</span><span class="boring">        fn compos(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
</span><span class="boring">            let mut ret = Self::id();
</span><span class="boring">            ret.compos_rhs(lhs);
</span><span class="boring">            ret.compos_lhs(rhs);
</span><span class="boring">            ret
</span><span class="boring">        }
</span><span class="boring">        fn opr_self(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
</span><span class="boring">            *self = Self::compos(lhs, rhs);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct LazySeg&lt;S, F&gt; {
</span><span class="boring">        n: usize,
</span><span class="boring">        size: usize,
</span><span class="boring">        log: u32,
</span><span class="boring">        data: Vec&lt;S&gt;,
</span><span class="boring">        lazy: Vec&lt;F&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;S, F&gt; LazySeg&lt;S, F&gt;
</span><span class="boring">    where
</span><span class="boring">        S: LzMonoid,
</span><span class="boring">        F: LzMap&lt;S&gt;,
</span><span class="boring">    {
</span><span class="boring">        fn update(&amp;mut self, k: usize) {
</span><span class="boring">            let val = S::opr(&amp;self.data[k &lt;&lt; 1], &amp;self.data[(k &lt;&lt; 1) + 1]);
</span><span class="boring">            self.data[k] = val;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn all_apply(&amp;mut self, k: usize, f: &amp;F) {
</span><span class="boring">            f.map(&amp;mut self.data[k]);
</span><span class="boring">            if k &lt; self.size {
</span><span class="boring">                self.lazy[k].compos_rhs(f);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn all_apply_unsafe(size: usize, k: usize, f: usize, data: &amp;mut [S], lazy: &amp;mut [F]) {
</span><span class="boring">            // f &lt; k
</span><span class="boring">            lazy[f].map(&amp;mut data[k]);
</span><span class="boring">            if k &lt; size {
</span><span class="boring">                let (fs, ks) = lazy.split_at_mut(k);
</span><span class="boring">                ks[0].compos_rhs(&amp;fs[f]);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn push(&amp;mut self, k: usize) {
</span><span class="boring">            Self::all_apply_unsafe(self.size, k &lt;&lt; 1, k, &amp;mut self.data, &amp;mut self.lazy);
</span><span class="boring">            Self::all_apply_unsafe(self.size, (k &lt;&lt; 1) + 1, k, &amp;mut self.data, &amp;mut self.lazy);
</span><span class="boring">            self.lazy[k] = F::id();
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn new(arr: Vec&lt;S&gt;) -&gt; Self {
</span><span class="boring">            let n = arr.len();
</span><span class="boring">            let log = ceil_pow2(n);
</span><span class="boring">            let size = 1 &lt;&lt; log;
</span><span class="boring">            let stsize = 1 &lt;&lt; (log + 1);
</span><span class="boring">
</span><span class="boring">            let mut data = Vec::with_capacity(stsize);
</span><span class="boring">            data.extend((0..size).map(|_| S::e()));
</span><span class="boring">            data.extend(arr.into_iter());
</span><span class="boring">            data.extend((data.len()..stsize).map(|_| S::e()));
</span><span class="boring">
</span><span class="boring">            let mut ls = Self {
</span><span class="boring">                n,
</span><span class="boring">                log,
</span><span class="boring">                size,
</span><span class="boring">                data,
</span><span class="boring">                lazy: Vec::from_iter((0..size).map(|_| F::id())),
</span><span class="boring">            };
</span><span class="boring">            for i in (1..size).rev() {
</span><span class="boring">                ls.update(i);
</span><span class="boring">            }
</span><span class="boring">            ls
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn set(&amp;mut self, i: usize, v: S) {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            for j in (1..=self.log).rev() {
</span><span class="boring">                self.push(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">            self.data[i] = v;
</span><span class="boring">            for j in 1..=self.log {
</span><span class="boring">                self.update(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn get(&amp;mut self, i: usize) -&gt; &amp;S {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            for j in (1..=self.log).rev() {
</span><span class="boring">                self.push(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">            &amp;self.data[i]
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn prod(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; S {
</span><span class="boring">            let (l, r) = range_to_bounds(self.size, range);
</span><span class="boring">
</span><span class="boring">            if l == 0 &amp;&amp; r == self.size {
</span><span class="boring">                let mut ret = S::e();
</span><span class="boring">                ret.opr_lhs(&amp;self.data[1]);
</span><span class="boring">                return ret;
</span><span class="boring">            } else if l == r {
</span><span class="boring">                return S::e();
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut l, mut r) = (l + self.size, r + self.size);
</span><span class="boring">
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                if ((l &gt;&gt; i) &lt;&lt; i) != l {
</span><span class="boring">                    self.push(l &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">                if ((r &gt;&gt; i) &lt;&lt; i) != r {
</span><span class="boring">                    self.push((r - 1) &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut sml, mut smr) = (S::e(), S::e());
</span><span class="boring">            while l &lt; r {
</span><span class="boring">                if l &amp; 1 == 1 {
</span><span class="boring">                    sml.opr_lhs(&amp;self.data[l]);
</span><span class="boring">                    l += 1;
</span><span class="boring">                }
</span><span class="boring">                if r &amp; 1 == 1 {
</span><span class="boring">                    r -= 1;
</span><span class="boring">                    smr.opr_rhs(&amp;self.data[r]);
</span><span class="boring">                }
</span><span class="boring">                l &gt;&gt;= 1;
</span><span class="boring">                r &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            S::opr(&amp;sml, &amp;smr)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn apply(&amp;mut self, i: usize, f: &amp;F) {
</span><span class="boring">            let i = i + self.size;
</span><span class="boring">            for j in (1..=self.log).rev() {
</span><span class="boring">                self.push(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">            f.map(&amp;mut self.data[i]);
</span><span class="boring">            for j in 1..=self.log {
</span><span class="boring">                self.update(i &gt;&gt; j);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn apply_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;, f: &amp;F) {
</span><span class="boring">            let (l, r) = range_to_bounds(self.size, range);
</span><span class="boring">
</span><span class="boring">            if l == r {
</span><span class="boring">                return;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (mut l, mut r) = (l + self.size, r + self.size);
</span><span class="boring">
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                if ((l &gt;&gt; i) &lt;&lt; i) != l {
</span><span class="boring">                    self.push(l &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">                if ((r &gt;&gt; i) &lt;&lt; i) != r {
</span><span class="boring">                    self.push((r - 1) &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let (l2, r2) = (l, r);
</span><span class="boring">            while l &lt; r {
</span><span class="boring">                if l &amp; 1 == 1 {
</span><span class="boring">                    self.all_apply(l, f);
</span><span class="boring">                    l += 1;
</span><span class="boring">                }
</span><span class="boring">                if r &amp; 1 == 1 {
</span><span class="boring">                    r -= 1;
</span><span class="boring">                    self.all_apply(r, f);
</span><span class="boring">                }
</span><span class="boring">                l &gt;&gt;= 1;
</span><span class="boring">                r &gt;&gt;= 1;
</span><span class="boring">            }
</span><span class="boring">            l = l2;
</span><span class="boring">            r = r2;
</span><span class="boring">
</span><span class="boring">            for i in 1..=self.log {
</span><span class="boring">                if ((l &gt;&gt; i) &lt;&lt; i) != l {
</span><span class="boring">                    self.update(l &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">                if ((r &gt;&gt; i) &lt;&lt; i) != r {
</span><span class="boring">                    self.update((r - 1) &gt;&gt; i);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn max_right(&amp;mut self, l: usize, g: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
</span><span class="boring">            if l == self.n {
</span><span class="boring">                return self.n;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut l = l + self.size;
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                self.push(l &gt;&gt; i);
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut sm = S::e();
</span><span class="boring">            loop {
</span><span class="boring">                l &gt;&gt;= l.trailing_zeros();
</span><span class="boring">                if !g(&amp;S::opr(&amp;sm, &amp;self.data[l])) {
</span><span class="boring">                    while l &lt; self.size {
</span><span class="boring">                        self.push(l);
</span><span class="boring">                        l &lt;&lt;= 1;
</span><span class="boring">                        let tmp = S::opr(&amp;sm, &amp;self.data[l]);
</span><span class="boring">                        if g(&amp;tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            l += 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return l - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm.opr_lhs(&amp;self.data[l]);
</span><span class="boring">                l += 1;
</span><span class="boring">
</span><span class="boring">                if l &amp; ((!l) + 1) != l {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            self.n
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn min_left(&amp;mut self, r: usize, g: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
</span><span class="boring">            if r == 0 {
</span><span class="boring">                return 0;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut r = r + self.size;
</span><span class="boring">            for i in (1..=self.log).rev() {
</span><span class="boring">                self.push((r - 1) &gt;&gt; i);
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            let mut sm = S::e();
</span><span class="boring">            loop {
</span><span class="boring">                r -= 1;
</span><span class="boring">                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
</span><span class="boring">                    r &gt;&gt;= 1;
</span><span class="boring">                }
</span><span class="boring">
</span><span class="boring">                if !g(&amp;S::opr(&amp;self.data[r], &amp;sm)) {
</span><span class="boring">                    while r &lt; self.size {
</span><span class="boring">                        self.push(r);
</span><span class="boring">                        r = (r &lt;&lt; 1) + 1;
</span><span class="boring">                        let tmp = S::opr(&amp;self.data[r], &amp;sm);
</span><span class="boring">                        if g(&amp;tmp) {
</span><span class="boring">                            sm = tmp;
</span><span class="boring">                            r -= 1;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    return r + 1 - self.size;
</span><span class="boring">                }
</span><span class="boring">                sm.opr_rhs(&amp;self.data[r]);
</span><span class="boring">
</span><span class="boring">                if r &amp; ((!r) + 1) == r {
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            0
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-11"><a class="header" href="#code-11">Code</a></h2>
<pre><code class="language-rust noplayground">mod lazyseg {
    use std::ops::RangeBounds;

    fn ceil_pow2(n: usize) -&gt; u32 {
        let mut x = 0;
        while 1 &lt;&lt; x &lt; n {
            x += 1;
        }
        x
    }

    fn range_to_bounds(n: usize, range: impl RangeBounds&lt;usize&gt;) -&gt; (usize, usize) {
        use std::ops::Bound::*;

        let l = match range.start_bound() {
            Included(&amp;v) =&gt; v,
            Excluded(&amp;v) =&gt; v + 1,
            Unbounded =&gt; 0,
        };

        let r = match range.end_bound() {
            Included(&amp;v) =&gt; v + 1,
            Excluded(&amp;v) =&gt; v,
            Unbounded =&gt; n,
        };

        (l, r)
    }

    pub trait LzMonoid: Sized {
        fn e() -&gt; Self;
        fn opr_lhs(&amp;mut self, rhs: &amp;Self);
        fn opr_rhs(&amp;mut self, lhs: &amp;Self);
        fn opr(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
            let mut ret = Self::e();
            ret.opr_rhs(lhs);
            ret.opr_lhs(rhs);
            ret
        }
        fn opr_set(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
            *self = Self::opr(lhs, rhs);
        }
    }

    pub trait LzMap&lt;S&gt;: Sized {
        fn id() -&gt; Self;
        fn map(&amp;self, apply: &amp;mut S);
        fn compos_lhs(&amp;mut self, rhs: &amp;Self);
        fn compos_rhs(&amp;mut self, lhs: &amp;Self);
        fn compos(lhs: &amp;Self, rhs: &amp;Self) -&gt; Self {
            let mut ret = Self::id();
            ret.compos_rhs(lhs);
            ret.compos_lhs(rhs);
            ret
        }
        fn opr_self(&amp;mut self, lhs: &amp;Self, rhs: &amp;Self) {
            *self = Self::compos(lhs, rhs);
        }
    }

    pub struct LazySeg&lt;S, F&gt; {
        n: usize,
        size: usize,
        log: u32,
        data: Vec&lt;S&gt;,
        lazy: Vec&lt;F&gt;,
    }

    impl&lt;S, F&gt; LazySeg&lt;S, F&gt;
    where
        S: LzMonoid,
        F: LzMap&lt;S&gt;,
    {
        fn update(&amp;mut self, k: usize) {
            let val = S::opr(&amp;self.data[k &lt;&lt; 1], &amp;self.data[(k &lt;&lt; 1) + 1]);
            self.data[k] = val;
        }

        fn all_apply(&amp;mut self, k: usize, f: &amp;F) {
            f.map(&amp;mut self.data[k]);
            if k &lt; self.size {
                self.lazy[k].compos_rhs(f);
            }
        }

        fn all_apply_unsafe(size: usize, k: usize, f: usize, data: &amp;mut [S], lazy: &amp;mut [F]) {
            // f &lt; k
            lazy[f].map(&amp;mut data[k]);
            if k &lt; size {
                let (fs, ks) = lazy.split_at_mut(k);
                ks[0].compos_rhs(&amp;fs[f]);
            }
        }

        fn push(&amp;mut self, k: usize) {
            Self::all_apply_unsafe(self.size, k &lt;&lt; 1, k, &amp;mut self.data, &amp;mut self.lazy);
            Self::all_apply_unsafe(self.size, (k &lt;&lt; 1) + 1, k, &amp;mut self.data, &amp;mut self.lazy);
            self.lazy[k] = F::id();
        }

        pub fn new(arr: Vec&lt;S&gt;) -&gt; Self {
            let n = arr.len();
            let log = ceil_pow2(n);
            let size = 1 &lt;&lt; log;
            let stsize = 1 &lt;&lt; (log + 1);

            let mut data = Vec::with_capacity(stsize);
            data.extend((0..size).map(|_| S::e()));
            data.extend(arr.into_iter());
            data.extend((data.len()..stsize).map(|_| S::e()));

            let mut ls = Self {
                n,
                log,
                size,
                data,
                lazy: Vec::from_iter((0..size).map(|_| F::id())),
            };
            for i in (1..size).rev() {
                ls.update(i);
            }
            ls
        }

        pub fn set(&amp;mut self, i: usize, v: S) {
            let i = i + self.size;
            for j in (1..=self.log).rev() {
                self.push(i &gt;&gt; j);
            }
            self.data[i] = v;
            for j in 1..=self.log {
                self.update(i &gt;&gt; j);
            }
        }

        pub fn get(&amp;mut self, i: usize) -&gt; &amp;S {
            let i = i + self.size;
            for j in (1..=self.log).rev() {
                self.push(i &gt;&gt; j);
            }
            &amp;self.data[i]
        }

        pub fn prod(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; S {
            let (l, r) = range_to_bounds(self.size, range);

            if l == 0 &amp;&amp; r == self.size {
                let mut ret = S::e();
                ret.opr_lhs(&amp;self.data[1]);
                return ret;
            } else if l == r {
                return S::e();
            }

            let (mut l, mut r) = (l + self.size, r + self.size);

            for i in (1..=self.log).rev() {
                if ((l &gt;&gt; i) &lt;&lt; i) != l {
                    self.push(l &gt;&gt; i);
                }
                if ((r &gt;&gt; i) &lt;&lt; i) != r {
                    self.push((r - 1) &gt;&gt; i);
                }
            }

            let (mut sml, mut smr) = (S::e(), S::e());
            while l &lt; r {
                if l &amp; 1 == 1 {
                    sml.opr_lhs(&amp;self.data[l]);
                    l += 1;
                }
                if r &amp; 1 == 1 {
                    r -= 1;
                    smr.opr_rhs(&amp;self.data[r]);
                }
                l &gt;&gt;= 1;
                r &gt;&gt;= 1;
            }

            S::opr(&amp;sml, &amp;smr)
        }

        pub fn apply(&amp;mut self, i: usize, f: &amp;F) {
            let i = i + self.size;
            for j in (1..=self.log).rev() {
                self.push(i &gt;&gt; j);
            }
            f.map(&amp;mut self.data[i]);
            for j in 1..=self.log {
                self.update(i &gt;&gt; j);
            }
        }

        pub fn apply_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;, f: &amp;F) {
            let (l, r) = range_to_bounds(self.size, range);

            if l == r {
                return;
            }

            let (mut l, mut r) = (l + self.size, r + self.size);

            for i in (1..=self.log).rev() {
                if ((l &gt;&gt; i) &lt;&lt; i) != l {
                    self.push(l &gt;&gt; i);
                }
                if ((r &gt;&gt; i) &lt;&lt; i) != r {
                    self.push((r - 1) &gt;&gt; i);
                }
            }

            let (l2, r2) = (l, r);
            while l &lt; r {
                if l &amp; 1 == 1 {
                    self.all_apply(l, f);
                    l += 1;
                }
                if r &amp; 1 == 1 {
                    r -= 1;
                    self.all_apply(r, f);
                }
                l &gt;&gt;= 1;
                r &gt;&gt;= 1;
            }
            l = l2;
            r = r2;

            for i in 1..=self.log {
                if ((l &gt;&gt; i) &lt;&lt; i) != l {
                    self.update(l &gt;&gt; i);
                }
                if ((r &gt;&gt; i) &lt;&lt; i) != r {
                    self.update((r - 1) &gt;&gt; i);
                }
            }
        }

        pub fn max_right(&amp;mut self, l: usize, g: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
            if l == self.n {
                return self.n;
            }

            let mut l = l + self.size;
            for i in (1..=self.log).rev() {
                self.push(l &gt;&gt; i);
            }

            let mut sm = S::e();
            loop {
                l &gt;&gt;= l.trailing_zeros();
                if !g(&amp;S::opr(&amp;sm, &amp;self.data[l])) {
                    while l &lt; self.size {
                        self.push(l);
                        l &lt;&lt;= 1;
                        let tmp = S::opr(&amp;sm, &amp;self.data[l]);
                        if g(&amp;tmp) {
                            sm = tmp;
                            l += 1;
                        }
                    }
                    return l - self.size;
                }
                sm.opr_lhs(&amp;self.data[l]);
                l += 1;

                if l &amp; ((!l) + 1) != l {
                    break;
                }
            }

            self.n
        }

        pub fn min_left(&amp;mut self, r: usize, g: impl Fn(&amp;S) -&gt; bool) -&gt; usize {
            if r == 0 {
                return 0;
            }

            let mut r = r + self.size;
            for i in (1..=self.log).rev() {
                self.push((r - 1) &gt;&gt; i);
            }

            let mut sm = S::e();
            loop {
                r -= 1;
                while r &gt; 1 &amp;&amp; r &amp; 1 == 1 {
                    r &gt;&gt;= 1;
                }

                if !g(&amp;S::opr(&amp;self.data[r], &amp;sm)) {
                    while r &lt; self.size {
                        self.push(r);
                        r = (r &lt;&lt; 1) + 1;
                        let tmp = S::opr(&amp;self.data[r], &amp;sm);
                        if g(&amp;tmp) {
                            sm = tmp;
                            r -= 1;
                        }
                    }
                    return r + 1 - self.size;
                }
                sm.opr_rhs(&amp;self.data[r]);

                if r &amp; ((!r) + 1) == r {
                    break;
                }
            }

            0
        }
    }
}</code></pre>
<h2 id="apis-2"><a class="header" href="#apis-2">APIs</a></h2>
<p>Will be done soon. For <code>max_right</code> and <code>min_left</code>, either check the explanation from <a href="datastructure/segtree/./segtree.html#apis">the segment tree documentation</a>, or see the below mathematical definitions (which will be replaced with better explanation).</p>
<h3 id="max_right"><a class="header" href="#max_right"><code>max_right</code></a></h3>
<p>Given an index \(l\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(r\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(r=l\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(r=n\) or \( f \left( A_l \cdot A_{l+1} \cdots A_r \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the maximum \(r\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq l \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(r\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<h3 id="min_left"><a class="header" href="#min_left"><code>min_left</code></a></h3>
<p>Given an index \(r\) and a check function \( f : S \rightarrow bool \), <code>max_right</code> finds an index \(l\) such that satisfies both of the following conditions:</p>
<ul>
<li>\(l=r\) or \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \)</li>
<li>\(l=0\) or \( f \left( A_{l-1} \cdot A_l \cdots A_{r-1} \right) = false \)</li>
</ul>
<p>If \(f\) is monotone, this is the minimum \(l\) that satisfies \( f \left( A_l \cdot A_{l+1} \cdots A_{r-1} \right) = true \).</p>
<p>It should be guaranteed that \(f(e)\) is true, \(0 \leq r \leq n\), and \(f\) has no side effects i.e. calling \(f\) for the same value should always return the same result.</p>
<p>The search for \(l\) is done by binary search, so the time complexity of this function is \( O(\log{n}) \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rope"><a class="header" href="#rope">Rope</a></h1>
<p>Rope acts as if it is a list, but inserting a value at an arbitrary position takes time complexity of amortized \( O(\log{N}) \). However, accessing values also takes amortized \( O(\log{N}) \) time. Building a rope from an iterator takes \( O(N) \).</p>
<p>When accessing to elements, if you use immutable borrow; that is, borrowing through <code>rope.get(idx)</code> or immutably indexing a value like <code>let v = rope[3];</code>, then <strong>splaying doesn't happen</strong> and in the worst case the accessing could take \(O(N)\). Make sure to use <code>get_mut()</code> for performance.</p>
<h2 id="example-13"><a class="header" href="#example-13">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>use rope::Rope;

let mut arr: Rope&lt;i32&gt; = (0..10).collect();
println!(&quot;{:?}&quot;, arr);

let out = arr.take_range(1..5).unwrap();
arr.merge_right(out);
println!(&quot;{:?}&quot;, arr);

for i in 11..100000 {
    let n = arr.len() / 2;
    arr.insert(n, i);
}
println!(&quot;{}&quot;, arr[50000]);

for _ in 0..arr.len() - 10 {
    let n = arr.len() / 2;
    arr.remove(n + 1);
}
println!(&quot;{:?}&quot;, arr);
<span class="boring">}
</span><span class="boring">mod rope {
</span><span class="boring">    use std::{
</span><span class="boring">        cmp::Ordering,
</span><span class="boring">        fmt::{Debug, Display},
</span><span class="boring">        ops::{Bound::*, Index, IndexMut, RangeBounds},
</span><span class="boring">        ptr::{self, NonNull},
</span><span class="boring">        iter::FromIterator,
</span><span class="boring">    };
</span><span class="boring">    pub struct Node&lt;T&gt; {
</span><span class="boring">        data: T,
</span><span class="boring">        subt: usize,
</span><span class="boring">        l: Link&lt;T&gt;,
</span><span class="boring">        r: Link&lt;T&gt;,
</span><span class="boring">        p: Link&lt;T&gt;,
</span><span class="boring">    }
</span><span class="boring">    type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">    impl&lt;T&gt; Node&lt;T&gt; {
</span><span class="boring">        fn new(data: T) -&gt; Self {
</span><span class="boring">            Node {
</span><span class="boring">                data,
</span><span class="boring">                subt: 1,
</span><span class="boring">                l: None,
</span><span class="boring">                r: None,
</span><span class="boring">                p: None,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn left_size(&amp;self) -&gt; usize {
</span><span class="boring">            unsafe { self.l.map_or(0, |l| (*l.as_ptr()).subt) }
</span><span class="boring">        }
</span><span class="boring">        fn right_size(&amp;self) -&gt; usize {
</span><span class="boring">            unsafe { self.r.map_or(0, |r| (*r.as_ptr()).subt) }
</span><span class="boring">        }
</span><span class="boring">        fn upd_subtree(&amp;mut self) {
</span><span class="boring">            self.subt = 1 + self.left_size() + self.right_size();
</span><span class="boring">        }
</span><span class="boring">        // Option&lt;(is_left, parent)&gt;
</span><span class="boring">        unsafe fn is_left_child(x: NonNull&lt;Self&gt;) -&gt; Option&lt;(bool, NonNull&lt;Self&gt;)&gt; {
</span><span class="boring">            if let Some(p) = (*x.as_ptr()).p {
</span><span class="boring">                if (*p.as_ptr())
</span><span class="boring">                    .l
</span><span class="boring">                    .map_or(false, |pl| ptr::eq(x.as_ptr(), pl.as_ptr()))
</span><span class="boring">                {
</span><span class="boring">                    Some((true, p))
</span><span class="boring">                } else {
</span><span class="boring">                    Some((false, p))
</span><span class="boring">                }
</span><span class="boring">            } else {
</span><span class="boring">                None
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct Rope&lt;T&gt; {
</span><span class="boring">        root: Link&lt;T&gt;,
</span><span class="boring">        size: usize,
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Default for Rope&lt;T&gt; {
</span><span class="boring">        fn default() -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                root: None,
</span><span class="boring">                size: 0,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Rope&lt;T&gt; {
</span><span class="boring">        pub fn new() -&gt; Self {
</span><span class="boring">            Self::default()
</span><span class="boring">        }
</span><span class="boring">        pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">            self.size
</span><span class="boring">        }
</span><span class="boring">        pub fn insert(&amp;mut self, idx: usize, data: T) {
</span><span class="boring">            debug_assert!(idx &lt;= self.size);
</span><span class="boring">            unsafe {
</span><span class="boring">                let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));
</span><span class="boring">                if let Some(r) = self.root {
</span><span class="boring">                    let idx = self.kth_ptr(idx);
</span><span class="boring">                    if let Some(idx) = idx {
</span><span class="boring">                        // idx_node is the node which new_node should replace
</span><span class="boring">                        // &quot;Replace&quot; means the new_node should be placed right before the idx_node
</span><span class="boring">                        if let Some(l) = (*idx.as_ptr()).l {
</span><span class="boring">                            // Attach at the right of rightmost node from l
</span><span class="boring">                            let mut p = l;
</span><span class="boring">                            while let Some(r) = (*p.as_ptr()).r {
</span><span class="boring">                                p = r;
</span><span class="boring">                            }
</span><span class="boring">                            // Attach new_node to the right of p
</span><span class="boring">                            (*new_node.as_ptr()).p = Some(p);
</span><span class="boring">                            (*p.as_ptr()).r = Some(new_node);
</span><span class="boring">                        } else {
</span><span class="boring">                            // Attach it right away
</span><span class="boring">                            let p = idx;
</span><span class="boring">                            (*new_node.as_ptr()).p = Some(p);
</span><span class="boring">                            (*p.as_ptr()).l = Some(new_node);
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // idx == self.size
</span><span class="boring">                        // new_node goes to the rightmost of the tree
</span><span class="boring">                        let mut p = r;
</span><span class="boring">                        while let Some(r) = (*p.as_ptr()).r {
</span><span class="boring">                            p = r;
</span><span class="boring">                        }
</span><span class="boring">                        // Attach new_node to the right of p
</span><span class="boring">                        (*new_node.as_ptr()).p = Some(p);
</span><span class="boring">                        (*p.as_ptr()).r = Some(new_node);
</span><span class="boring">                    }
</span><span class="boring">                    let mut c = new_node;
</span><span class="boring">                    while let Some(p) = (*c.as_ptr()).p {
</span><span class="boring">                        c = p;
</span><span class="boring">                        (*c.as_ptr()).upd_subtree();
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    self.root = Some(new_node);
</span><span class="boring">                }
</span><span class="boring">                self.splay(new_node);
</span><span class="boring">                self.size += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        pub fn remove(&amp;mut self, idx: usize) -&gt; Option&lt;T&gt; {
</span><span class="boring">            if idx &gt;= self.size {
</span><span class="boring">                return None;
</span><span class="boring">            }
</span><span class="boring">            let data: T = unsafe {
</span><span class="boring">                if let Some(mut rt) = self.kth_ptr(idx) {
</span><span class="boring">                    rt = self.remove_helper(rt);
</span><span class="boring">                    if let Some(rp) = (*rt.as_ptr()).p {
</span><span class="boring">                        self.splay(rp);
</span><span class="boring">                    }
</span><span class="boring">                    let retr = Box::from_raw(rt.as_ptr());
</span><span class="boring">                    retr.data
</span><span class="boring">                } else {
</span><span class="boring">                    unreachable!()
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">            self.size -= 1;
</span><span class="boring">            Some(data)
</span><span class="boring">        }
</span><span class="boring">        pub fn push_front(&amp;mut self, data: T) {
</span><span class="boring">            self.insert(0, data);
</span><span class="boring">        }
</span><span class="boring">        pub fn push_back(&amp;mut self, data: T) {
</span><span class="boring">            self.insert(self.size, data);
</span><span class="boring">        }
</span><span class="boring">        pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">            self.remove(0)
</span><span class="boring">        }
</span><span class="boring">        pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">            self.remove(self.size - 1)
</span><span class="boring">        }
</span><span class="boring">        /// Splits out the rope, leaving self[..at] and returning self[at..].
</span><span class="boring">        /// If the index is invalid, it returns None.
</span><span class="boring">        pub fn take_right(&amp;mut self, right_start: usize) -&gt; Option&lt;Self&gt; {
</span><span class="boring">            let rhs = unsafe {
</span><span class="boring">                if right_start == 0 {
</span><span class="boring">                    let rhs = Self {
</span><span class="boring">                        root: self.root,
</span><span class="boring">                        size: self.size,
</span><span class="boring">                    };
</span><span class="boring">                    self.root = None;
</span><span class="boring">                    self.size = 0;
</span><span class="boring">                    rhs
</span><span class="boring">                } else {
</span><span class="boring">                    let root = self.kth_ptr(right_start - 1)?;
</span><span class="boring">                    self.splay(root);
</span><span class="boring">                    if let Some(r) = (*root.as_ptr()).r {
</span><span class="boring">                        (*root.as_ptr()).r = None;
</span><span class="boring">                        (*r.as_ptr()).p = None;
</span><span class="boring">                        (*root.as_ptr()).upd_subtree();
</span><span class="boring">                        self.size = (*root.as_ptr()).subt;
</span><span class="boring">                        Self {
</span><span class="boring">                            root: Some(r),
</span><span class="boring">                            size: (*r.as_ptr()).subt,
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        Self {
</span><span class="boring">                            root: None,
</span><span class="boring">                            size: 0,
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">            Some(rhs)
</span><span class="boring">        }
</span><span class="boring">        /// Splits out the rope and returns self[..at] and self[at..].
</span><span class="boring">        /// If the index is invalid, it returns None.
</span><span class="boring">        pub fn split_at(mut self, at: usize) -&gt; Option&lt;(Self, Self)&gt; {
</span><span class="boring">            let rhs = self.take_right(at)?;
</span><span class="boring">            Some((self, rhs))
</span><span class="boring">        }
</span><span class="boring">        /// Takes out the range from the rope.
</span><span class="boring">        /// Returns None if the index is invalid.
</span><span class="boring">        pub fn take_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; Option&lt;Self&gt; {
</span><span class="boring">            let l = match range.start_bound() {
</span><span class="boring">                Included(&amp;l) =&gt; l,
</span><span class="boring">                Excluded(&amp;l) =&gt; l + 1,
</span><span class="boring">                Unbounded =&gt; 0,
</span><span class="boring">            };
</span><span class="boring">            let r = match range.end_bound() {
</span><span class="boring">                Included(&amp;r) =&gt; r + 1,
</span><span class="boring">                Excluded(&amp;r) =&gt; r,
</span><span class="boring">                Unbounded =&gt; self.size,
</span><span class="boring">            };
</span><span class="boring">            if l &gt; r || l &gt; self.size || r &gt; self.size {
</span><span class="boring">                return None;
</span><span class="boring">            }
</span><span class="boring">            // Now the operations below never ends early
</span><span class="boring">            let c = self.take_right(r)?;
</span><span class="boring">            let b = self.take_right(l)?;
</span><span class="boring">            self.merge_right(c);
</span><span class="boring">            Some(b)
</span><span class="boring">        }
</span><span class="boring">        pub fn merge_right(&amp;mut self, mut rhs: Self) {
</span><span class="boring">            if self.len() == 0 {
</span><span class="boring">                self.root = rhs.root;
</span><span class="boring">                self.size = rhs.size;
</span><span class="boring">            } else {
</span><span class="boring">                unsafe {
</span><span class="boring">                    let rmost = self.kth_ptr(self.size - 1).unwrap();
</span><span class="boring">                    self.splay(rmost);
</span><span class="boring">                    (*rmost.as_ptr()).r = rhs.root;
</span><span class="boring">                    if let Some(rhs_root) = rhs.root {
</span><span class="boring">                        (*rhs_root.as_ptr()).p = Some(rmost);
</span><span class="boring">                    }
</span><span class="boring">                    (*rmost.as_ptr()).upd_subtree();
</span><span class="boring">                    self.size = (*rmost.as_ptr()).subt;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            rhs.root = None;
</span><span class="boring">            rhs.size = 0;
</span><span class="boring">        }
</span><span class="boring">        pub fn merge_left(&amp;mut self, mut lhs: Self) {
</span><span class="boring">            if self.len() == 0 {
</span><span class="boring">                self.root = lhs.root;
</span><span class="boring">                self.size = lhs.size;
</span><span class="boring">            } else {
</span><span class="boring">                unsafe {
</span><span class="boring">                    let lmost = self.kth_ptr(0).unwrap();
</span><span class="boring">                    self.splay(lmost);
</span><span class="boring">                    (*lmost.as_ptr()).l = lhs.root;
</span><span class="boring">                    if let Some(lhs_root) = lhs.root {
</span><span class="boring">                        (*lhs_root.as_ptr()).p = Some(lmost);
</span><span class="boring">                    }
</span><span class="boring">                    (*lmost.as_ptr()).upd_subtree();
</span><span class="boring">                    self.size = (*lmost.as_ptr()).subt;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            lhs.root = None;
</span><span class="boring">            lhs.size = 0;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T: Debug&gt; Debug for Rope&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">            write!(f, &quot;[&quot;)?;
</span><span class="boring">            let mut cnt: usize = 0;
</span><span class="boring">            unsafe {
</span><span class="boring">                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
</span><span class="boring">                let mut curr = self.root;
</span><span class="boring">                loop {
</span><span class="boring">                    while let Some(x) = curr {
</span><span class="boring">                        stack.push(x.as_ptr());
</span><span class="boring">                        curr = (*x.as_ptr()).l;
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(x) = stack.pop() {
</span><span class="boring">                        if cnt == 0 {
</span><span class="boring">                            write!(f, &quot;{:?}&quot;, (*x).data)?;
</span><span class="boring">                        } else {
</span><span class="boring">                            write!(f, &quot;, {:?}&quot;, (*x).data)?;
</span><span class="boring">                        }
</span><span class="boring">                        cnt += 1;
</span><span class="boring">                        curr = (*x).r;
</span><span class="boring">                    } else {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            write!(f, &quot;]&quot;)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T: Display&gt; Display for Rope&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">            unsafe {
</span><span class="boring">                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
</span><span class="boring">                let mut curr = self.root;
</span><span class="boring">                loop {
</span><span class="boring">                    while let Some(x) = curr {
</span><span class="boring">                        stack.push(x.as_ptr());
</span><span class="boring">                        curr = (*x.as_ptr()).l;
</span><span class="boring">                    }
</span><span class="boring">                    if let Some(x) = stack.pop() {
</span><span class="boring">                        write!(f, &quot;{}&quot;, (*x).data)?;
</span><span class="boring">                        curr = (*x).r;
</span><span class="boring">                    } else {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Drop for Rope&lt;T&gt; {
</span><span class="boring">        fn drop(&amp;mut self) {
</span><span class="boring">            if let Some(root) = self.root {
</span><span class="boring">                unsafe {
</span><span class="boring">                    let mut st: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
</span><span class="boring">                    st.push(root.as_ptr());
</span><span class="boring">                    while let Some(t) = st.pop() {
</span><span class="boring">                        let v = Box::from_raw(t);
</span><span class="boring">                        if let Some(l) = v.l {
</span><span class="boring">                            st.push(l.as_ptr());
</span><span class="boring">                        }
</span><span class="boring">                        if let Some(r) = v.r {
</span><span class="boring">                            st.push(r.as_ptr());
</span><span class="boring">                        }
</span><span class="boring">                        // retrieve.drop()
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; Index&lt;usize&gt; for Rope&lt;T&gt; {
</span><span class="boring">        type Output = T;
</span><span class="boring">        fn index(&amp;self, idx: usize) -&gt; &amp;Self::Output {
</span><span class="boring">            unsafe {
</span><span class="boring">                let p = self.kth_ptr(idx);
</span><span class="boring">                &amp;(*p.unwrap().as_ptr()).data
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; IndexMut&lt;usize&gt; for Rope&lt;T&gt; {
</span><span class="boring">        fn index_mut(&amp;mut self, idx: usize) -&gt; &amp;mut Self::Output {
</span><span class="boring">            unsafe {
</span><span class="boring">                let p = self.kth_ptr(idx);
</span><span class="boring">                &amp;mut (*p.unwrap().as_ptr()).data
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;T&gt; FromIterator&lt;T&gt; for Rope&lt;T&gt; {
</span><span class="boring">        fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {
</span><span class="boring">            let mut arr = Self::new();
</span><span class="boring">            for v in iter {
</span><span class="boring">                unsafe { arr.push_ontop_root(v) };
</span><span class="boring">            }
</span><span class="boring">            arr
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    //------------------------
</span><span class="boring">    // Helper implementations
</span><span class="boring">    //------------------------
</span><span class="boring">    impl&lt;T&gt; Rope&lt;T&gt; {
</span><span class="boring">        /// Adds data as a new root of a rope, and putting the original root
</span><span class="boring">        /// as a left child of the root.
</span><span class="boring">        unsafe fn push_ontop_root(&amp;mut self, data: T) {
</span><span class="boring">            let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));
</span><span class="boring">            if let Some(root) = self.root {
</span><span class="boring">                (*root.as_ptr()).p = Some(new_node);
</span><span class="boring">                (*new_node.as_ptr()).l = Some(root);
</span><span class="boring">            }
</span><span class="boring">            self.root = Some(new_node);
</span><span class="boring">            (*new_node.as_ptr()).upd_subtree();
</span><span class="boring">            self.size += 1;
</span><span class="boring">        }
</span><span class="boring">        /// Returns false if x has no parent, and do nothing
</span><span class="boring">        /// Returns true if x has a parent, after performing rotation
</span><span class="boring">        unsafe fn rotate(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; bool {
</span><span class="boring">            if let Some((is_x_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                // Check if p is root
</span><span class="boring">                if let Some(root) = self.root {
</span><span class="boring">                    if ptr::eq(root.as_ptr(), p.as_ptr()) {
</span><span class="boring">                        self.root = Some(x);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                // Connect x to xpp. If pp is None, do nothing.
</span><span class="boring">                (*x.as_ptr()).p = (*p.as_ptr()).p;
</span><span class="boring">                if let Some((is_p_left, pp)) = Node::is_left_child(p) {
</span><span class="boring">                    if is_p_left {
</span><span class="boring">                        (*pp.as_ptr()).l = Some(x);
</span><span class="boring">                    } else {
</span><span class="boring">                        (*pp.as_ptr()).r = Some(x);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                if is_x_left {
</span><span class="boring">                    let b = (*x.as_ptr()).r;
</span><span class="boring">                    (*x.as_ptr()).r = Some(p);
</span><span class="boring">                    (*p.as_ptr()).p = Some(x);
</span><span class="boring">                    (*p.as_ptr()).l = b;
</span><span class="boring">                    if let Some(b) = b {
</span><span class="boring">                        (*b.as_ptr()).p = Some(p);
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    let b = (*x.as_ptr()).l;
</span><span class="boring">                    (*x.as_ptr()).l = Some(p);
</span><span class="boring">                    (*p.as_ptr()).p = Some(x);
</span><span class="boring">                    (*p.as_ptr()).r = b;
</span><span class="boring">                    if let Some(b) = b {
</span><span class="boring">                        (*b.as_ptr()).p = Some(p);
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                (*p.as_ptr()).upd_subtree();
</span><span class="boring">                (*x.as_ptr()).upd_subtree();
</span><span class="boring">                true
</span><span class="boring">            } else {
</span><span class="boring">                false
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn splay(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) {
</span><span class="boring">            unsafe {
</span><span class="boring">                while let Some(root) = self.root {
</span><span class="boring">                    if ptr::eq(x.as_ptr(), root.as_ptr()) {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), p.as_ptr()) {
</span><span class="boring">                            // If p is root, rotate x once
</span><span class="boring">                            self.rotate(x);
</span><span class="boring">                        } else {
</span><span class="boring">                            // Panics if pp doesn't exist, which happens only when p is root
</span><span class="boring">                            let (is_p_left, _pp) = Node::is_left_child(p).unwrap();
</span><span class="boring">                            if is_x_left == is_p_left {
</span><span class="boring">                                self.rotate(p);
</span><span class="boring">                                self.rotate(x);
</span><span class="boring">                            } else {
</span><span class="boring">                                self.rotate(x);
</span><span class="boring">                                self.rotate(x);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // x has no parent, which should logically never happen
</span><span class="boring">                        unreachable!()
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        unsafe fn kth_ptr(&amp;self, idx: usize) -&gt; Link&lt;T&gt; {
</span><span class="boring">            if self.size &lt;= idx {
</span><span class="boring">                return None;
</span><span class="boring">            }
</span><span class="boring">            if let Some(r) = self.root {
</span><span class="boring">                let mut rem = idx;
</span><span class="boring">                let mut p = r;
</span><span class="boring">                loop {
</span><span class="boring">                    let lsize = (*p.as_ptr()).left_size();
</span><span class="boring">                    match rem.cmp(&amp;lsize) {
</span><span class="boring">                        Ordering::Less =&gt; {
</span><span class="boring">                            p = (*p.as_ptr()).l?;
</span><span class="boring">                        }
</span><span class="boring">                        Ordering::Equal =&gt; {
</span><span class="boring">                            break;
</span><span class="boring">                        }
</span><span class="boring">                        Ordering::Greater =&gt; {
</span><span class="boring">                            rem -= lsize + 1;
</span><span class="boring">                            p = (*p.as_ptr()).r?;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">                Some(p)
</span><span class="boring">            } else {
</span><span class="boring">                None
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        unsafe fn remove_helper(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; NonNull&lt;Node&lt;T&gt;&gt; {
</span><span class="boring">            // Set remove_target to the actual node to delete
</span><span class="boring">            match ((*x.as_ptr()).l, ((*x.as_ptr()).r)) {
</span><span class="boring">                (None, None) =&gt; {
</span><span class="boring">                    // Reset root if the node itself is root
</span><span class="boring">                    if let Some(root) = self.root {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
</span><span class="boring">                            self.root = None;
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    // Detatch itself from parent
</span><span class="boring">                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if is_x_left {
</span><span class="boring">                            (*p.as_ptr()).l = None;
</span><span class="boring">                        } else {
</span><span class="boring">                            (*p.as_ptr()).r = None;
</span><span class="boring">                        }
</span><span class="boring">                        // Update subtree size
</span><span class="boring">                        let mut p = p;
</span><span class="boring">                        (*p.as_ptr()).upd_subtree();
</span><span class="boring">                        while let Some(pp) = (*p.as_ptr()).p {
</span><span class="boring">                            p = pp;
</span><span class="boring">                            (*p.as_ptr()).upd_subtree();
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    x
</span><span class="boring">                }
</span><span class="boring">                (Some(l), None) =&gt; {
</span><span class="boring">                    // Reset root if the node itself is a root
</span><span class="boring">                    if let Some(root) = self.root {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
</span><span class="boring">                            self.root = Some(l);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    (*l.as_ptr()).p = (*x.as_ptr()).p;
</span><span class="boring">                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if is_rt_left {
</span><span class="boring">                            (*p.as_ptr()).l = Some(l);
</span><span class="boring">                        } else {
</span><span class="boring">                            (*p.as_ptr()).r = Some(l);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    let mut p = l;
</span><span class="boring">                    while let Some(pp) = (*p.as_ptr()).p {
</span><span class="boring">                        p = pp;
</span><span class="boring">                        (*p.as_ptr()).upd_subtree();
</span><span class="boring">                    }
</span><span class="boring">                    x
</span><span class="boring">                }
</span><span class="boring">                (None, Some(r)) =&gt; {
</span><span class="boring">                    // Reset root if the node itself is a root
</span><span class="boring">                    if let Some(root) = self.root {
</span><span class="boring">                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
</span><span class="boring">                            self.root = Some(r);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    (*r.as_ptr()).p = (*x.as_ptr()).p;
</span><span class="boring">                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
</span><span class="boring">                        if is_rt_left {
</span><span class="boring">                            (*p.as_ptr()).l = Some(r);
</span><span class="boring">                        } else {
</span><span class="boring">                            (*p.as_ptr()).r = Some(r);
</span><span class="boring">                        }
</span><span class="boring">                    }
</span><span class="boring">                    let mut p = r;
</span><span class="boring">                    while let Some(pp) = (*p.as_ptr()).p {
</span><span class="boring">                        p = pp;
</span><span class="boring">                        (*p.as_ptr()).upd_subtree();
</span><span class="boring">                    }
</span><span class="boring">                    x
</span><span class="boring">                }
</span><span class="boring">                (Some(l), Some(_)) =&gt; {
</span><span class="boring">                    let mut sw = l;
</span><span class="boring">                    while let Some(sr) = (*sw.as_ptr()).r {
</span><span class="boring">                        sw = sr;
</span><span class="boring">                    }
</span><span class="boring">                    std::mem::swap(&amp;mut (*x.as_ptr()).data, &amp;mut (*sw.as_ptr()).data);
</span><span class="boring">                    sw = self.remove_helper(sw);
</span><span class="boring">                    sw
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    //-----------
</span><span class="boring">    // Iterators
</span><span class="boring">    //-----------
</span><span class="boring">    impl&lt;T&gt; Rope&lt;T&gt; {
</span><span class="boring">        pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
</span><span class="boring">            Iter::new(self)
</span><span class="boring">        }
</span><span class="boring">        pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
</span><span class="boring">            IterMut::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct Iter&lt;'a, T&gt; {
</span><span class="boring">        rope: &amp;'a Rope&lt;T&gt;,
</span><span class="boring">        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
</span><span class="boring">        curr: Link&lt;T&gt;,
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
</span><span class="boring">        fn new(rope: &amp;'a Rope&lt;T&gt;) -&gt; Self {
</span><span class="boring">            let root = rope.root;
</span><span class="boring">            Self {
</span><span class="boring">                rope,
</span><span class="boring">                stack: Vec::new(),
</span><span class="boring">                curr: root,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; IntoIterator for &amp;'a Rope&lt;T&gt; {
</span><span class="boring">        type Item = &amp;'a T;
</span><span class="boring">        type IntoIter = Iter&lt;'a, T&gt;;
</span><span class="boring">        fn into_iter(self) -&gt; Self::IntoIter {
</span><span class="boring">            Self::IntoIter::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
</span><span class="boring">        type Item = &amp;'a T;
</span><span class="boring">        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">            unsafe {
</span><span class="boring">                while let Some(x) = self.curr {
</span><span class="boring">                    self.stack.push(x);
</span><span class="boring">                    self.curr = (*x.as_ptr()).l;
</span><span class="boring">                }
</span><span class="boring">                if let Some(x) = self.stack.pop() {
</span><span class="boring">                    self.curr = (*x.as_ptr()).r;
</span><span class="boring">                    Some(&amp;x.as_ref().data)
</span><span class="boring">                } else {
</span><span class="boring">                    None
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
</span><span class="boring">            (self.rope.len(), Some(self.rope.len()))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct IterMut&lt;'a, T&gt; {
</span><span class="boring">        rope: &amp;'a mut Rope&lt;T&gt;,
</span><span class="boring">        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
</span><span class="boring">        curr: Link&lt;T&gt;,
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; IterMut&lt;'a, T&gt; {
</span><span class="boring">        fn new(rope: &amp;'a mut Rope&lt;T&gt;) -&gt; Self {
</span><span class="boring">            let root = rope.root;
</span><span class="boring">            Self {
</span><span class="boring">                rope,
</span><span class="boring">                stack: Vec::new(),
</span><span class="boring">                curr: root,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Rope&lt;T&gt; {
</span><span class="boring">        type Item = &amp;'a mut T;
</span><span class="boring">        type IntoIter = IterMut&lt;'a, T&gt;;
</span><span class="boring">        fn into_iter(self) -&gt; Self::IntoIter {
</span><span class="boring">            Self::IntoIter::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
</span><span class="boring">        type Item = &amp;'a mut T;
</span><span class="boring">        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">            unsafe {
</span><span class="boring">                while let Some(x) = self.curr {
</span><span class="boring">                    self.stack.push(x);
</span><span class="boring">                    self.curr = (*x.as_ptr()).l;
</span><span class="boring">                }
</span><span class="boring">                if let Some(mut x) = self.stack.pop() {
</span><span class="boring">                    self.curr = (*x.as_ptr()).r;
</span><span class="boring">                    Some(&amp;mut x.as_mut().data)
</span><span class="boring">                } else {
</span><span class="boring">                    None
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
</span><span class="boring">            (self.rope.len(), Some(self.rope.len()))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-12"><a class="header" href="#code-12">Code</a></h2>
<pre><code class="language-rust noplayground">mod rope {
    use std::{
        cmp::Ordering,
        fmt::{Debug, Display},
        ops::{Bound::*, Index, IndexMut, RangeBounds},
        ptr::{self, NonNull},
    };

    pub struct Rope&lt;T&gt; {
        root: Link&lt;T&gt;,
        size: usize,
    }

    impl&lt;T&gt; Default for Rope&lt;T&gt; {
        fn default() -&gt; Self {
            Self {
                root: None,
                size: 0,
            }
        }
    }

    impl&lt;T&gt; Rope&lt;T&gt; {
        pub fn new() -&gt; Self {
            Self::default()
        }

        pub fn len(&amp;self) -&gt; usize {
            self.size
        }

        pub fn clear(&amp;mut self) {
            let drop_tree = Self {
                root: self.root,
                size: self.size,
            };
            drop(drop_tree);
            self.root = None;
            self.size = 0;
        }

        pub fn insert(&amp;mut self, idx: usize, data: T) {
            debug_assert!(idx &lt;= self.size);
            unsafe {
                let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));

                if let Some(r) = self.root {
                    let idx = self.kth_ptr(idx);
                    if let Some(idx) = idx {
                        // idx_node is the node which new_node should replace
                        // &quot;Replace&quot; means the new_node should be placed right before the idx_node
                        if let Some(l) = (*idx.as_ptr()).l {
                            // Attach at the right of rightmost node from l
                            let mut p = l;
                            while let Some(r) = (*p.as_ptr()).r {
                                p = r;
                            }
                            // Attach new_node to the right of p
                            (*new_node.as_ptr()).p = Some(p);
                            (*p.as_ptr()).r = Some(new_node);
                        } else {
                            // Attach it right away
                            let p = idx;
                            (*new_node.as_ptr()).p = Some(p);
                            (*p.as_ptr()).l = Some(new_node);
                        }
                    } else {
                        // idx == self.size
                        // new_node goes to the rightmost of the tree
                        let mut p = r;
                        while let Some(r) = (*p.as_ptr()).r {
                            p = r;
                        }
                        // Attach new_node to the right of p
                        (*new_node.as_ptr()).p = Some(p);
                        (*p.as_ptr()).r = Some(new_node);
                    }

                    let mut c = new_node;
                    while let Some(p) = (*c.as_ptr()).p {
                        c = p;
                        (*c.as_ptr()).upd_subtree();
                    }
                } else {
                    self.root = Some(new_node);
                }

                self.splay(new_node);
                self.size += 1;
            }
        }

        pub fn remove(&amp;mut self, idx: usize) -&gt; Option&lt;T&gt; {
            if idx &gt;= self.size {
                return None;
            }

            let data: T = unsafe {
                if let Some(mut rt) = self.kth_ptr(idx) {
                    rt = self.remove_helper(rt);
                    if let Some(rp) = (*rt.as_ptr()).p {
                        self.splay(rp);
                    }
                    let retr = Box::from_raw(rt.as_ptr());
                    retr.data
                } else {
                    unreachable!()
                }
            };

            self.size -= 1;
            Some(data)
        }

        pub fn push_front(&amp;mut self, data: T) {
            self.insert(0, data);
        }

        pub fn push_back(&amp;mut self, data: T) {
            self.insert(self.size, data);
        }

        pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.remove(0)
        }

        pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.remove(self.size - 1)
        }

        /// Splits out the rope, leaving self[..at] and returning self[at..].
        /// If the index is invalid, it returns None.
        pub fn take_right(&amp;mut self, right_start: usize) -&gt; Option&lt;Self&gt; {
            let rhs = unsafe {
                if right_start == 0 {
                    let rhs = Self {
                        root: self.root,
                        size: self.size,
                    };
                    self.root = None;
                    self.size = 0;
                    rhs
                } else {
                    let root = self.kth_ptr(right_start - 1)?;
                    self.splay(root);
                    if let Some(r) = (*root.as_ptr()).r {
                        (*root.as_ptr()).r = None;
                        (*r.as_ptr()).p = None;
                        (*root.as_ptr()).upd_subtree();
                        self.size = (*root.as_ptr()).subt;
                        Self {
                            root: Some(r),
                            size: (*r.as_ptr()).subt,
                        }
                    } else {
                        Self {
                            root: None,
                            size: 0,
                        }
                    }
                }
            };
            Some(rhs)
        }

        /// Splits out the rope and returns self[..at] and self[at..].
        /// If the index is invalid, it returns None.
        pub fn split_at(mut self, at: usize) -&gt; Option&lt;(Self, Self)&gt; {
            let rhs = self.take_right(at)?;
            Some((self, rhs))
        }

        /// Takes out the range from the rope.
        /// Returns None if the index is invalid.
        pub fn take_range(&amp;mut self, range: impl RangeBounds&lt;usize&gt;) -&gt; Option&lt;Self&gt; {
            let l = match range.start_bound() {
                Included(&amp;l) =&gt; l,
                Excluded(&amp;l) =&gt; l + 1,
                Unbounded =&gt; 0,
            };
            let r = match range.end_bound() {
                Included(&amp;r) =&gt; r + 1,
                Excluded(&amp;r) =&gt; r,
                Unbounded =&gt; self.size,
            };

            if l &gt; r || l &gt; self.size || r &gt; self.size {
                return None;
            }
            // Now the operations below never ends early
            let c = self.take_right(r)?;
            let b = self.take_right(l)?;
            self.merge_right(c);
            Some(b)
        }

        pub fn merge_right(&amp;mut self, mut rhs: Self) {
            if self.len() == 0 {
                self.root = rhs.root;
                self.size = rhs.size;
            } else {
                unsafe {
                    let rmost = self.kth_ptr(self.size - 1).unwrap();
                    self.splay(rmost);
                    (*rmost.as_ptr()).r = rhs.root;
                    if let Some(rhs_root) = rhs.root {
                        (*rhs_root.as_ptr()).p = Some(rmost);
                    }
                    (*rmost.as_ptr()).upd_subtree();
                    self.size = (*rmost.as_ptr()).subt;
                }
            }
            rhs.root = None;
            rhs.size = 0;
        }

        pub fn merge_left(&amp;mut self, mut lhs: Self) {
            if self.len() == 0 {
                self.root = lhs.root;
                self.size = lhs.size;
            } else {
                unsafe {
                    let lmost = self.kth_ptr(0).unwrap();
                    self.splay(lmost);
                    (*lmost.as_ptr()).l = lhs.root;
                    if let Some(lhs_root) = lhs.root {
                        (*lhs_root.as_ptr()).p = Some(lmost);
                    }
                    (*lmost.as_ptr()).upd_subtree();
                    self.size = (*lmost.as_ptr()).subt;
                }
            }
            lhs.root = None;
            lhs.size = 0;
        }

        /// Inserts rope into self at self.
        /// After the operation, rope[0] becomes self[at].
        /// Returns false if the specified index is invalid, true otherwise.
        pub fn insert_rope(&amp;mut self, rope: Self, at: usize) -&gt; bool {
            let rhs = self.take_right(at);
            if let Some(rhs) = rhs {
                self.merge_right(rope);
                self.merge_right(rhs);
                true
            } else {
                false
            }
        }
    }

    impl&lt;T: Clone&gt; Clone for Rope&lt;T&gt; {
        fn clone(&amp;self) -&gt; Self {
            self.iter().cloned().collect()
        }
    }

    impl&lt;T: Debug&gt; Debug for Rope&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;[&quot;)?;
            let mut cnt: usize = 0;
            unsafe {
                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
                let mut curr = self.root;
                loop {
                    while let Some(x) = curr {
                        stack.push(x.as_ptr());
                        curr = (*x.as_ptr()).l;
                    }
                    if let Some(x) = stack.pop() {
                        if cnt == 0 {
                            write!(f, &quot;{:?}&quot;, (*x).data)?;
                        } else {
                            write!(f, &quot;, {:?}&quot;, (*x).data)?;
                        }
                        cnt += 1;
                        curr = (*x).r;
                    } else {
                        break;
                    }
                }
            }
            write!(f, &quot;]&quot;)
        }
    }

    impl&lt;T: Display&gt; Display for Rope&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            unsafe {
                let mut stack: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
                let mut curr = self.root;
                loop {
                    while let Some(x) = curr {
                        stack.push(x.as_ptr());
                        curr = (*x.as_ptr()).l;
                    }
                    if let Some(x) = stack.pop() {
                        write!(f, &quot;{}&quot;, (*x).data)?;
                        curr = (*x).r;
                    } else {
                        break;
                    }
                }
            }
            Ok(())
        }
    }

    impl&lt;T&gt; Drop for Rope&lt;T&gt; {
        fn drop(&amp;mut self) {
            if let Some(root) = self.root {
                unsafe {
                    let mut st: Vec&lt;*mut Node&lt;T&gt;&gt; = Vec::new();
                    st.push(root.as_ptr());
                    while let Some(t) = st.pop() {
                        let v = Box::from_raw(t);
                        if let Some(l) = v.l {
                            st.push(l.as_ptr());
                        }
                        if let Some(r) = v.r {
                            st.push(r.as_ptr());
                        }
                        drop(v);
                    }
                }
            }
        }
    }

    impl&lt;T&gt; Index&lt;usize&gt; for Rope&lt;T&gt; {
        type Output = T;
        fn index(&amp;self, idx: usize) -&gt; &amp;Self::Output {
            unsafe {
                let p = self.kth_ptr(idx).unwrap();
                &amp;(*p.as_ptr()).data
            }
        }
    }

    impl&lt;T&gt; IndexMut&lt;usize&gt; for Rope&lt;T&gt; {
        fn index_mut(&amp;mut self, idx: usize) -&gt; &amp;mut Self::Output {
            unsafe {
                let p = self.kth_ptr(idx).unwrap();
                self.splay(p);
                &amp;mut (*p.as_ptr()).data
            }
        }
    }

    impl&lt;T&gt; FromIterator&lt;T&gt; for Rope&lt;T&gt; {
        fn from_iter&lt;I: IntoIterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self {
            let mut arr = Self::new();
            for v in iter {
                unsafe { arr.push_ontop_root(v) };
            }
            arr
        }
    }

    impl&lt;T&gt; Rope&lt;T&gt; {
        pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
            Iter::new(self)
        }

        pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
            IterMut::new(self)
        }
    }

    pub struct Iter&lt;'a, T&gt; {
        rope: &amp;'a Rope&lt;T&gt;,
        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
        curr: Link&lt;T&gt;,
    }

    impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
        fn new(rope: &amp;'a Rope&lt;T&gt;) -&gt; Self {
            let root = rope.root;
            Self {
                rope,
                stack: Vec::new(),
                curr: root,
            }
        }
    }

    impl&lt;'a, T&gt; IntoIterator for &amp;'a Rope&lt;T&gt; {
        type Item = &amp;'a T;
        type IntoIter = Iter&lt;'a, T&gt;;
        fn into_iter(self) -&gt; Self::IntoIter {
            Self::IntoIter::new(self)
        }
    }

    impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
        type Item = &amp;'a T;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            unsafe {
                while let Some(x) = self.curr {
                    self.stack.push(x);
                    self.curr = (*x.as_ptr()).l;
                }
                if let Some(x) = self.stack.pop() {
                    self.curr = (*x.as_ptr()).r;
                    Some(&amp;x.as_ref().data)
                } else {
                    None
                }
            }
        }

        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
            (self.rope.len(), Some(self.rope.len()))
        }
    }

    pub struct IterMut&lt;'a, T&gt; {
        rope: &amp;'a mut Rope&lt;T&gt;,
        stack: Vec&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
        curr: Link&lt;T&gt;,
    }

    impl&lt;'a, T&gt; IterMut&lt;'a, T&gt; {
        fn new(rope: &amp;'a mut Rope&lt;T&gt;) -&gt; Self {
            let root = rope.root;
            Self {
                rope,
                stack: Vec::new(),
                curr: root,
            }
        }
    }

    impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Rope&lt;T&gt; {
        type Item = &amp;'a mut T;
        type IntoIter = IterMut&lt;'a, T&gt;;
        fn into_iter(self) -&gt; Self::IntoIter {
            Self::IntoIter::new(self)
        }
    }

    impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
        type Item = &amp;'a mut T;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            unsafe {
                while let Some(x) = self.curr {
                    self.stack.push(x);
                    self.curr = (*x.as_ptr()).l;
                }
                if let Some(mut x) = self.stack.pop() {
                    self.curr = (*x.as_ptr()).r;
                    Some(&amp;mut x.as_mut().data)
                } else {
                    None
                }
            }
        }

        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
            (self.rope.len(), Some(self.rope.len()))
        }
    }

    //------------------------
    // Helper implementations
    //------------------------

    struct Node&lt;T&gt; {
        data: T,
        subt: usize,
        l: Link&lt;T&gt;,
        r: Link&lt;T&gt;,
        p: Link&lt;T&gt;,
    }

    type Link&lt;T&gt; = Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;;

    impl&lt;T&gt; Node&lt;T&gt; {
        fn new(data: T) -&gt; Self {
            Node {
                data,
                subt: 1,
                l: None,
                r: None,
                p: None,
            }
        }
        fn left_size(&amp;self) -&gt; usize {
            unsafe { self.l.map_or(0, |l| (*l.as_ptr()).subt) }
        }
        fn right_size(&amp;self) -&gt; usize {
            unsafe { self.r.map_or(0, |r| (*r.as_ptr()).subt) }
        }
        fn upd_subtree(&amp;mut self) {
            self.subt = 1 + self.left_size() + self.right_size();
        }

        // Option&lt;(is_left, parent)&gt;
        unsafe fn is_left_child(x: NonNull&lt;Self&gt;) -&gt; Option&lt;(bool, NonNull&lt;Self&gt;)&gt; {
            if let Some(p) = (*x.as_ptr()).p {
                if (*p.as_ptr())
                    .l
                    .map_or(false, |pl| ptr::eq(x.as_ptr(), pl.as_ptr()))
                {
                    Some((true, p))
                } else {
                    Some((false, p))
                }
            } else {
                None
            }
        }
    }

    impl&lt;T&gt; Rope&lt;T&gt; {
        /// Adds data as a new root of a rope, and putting the original root
        /// as a left child of the root.
        unsafe fn push_ontop_root(&amp;mut self, data: T) {
            let new_node = NonNull::new_unchecked(Box::into_raw(Box::new(Node::new(data))));
            if let Some(root) = self.root {
                (*root.as_ptr()).p = Some(new_node);
                (*new_node.as_ptr()).l = Some(root);
            }
            self.root = Some(new_node);
            (*new_node.as_ptr()).upd_subtree();
            self.size += 1;
        }

        /// Returns false if x has no parent, and do nothing
        /// Returns true if x has a parent, after performing rotation
        unsafe fn rotate(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; bool {
            if let Some((is_x_left, p)) = Node::is_left_child(x) {
                // Check if p is root
                if let Some(root) = self.root {
                    if ptr::eq(root.as_ptr(), p.as_ptr()) {
                        self.root = Some(x);
                    }
                }

                // Connect x to xpp. If pp is None, do nothing.
                (*x.as_ptr()).p = (*p.as_ptr()).p;
                if let Some((is_p_left, pp)) = Node::is_left_child(p) {
                    if is_p_left {
                        (*pp.as_ptr()).l = Some(x);
                    } else {
                        (*pp.as_ptr()).r = Some(x);
                    }
                }

                if is_x_left {
                    let b = (*x.as_ptr()).r;
                    (*x.as_ptr()).r = Some(p);
                    (*p.as_ptr()).p = Some(x);
                    (*p.as_ptr()).l = b;
                    if let Some(b) = b {
                        (*b.as_ptr()).p = Some(p);
                    }
                } else {
                    let b = (*x.as_ptr()).l;
                    (*x.as_ptr()).l = Some(p);
                    (*p.as_ptr()).p = Some(x);
                    (*p.as_ptr()).r = b;
                    if let Some(b) = b {
                        (*b.as_ptr()).p = Some(p);
                    }
                }

                (*p.as_ptr()).upd_subtree();
                (*x.as_ptr()).upd_subtree();
                true
            } else {
                false
            }
        }

        fn splay(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) {
            unsafe {
                while let Some(root) = self.root {
                    if ptr::eq(x.as_ptr(), root.as_ptr()) {
                        break;
                    }

                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
                        if ptr::eq(root.as_ptr(), p.as_ptr()) {
                            // If p is root, rotate x once
                            self.rotate(x);
                        } else {
                            // Panics if pp doesn't exist, which happens only when p is root
                            let (is_p_left, _pp) = Node::is_left_child(p).unwrap();
                            if is_x_left == is_p_left {
                                self.rotate(p);
                                self.rotate(x);
                            } else {
                                self.rotate(x);
                                self.rotate(x);
                            }
                        }
                    } else {
                        // x has no parent, which should logically never happen
                        unreachable!()
                    }
                }
            }
        }

        unsafe fn kth_ptr(&amp;self, idx: usize) -&gt; Link&lt;T&gt; {
            if self.size &lt;= idx {
                return None;
            }
            if let Some(r) = self.root {
                let mut rem = idx;
                let mut p = r;
                loop {
                    let lsize = (*p.as_ptr()).left_size();
                    match rem.cmp(&amp;lsize) {
                        Ordering::Less =&gt; {
                            p = (*p.as_ptr()).l?;
                        }
                        Ordering::Equal =&gt; {
                            break;
                        }
                        Ordering::Greater =&gt; {
                            rem -= lsize + 1;
                            p = (*p.as_ptr()).r?;
                        }
                    }
                }
                Some(p)
            } else {
                None
            }
        }

        unsafe fn remove_helper(&amp;mut self, x: NonNull&lt;Node&lt;T&gt;&gt;) -&gt; NonNull&lt;Node&lt;T&gt;&gt; {
            // Set remove_target to the actual node to delete
            match ((*x.as_ptr()).l, ((*x.as_ptr()).r)) {
                (None, None) =&gt; {
                    // Reset root if the node itself is root
                    if let Some(root) = self.root {
                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
                            self.root = None;
                        }
                    }
                    // Detatch itself from parent
                    if let Some((is_x_left, p)) = Node::is_left_child(x) {
                        if is_x_left {
                            (*p.as_ptr()).l = None;
                        } else {
                            (*p.as_ptr()).r = None;
                        }
                        // Update subtree size
                        let mut p = p;
                        (*p.as_ptr()).upd_subtree();
                        while let Some(pp) = (*p.as_ptr()).p {
                            p = pp;
                            (*p.as_ptr()).upd_subtree();
                        }
                    }
                    x
                }
                (Some(l), None) =&gt; {
                    // Reset root if the node itself is a root
                    if let Some(root) = self.root {
                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
                            self.root = Some(l);
                        }
                    }

                    (*l.as_ptr()).p = (*x.as_ptr()).p;
                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
                        if is_rt_left {
                            (*p.as_ptr()).l = Some(l);
                        } else {
                            (*p.as_ptr()).r = Some(l);
                        }
                    }

                    let mut p = l;
                    while let Some(pp) = (*p.as_ptr()).p {
                        p = pp;
                        (*p.as_ptr()).upd_subtree();
                    }
                    x
                }
                (None, Some(r)) =&gt; {
                    // Reset root if the node itself is a root
                    if let Some(root) = self.root {
                        if ptr::eq(root.as_ptr(), x.as_ptr()) {
                            self.root = Some(r);
                        }
                    }

                    (*r.as_ptr()).p = (*x.as_ptr()).p;
                    if let Some((is_rt_left, p)) = Node::is_left_child(x) {
                        if is_rt_left {
                            (*p.as_ptr()).l = Some(r);
                        } else {
                            (*p.as_ptr()).r = Some(r);
                        }
                    }

                    let mut p = r;
                    while let Some(pp) = (*p.as_ptr()).p {
                        p = pp;
                        (*p.as_ptr()).upd_subtree();
                    }
                    x
                }
                (Some(l), Some(_)) =&gt; {
                    let mut sw = l;
                    while let Some(sr) = (*sw.as_ptr()).r {
                        sw = sr;
                    }
                    std::mem::swap(&amp;mut (*x.as_ptr()).data, &amp;mut (*sw.as_ptr()).data);
                    sw = self.remove_helper(sw);
                    sw
                }
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adjacency-list-graph-representation"><a class="header" href="#adjacency-list-graph-representation">Adjacency List Graph Representation</a></h1>
<p>Credits to kiwiyou</p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Graph&lt;T&gt; {
    n: usize,
    first: Vec&lt;u32&gt;,
    edge: Vec&lt;(u32, u32, T)&gt;, // (to, prev, data)
}

impl&lt;T&gt; Graph&lt;T&gt; {
    fn new(n: usize, e: usize) -&gt; Self {
        Self {
            n,
            first: vec![u32::MAX; n],
            edge: Vec::with_capacity(e),
        }
    }

    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len() as u32);
        self.edge.push((to as u32, prev, data));
    }

    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
        Neighbor {
            graph: self,
            next_edge: self.first[of],
        }
    }
}

struct Neighbor&lt;'g, T&gt; {
    graph: &amp;'g Graph&lt;T&gt;,
    next_edge: u32,
}

impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
    type Item = (usize, &amp;'g T);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (to, next_edge, data) = self.graph.edge.get(self.next_edge as usize)?;
        self.next_edge = *next_edge;
        Some((*to as usize, data))
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dijkstra"><a class="header" href="#dijkstra">Dijkstra</a></h1>
<p><code>dijkstra(graph: &amp;Graph&lt;T&gt;, src: usize)</code> where <code>Graph&lt;T&gt;</code> is a <a href="graphs/./adjlist.html">graph representation</a>, <code>T</code> is a numeric data type, and <code>src</code> is an id of a source node. It returns a <code>dist = Vec&lt;Option&lt;T&gt;&gt;</code>, where <code>dist[dst]</code> is the length of a shortest path from <code>src</code> to <code>dst</code> if it exists, or <code>None</code> if <code>dst</code> is unreachable from <code>src</code>.</p>
<h2 id="example-14"><a class="header" href="#example-14">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut g: Graph&lt;i64&gt; = Graph::new(4, 3);
g.add_edge(0, 1, 5);
g.add_edge(1, 2, 5);
g.add_edge(1, 2, 15);
println!(&quot;{:?}&quot;, dijkstra(&amp;g, 0));
<span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Graph&lt;T&gt; {
</span><span class="boring">    n: usize,
</span><span class="boring">    first: Vec&lt;usize&gt;,
</span><span class="boring">    edge: Vec&lt;(usize, usize, T)&gt;, // (to, prev, data)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Graph&lt;T&gt; {
</span><span class="boring">    fn new(n: usize, e: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            first: vec![usize::MAX; n],
</span><span class="boring">            edge: Vec::with_capacity(e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
</span><span class="boring">        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len());
</span><span class="boring">        self.edge.push((to, prev, data));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
</span><span class="boring">        Neighbor {
</span><span class="boring">            graph: self,
</span><span class="boring">            next_edge: self.first[of],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Neighbor&lt;'g, T&gt; {
</span><span class="boring">    graph: &amp;'g Graph&lt;T&gt;,
</span><span class="boring">    next_edge: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
</span><span class="boring">    type Item = (usize, &amp;'g T);
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        let (to, next_edge, data) = self.graph.edge.get(self.next_edge)?;
</span><span class="boring">        self.next_edge = *next_edge;
</span><span class="boring">        Some((*to, data))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn dijkstra&lt;T: Copy + From&lt;u8&gt; + std::ops::Add&lt;Output = T&gt; + Eq + Ord&gt;(
</span><span class="boring">    graph: &amp;Graph&lt;T&gt;,
</span><span class="boring">    src: usize,
</span><span class="boring">) -&gt; Vec&lt;Option&lt;T&gt;&gt; {
</span><span class="boring">    use std::{cmp::Reverse, collections::BinaryHeap};
</span><span class="boring">    let mut dist: Vec&lt;Option&lt;T&gt;&gt; = vec![None; graph.n];
</span><span class="boring">    let mut heap: BinaryHeap&lt;(Reverse&lt;T&gt;, usize)&gt; = BinaryHeap::new();
</span><span class="boring">    heap.push((Reverse(0.into()), src));
</span><span class="boring">
</span><span class="boring">    while let Some((Reverse(curr_cost), curr)) = heap.pop() {
</span><span class="boring">        if dist[curr].map_or(false, |x| x &lt; curr_cost) {
</span><span class="boring">            continue;
</span><span class="boring">        }
</span><span class="boring">        dist[curr] = Some(curr_cost);
</span><span class="boring">
</span><span class="boring">        for (next, &amp;weight) in graph.neighbor(curr) {
</span><span class="boring">            let next_cost = curr_cost + weight;
</span><span class="boring">            if dist[next].map_or(true, |x| x &gt; next_cost) {
</span><span class="boring">                dist[next] = Some(next_cost);
</span><span class="boring">                heap.push((Reverse(next_cost), next));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    dist
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-13"><a class="header" href="#code-13">Code</a></h2>
<pre><code class="language-rust noplayground">trait HasNz {
    type NzType;
    fn into_nz(self) -&gt; Option&lt;Self::NzType&gt;;
    fn retrieve(nz: Self::NzType) -&gt; Self;
}

macro_rules! impl_hasnz {
    ($($t:ty, $n:ty);*) =&gt; { $(
        impl HasNz for $t {
            type NzType = $n;
            fn into_nz(self) -&gt; Option&lt;$n&gt; { &lt;$n&gt;::new(self) }
            fn retrieve(nz: $n) -&gt; Self { nz.get() }
        }
    )* };
}

use std::num::*;
impl_hasnz!(i8, NonZeroI8; i16, NonZeroI16; i32, NonZeroI32; i64, NonZeroI64; i128, NonZeroI128; isize, NonZeroIsize);
impl_hasnz!(u8, NonZeroU8; u16, NonZeroU16; u32, NonZeroU32; u64, NonZeroU64; u128, NonZeroU128; usize, NonZeroUsize);

use std::ops::*;
fn dijkstra&lt;T&gt;(graph: &amp;Graph&lt;T&gt;, src: usize) -&gt; Vec&lt;Option&lt;T&gt;&gt;
where
    T: Copy + From&lt;u8&gt; + Add&lt;Output = T&gt; + Sub&lt;Output = T&gt; + Eq + Ord + HasNz,
    &lt;T as HasNz&gt;::NzType: Copy,
{
    use core::cmp::Reverse;
    use std::collections::BinaryHeap;

    let mut dist: Vec&lt;Option&lt;T::NzType&gt;&gt; = vec![None; graph.n];
    let mut heap: BinaryHeap&lt;(Reverse&lt;T&gt;, usize)&gt; = BinaryHeap::new();
    heap.push((Reverse(1.into()), src));

    while let Some((Reverse(curr_cost), curr)) = heap.pop() {
        if dist[curr].map_or(false, |x| T::retrieve(x) &lt; curr_cost) {
            continue;
        }
        dist[curr] = curr_cost.into_nz();

        for (next, &amp;weight) in graph.neighbor(curr) {
            let next_cost = curr_cost + weight;
            if dist[next].map_or(true, |x| T::retrieve(x) &gt; next_cost) {
                dist[next] = next_cost.into_nz();
                heap.push((Reverse(next_cost), next));
            }
        }
    }

    dist.iter()
        .map(|x| x.map(|x| T::retrieve(x) - 1.into()))
        .collect()
}</code></pre>
<h3 id="compact-version"><a class="header" href="#compact-version">Compact Version</a></h3>
<p>The code is much compact, but the performance is slightly worse than the one above. This version seems to be approximately 10% slower, but none of the definitive tests have been done to check it.</p>
<pre><code class="language-rust noplayground">fn dijkstra&lt;T: Copy + From&lt;u8&gt; + std::ops::Add&lt;Output = T&gt; + Eq + Ord&gt;(
    graph: &amp;Graph&lt;T&gt;,
    src: usize,
) -&gt; Vec&lt;Option&lt;T&gt;&gt; {
    use std::{cmp::Reverse, collections::BinaryHeap};
    let mut dist: Vec&lt;Option&lt;T&gt;&gt; = vec![None; graph.n];
    let mut heap: BinaryHeap&lt;(Reverse&lt;T&gt;, usize)&gt; = BinaryHeap::new();
    heap.push((Reverse(0.into()), src));

    while let Some((Reverse(curr_cost), curr)) = heap.pop() {
        if dist[curr].map_or(false, |x| x &lt; curr_cost) {
            continue;
        }
        dist[curr] = Some(curr_cost);

        for (next, &amp;weight) in graph.neighbor(curr) {
            let next_cost = curr_cost + weight;
            if dist[next].map_or(true, |x| x &gt; next_cost) {
                dist[next] = Some(next_cost);
                heap.push((Reverse(next_cost), next));
            }
        }
    }
    dist
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dial"><a class="header" href="#dial">Dial</a></h1>
<p>Dial algorithm is an alternative to Dijkstra algorithm, which can be used when the maximum value of the edge costs is small. Instead of using a heap, dial algorithm uses a queue of vectors to sort searched paths by their distances. Generally the performance of it is quite similar to that of Dijkstra, but if somehow you want to use this instead, then go ahead!</p>
<p>The usage is exactly the same with Dijkstra algorithm, except that the name of the function is different.</p>
<h2 id="code-14"><a class="header" href="#code-14">Code</a></h2>
<pre><code class="language-rust noplayground">use std::num::*;
impl_hasnz!(i8, NonZeroI8; i16, NonZeroI16; i32, NonZeroI32; i64, NonZeroI64; i128, NonZeroI128; isize, NonZeroIsize);
impl_hasnz!(u8, NonZeroU8; u16, NonZeroU16; u32, NonZeroU32; u64, NonZeroU64; u128, NonZeroU128; usize, NonZeroUsize);

use std::ops::*;
fn dial&lt;T&gt;(graph: &amp;Graph&lt;T&gt;, src: usize) -&gt; Vec&lt;Option&lt;T&gt;&gt;
where
    T: Copy + From&lt;u8&gt; + Into&lt;u32&gt; + Add&lt;Output = T&gt; + Sub&lt;Output = T&gt; + Eq + Ord + HasNz,
    &lt;T as HasNz&gt;::Nz: Copy,
{
    let max_cost: u32 = graph.edge.iter().map(|x| x.2.into()).max().unwrap_or(0);

    let mut dist: Vec&lt;Option&lt;T::Nz&gt;&gt; = vec![None; graph.n];
    dist[src] = {
        let one: T = 1.into();
        one.into_nz()
    };

    let mut qcnt: usize = 1;
    let mut queue = std::collections::VecDeque::with_capacity(max_cost as usize + 2);
    for _ in 0..=queue.capacity() {
        queue.push_back(vec![]);
    }
    queue[0].push(src as u32);

    let mut curr_cost: T = 0.into();
    while qcnt != 0 {
        curr_cost = curr_cost + 1.into();
        let mut hand = queue.pop_front().unwrap();

        while let Some(curr) = hand.pop() {
            qcnt -= 1;
            if dist[curr as usize].map_or(false, |x| T::retrieve(x) &lt; curr_cost) {
                continue;
            }

            for (next, &amp;weight) in graph.neighbor(curr as usize) {
                let next_cost = curr_cost + weight;

                if dist[next].map_or(true, |x| T::retrieve(x) &gt; next_cost) {
                    dist[next] = next_cost.into_nz();

                    qcnt += 1;
                    if weight == 0.into() {
                        hand.push(next as u32);
                    } else {
                        queue[weight.into() as usize - 1].push(next as u32);
                    }
                }
            }
        }

        queue.push_back(hand);
    }

    dist.iter()
        .map(|x| x.map(|x| T::retrieve(x) - 1.into()))
        .collect()
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disjoint-set-union"><a class="header" href="#disjoint-set-union">Disjoint Set Union</a></h1>
<p>Disjoint set union data structure.</p>
<h2 id="example-15"><a class="header" href="#example-15">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct UnionFind {
</span><span class="boring">    n: usize,
</span><span class="boring">    parent: Vec&lt;usize&gt;,
</span><span class="boring">    group_num: usize,
</span><span class="boring">    group_size: Vec&lt;usize&gt;,
</span><span class="boring">}
</span><span class="boring">impl UnionFind {
</span><span class="boring">    fn new(n: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            parent: vec![n; n],
</span><span class="boring">            group_num: n,
</span><span class="boring">            group_size: vec![1; n],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn find(&amp;mut self, u: usize) -&gt; usize {
</span><span class="boring">        let par = self.parent[u];
</span><span class="boring">        if par == self.n {
</span><span class="boring">            return u;
</span><span class="boring">        }
</span><span class="boring">        self.parent[u] = self.find(par);
</span><span class="boring">        self.parent[u]
</span><span class="boring">    }
</span><span class="boring">    fn is_differ(&amp;mut self, u: usize, v: usize) -&gt; bool {
</span><span class="boring">        self.find(u) != self.find(v)
</span><span class="boring">    }
</span><span class="boring">    fn union(&amp;mut self, u: usize, v: usize) {
</span><span class="boring">        let (ur, vr) = (self.find(u), self.find(v));
</span><span class="boring">        if ur != vr {
</span><span class="boring">            self.parent[vr] = ur;
</span><span class="boring">            self.group_size[ur] += self.group_size[vr];
</span><span class="boring">            self.group_num -= 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn get_group_size(&amp;mut self, u: usize) -&gt; usize {
</span><span class="boring">        let r = self.find(u);
</span><span class="boring">        self.group_size[r]
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">fn main() {
</span>let mut uf = UnionFind::new(10);
println!(&quot;{}&quot;, uf.is_differ(2, 6)); // true
uf.union(2, 6);
println!(&quot;{}&quot;, uf.is_differ(2, 6)); // false
<span class="boring">}</span></code></pre></pre>
<h2 id="code-15"><a class="header" href="#code-15">Code</a></h2>
<pre><code class="language-rust noplayground">struct UnionFind {
    n: usize,
    parent: Vec&lt;usize&gt;,
    group_num: usize,
    group_size: Vec&lt;usize&gt;,
}

impl UnionFind {
    fn new(n: usize) -&gt; Self {
        Self {
            n,
            parent: vec![n; n],
            group_num: n,
            group_size: vec![1; n],
        }
    }

    /// Returns the root of a group u is in
    fn find(&amp;mut self, u: usize) -&gt; usize {
        let par = self.parent[u];
        if par == self.n {
            return u;
        }
        self.parent[u] = self.find(par);
        self.parent[u]
    }

    /// Returns true if u and v are in different groups, false otherwise.
    fn is_differ(&amp;mut self, u: usize, v: usize) -&gt; bool {
        self.find(u) != self.find(v)
    }

    /// The group of v is merged into the group of u
    fn union(&amp;mut self, u: usize, v: usize) {
        let (ur, vr) = (self.find(u), self.find(v));
        if ur != vr {
            self.parent[vr] = ur;
            self.group_size[ur] += self.group_size[vr];
            self.group_num -= 1;
        }
    }

    fn get_group_size(&amp;mut self, u: usize) -&gt; usize {
        let r = self.find(u);
        self.group_size[r]
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weighted-dsu"><a class="header" href="#weighted-dsu">Weighted DSU</a></h1>
<p>Disjoint set union where vertices have their own &quot;potential value&quot;.</p>
<h2 id="code-16"><a class="header" href="#code-16">Code</a></h2>
<pre><code class="language-rust noplayground">struct WeightDSU {
    n: usize,
    group_num: usize,
    parent: Vec&lt;usize&gt;,
    group_size: Vec&lt;usize&gt;,
    potdiff: Vec&lt;i64&gt;,
}

impl WeightDSU {
    fn new(n: usize) -&gt; Self {
        Self {
            n,
            group_num: n,
            parent: vec![n; n],
            group_size: vec![1; n],
            potdiff: vec![0; n],
        }
    }

    /// Returns the root of u, and pot[u]-pot[root]
    fn find(&amp;mut self, u: usize) -&gt; (usize, i64) {
        let par = self.parent[u];
        if par == self.n {
            return (u, 0);
        }
        let (root, parpoten) = self.find(par);
        self.potdiff[u] += parpoten;
        self.parent[u] = root;
        (root, self.potdiff[u])
    }

    /// Returns pot[u]-pot[v]. Returns None if u and v aren't in the same group.
    fn pot_differ(&amp;mut self, u: usize, v: usize) -&gt; Option&lt;i64&gt; {
        let (ur, udiff) = self.find(u);
        let (vr, vdiff) = self.find(v);
        if ur != vr {
            None
        } else {
            Some(udiff - vdiff)
        }
    }

    /// Unions u and v, with setting pot[u]-pot[v] = w.
    /// Also puts the root of v under the root of u.
    /// Returns false if u and v are already unioned and the relation is not consistent.
    fn union(&amp;mut self, u: usize, v: usize, w: i64) -&gt; bool {
        let (ur, udiff) = self.find(u);
        let (vr, vdiff) = self.find(v);
        if ur == vr {
            udiff - vdiff == w
        } else {
            self.parent[vr] = ur;
            self.potdiff[vr] = udiff - vdiff - w;
            self.group_size[ur] += self.group_size[vr];
            self.group_num -= 1;
            true
        }
    }

    fn get_group_size(&amp;mut self, u: usize) -&gt; usize {
        let r = self.find(u).0;
        self.group_size[r]
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strongly-connected-components"><a class="header" href="#strongly-connected-components">Strongly Connected Components</a></h1>
<p>Finding SCCs of a directed graph. Tarjan's algorithm is used for the algorithm. <a href="graphs/./adjlist.html">Adjancy list representation</a> should be included in the code for this snippet to work.</p>
<h2 id="example-16"><a class="header" href="#example-16">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use scc::*;
<span class="boring">
</span><span class="boring">fn main() {
</span>let mut graph: Graph&lt;()&gt; = Graph::new(5, 5);

graph.add_edge(0, 2, ());
graph.add_edge(3, 0, ());
graph.add_edge(2, 3, ());
graph.add_edge(0, 1, ());
graph.add_edge(1, 4, ());

let scc = Scc::new(&amp;graph);
println!(&quot;{:?}&quot;, scc.get_scc_list()); // [[3, 2, 0], [1], [4]]
println!(&quot;{:?}&quot;, scc.get_scc_ids()); // [0, 1, 0, 0, 2]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Graph&lt;T&gt; {
</span><span class="boring">    n: usize,
</span><span class="boring">    first: Vec&lt;usize&gt;,
</span><span class="boring">    edge: Vec&lt;(usize, usize, T)&gt;, // (to, prev, data)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Graph&lt;T&gt; {
</span><span class="boring">    fn new(n: usize, e: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            first: vec![usize::MAX; n],
</span><span class="boring">            edge: Vec::with_capacity(e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
</span><span class="boring">        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len());
</span><span class="boring">        self.edge.push((to, prev, data));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
</span><span class="boring">        Neighbor {
</span><span class="boring">            graph: self,
</span><span class="boring">            next_edge: self.first[of],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Neighbor&lt;'g, T&gt; {
</span><span class="boring">    graph: &amp;'g Graph&lt;T&gt;,
</span><span class="boring">    next_edge: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
</span><span class="boring">    type Item = (usize, &amp;'g T);
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        let (to, next_edge, data) = self.graph.edge.get(self.next_edge)?;
</span><span class="boring">        self.next_edge = *next_edge;
</span><span class="boring">        Some((*to, data))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod scc {
</span><span class="boring">    use super::*;
</span><span class="boring">    struct SccStack {
</span><span class="boring">        stack: Vec&lt;u32&gt;,
</span><span class="boring">        check: Vec&lt;bool&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl SccStack {
</span><span class="boring">        fn new(cap: usize) -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                stack: vec![0; cap],
</span><span class="boring">                check: vec![false; cap],
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn push(&amp;mut self, n: usize) {
</span><span class="boring">            self.stack.push(n as u32);
</span><span class="boring">            self.check[n] = true;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn pop(&amp;mut self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">            let tmp = self.stack.pop()? as usize;
</span><span class="boring">            self.check[tmp] = false;
</span><span class="boring">            Some(tmp)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn contains(&amp;self, n: usize) -&gt; bool {
</span><span class="boring">            self.check[n]
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct Scc&lt;'g, T&gt; {
</span><span class="boring">        graph: &amp;'g Graph&lt;T&gt;,
</span><span class="boring">        scc_list: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">        scc_ids: Vec&lt;usize&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;'g, T: 'g&gt; Scc&lt;'g, T&gt; {
</span><span class="boring">        pub(super) fn new(graph: &amp;'g Graph&lt;T&gt;) -&gt; Self {
</span><span class="boring">            let mut st = SccStack::new(graph.n);
</span><span class="boring">            let mut list = vec![];
</span><span class="boring">            let mut gid = 0;
</span><span class="boring">            let mut id = vec![graph.n; graph.n];
</span><span class="boring">            let mut low = vec![usize::MAX; graph.n];
</span><span class="boring">
</span><span class="boring">            for x in 0..graph.n {
</span><span class="boring">                if id[x] != graph.n {
</span><span class="boring">                    continue;
</span><span class="boring">                }
</span><span class="boring">                Self::dfs(graph, x, &amp;mut gid, &amp;mut id, &amp;mut low, &amp;mut st, &amp;mut list);
</span><span class="boring">            }
</span><span class="boring">            list.reverse();
</span><span class="boring">
</span><span class="boring">            let mut ids = vec![0; graph.n];
</span><span class="boring">            for (i, l) in list.iter().enumerate() {
</span><span class="boring">                for &amp;v in l.iter() {
</span><span class="boring">                    ids[v] = i;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            Self {
</span><span class="boring">                graph,
</span><span class="boring">                scc_list: list,
</span><span class="boring">                scc_ids: ids,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn dfs(
</span><span class="boring">            graph: &amp;Graph&lt;T&gt;,
</span><span class="boring">            curr: usize,
</span><span class="boring">            gid: &amp;mut usize,
</span><span class="boring">            id: &amp;mut Vec&lt;usize&gt;,
</span><span class="boring">            low: &amp;mut Vec&lt;usize&gt;,
</span><span class="boring">            st: &amp;mut SccStack,
</span><span class="boring">            list: &amp;mut Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">        ) {
</span><span class="boring">            st.push(curr);
</span><span class="boring">            id[curr] = *gid;
</span><span class="boring">            low[curr] = *gid;
</span><span class="boring">            *gid += 1;
</span><span class="boring">
</span><span class="boring">            for (next, _) in graph.neighbor(curr) {
</span><span class="boring">                if id[next] == graph.n {
</span><span class="boring">                    Self::dfs(graph, next, gid, id, low, st, list);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            for (next, _) in graph.neighbor(curr) {
</span><span class="boring">                if st.contains(next) {
</span><span class="boring">                    low[curr] = low[curr].min(low[next]);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            if id[curr] == low[curr] {
</span><span class="boring">                let mut newlist = vec![];
</span><span class="boring">                while let Some(popped) = st.pop() {
</span><span class="boring">                    if popped == curr {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                    newlist.push(popped);
</span><span class="boring">                }
</span><span class="boring">                newlist.push(curr);
</span><span class="boring">                list.push(newlist);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns list of SCCs. Each vector in the list is a single SCC. The order of SCCs are
</span><span class="boring">        /// sorted in topological order. That is,, if u and v are in different SCCs, and there is
</span><span class="boring">        /// an edge from u to v, then the SCC containing u appears earlier than the SCC containing
</span><span class="boring">        /// v in the list. The order of vertices in each SCC is unspecified.
</span><span class="boring">        pub fn get_scc_list(&amp;self) -&gt; &amp;Vec&lt;Vec&lt;usize&gt;&gt; {
</span><span class="boring">            &amp;self.scc_list
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns SCC ids. If u is in scc_list[i], then scc_id[u] = i.
</span><span class="boring">        pub fn get_scc_ids(&amp;self) -&gt; &amp;Vec&lt;usize&gt; {
</span><span class="boring">            &amp;self.scc_ids
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-17"><a class="header" href="#code-17">Code</a></h2>
<pre><code class="language-rust noplayground">mod scc {
    use super::*;
    struct SccStack {
        stack: Vec&lt;u32&gt;,
        check: Vec&lt;bool&gt;,
    }

    impl SccStack {
        fn new(cap: usize) -&gt; Self {
            Self {
                stack: vec![0; cap],
                check: vec![false; cap],
            }
        }

        fn push(&amp;mut self, n: u32) {
            self.stack.push(n);
            self.check[n as usize] = true;
        }

        fn pop(&amp;mut self) -&gt; Option&lt;u32&gt; {
            let tmp = self.stack.pop()?;
            self.check[tmp as usize] = false;
            Some(tmp)
        }

        fn contains(&amp;self, n: u32) -&gt; bool {
            self.check[n as usize]
        }
    }

    pub struct Scc&lt;'g, T&gt; {
        graph: &amp;'g Graph&lt;T&gt;,
        scc_list: Vec&lt;Vec&lt;usize&gt;&gt;,
        scc_ids: Vec&lt;usize&gt;,
    }

    impl&lt;'g, T: 'g&gt; Scc&lt;'g, T&gt; {
        pub(super) fn new(graph: &amp;'g Graph&lt;T&gt;) -&gt; Self {
            let mut st = SccStack::new(graph.n);
            let mut list = vec![];
            let mut gid = 0;
            let mut id = vec![graph.n as u32; graph.n];
            let mut low = vec![u32::MAX; graph.n];

            for x in 0..graph.n as u32 {
                if id[x as usize] != graph.n as u32 {
                    continue;
                }
                Self::dfs(graph, x, &amp;mut gid, &amp;mut id, &amp;mut low, &amp;mut st, &amp;mut list);
            }
            list.reverse();

            let mut ids = vec![0; graph.n];
            for (i, l) in list.iter().enumerate() {
                for &amp;v in l.iter() {
                    ids[v] = i;
                }
            }

            Self {
                graph,
                scc_list: list,
                scc_ids: ids,
            }
        }

        fn dfs(
            graph: &amp;Graph&lt;T&gt;,
            curr: u32,
            gid: &amp;mut u32,
            id: &amp;mut Vec&lt;u32&gt;,
            low: &amp;mut Vec&lt;u32&gt;,
            st: &amp;mut SccStack,
            list: &amp;mut Vec&lt;Vec&lt;usize&gt;&gt;,
        ) {
            st.push(curr);
            id[curr as usize] = *gid;
            low[curr as usize] = *gid;
            *gid += 1;

            for (next, _) in graph.neighbor(curr as usize) {
                if id[next] == graph.n as u32 {
                    Self::dfs(graph, next as u32, gid, id, low, st, list);
                }
            }

            for (next, _) in graph.neighbor(curr as usize) {
                if st.contains(next as u32) {
                    low[curr as usize] = low[curr as usize].min(low[next]);
                }
            }

            if id[curr as usize] == low[curr as usize] {
                let mut newlist = vec![];
                while let Some(popped) = st.pop() {
                    if popped == curr {
                        break;
                    }
                    newlist.push(popped as usize);
                }
                newlist.push(curr as usize);
                list.push(newlist);
            }
        }

        /// Returns list of SCCs. Each vector in the list is a single SCC. The order of SCCs are
        /// sorted in topological order. That is,, if u and v are in different SCCs, and there is
        /// an edge from u to v, then the SCC containing u appears earlier than the SCC containing
        /// v in the list. The order of vertices in each SCC is unspecified.
        pub fn get_scc_list(&amp;self) -&gt; &amp;Vec&lt;Vec&lt;usize&gt;&gt; {
            &amp;self.scc_list
        }

        /// Returns SCC ids. If u is in scc_list[i], then scc_id[u] = i.
        pub fn get_scc_ids(&amp;self) -&gt; &amp;Vec&lt;usize&gt; {
            &amp;self.scc_ids
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sat"><a class="header" href="#2-sat">2-SAT</a></h1>
<p>2-SAT with \(N\) clauses can be solved with time complexity of \(O(N)\). SCC module should be with this snippet in the code.</p>
<h2 id="example-17"><a class="header" href="#example-17">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use twosat::*;

<span class="boring">
</span><span class="boring">fn main() {
</span>// (not 0 or 1) and (not 1 or 2) and (0 or 2) and (2 or 1)
let mut ts = TwoSat::new(3, 4);
ts.add_clause(0, false, 1, true);
ts.add_clause(1, false, 2, true);
ts.add_clause(0, true, 2, true);
ts.add_clause(2, true, 1, true);
println!(&quot;{:?}&quot;, ts.solve()); // Some([false, true, true])

// (0 or 0) and (not 0 or not 0)
let mut ts = TwoSat::new(1, 2);
ts.add_clause(0, true, 0, true);
ts.add_clause(0, false, 0, false);
println!(&quot;{:?}&quot;, ts.solve()); // None
<span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Graph&lt;T&gt; {
</span><span class="boring">    n: usize,
</span><span class="boring">    first: Vec&lt;usize&gt;,
</span><span class="boring">    edge: Vec&lt;(usize, usize, T)&gt;, // (to, prev, data)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Graph&lt;T&gt; {
</span><span class="boring">    fn new(n: usize, e: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            n,
</span><span class="boring">            first: vec![usize::MAX; n],
</span><span class="boring">            edge: Vec::with_capacity(e),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn add_edge(&amp;mut self, from: usize, to: usize, data: T) {
</span><span class="boring">        let prev = std::mem::replace(&amp;mut self.first[from], self.edge.len());
</span><span class="boring">        self.edge.push((to, prev, data));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn neighbor(&amp;self, of: usize) -&gt; Neighbor&lt;T&gt; {
</span><span class="boring">        Neighbor {
</span><span class="boring">            graph: self,
</span><span class="boring">            next_edge: self.first[of],
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Neighbor&lt;'g, T&gt; {
</span><span class="boring">    graph: &amp;'g Graph&lt;T&gt;,
</span><span class="boring">    next_edge: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'g, T&gt; Iterator for Neighbor&lt;'g, T&gt; {
</span><span class="boring">    type Item = (usize, &amp;'g T);
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        let (to, next_edge, data) = self.graph.edge.get(self.next_edge)?;
</span><span class="boring">        self.next_edge = *next_edge;
</span><span class="boring">        Some((*to, data))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod scc {
</span><span class="boring">    use super::*;
</span><span class="boring">    struct SccStack {
</span><span class="boring">        stack: Vec&lt;u32&gt;,
</span><span class="boring">        check: Vec&lt;bool&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl SccStack {
</span><span class="boring">        fn new(cap: usize) -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                stack: vec![0; cap],
</span><span class="boring">                check: vec![false; cap],
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn push(&amp;mut self, n: usize) {
</span><span class="boring">            self.stack.push(n as u32);
</span><span class="boring">            self.check[n] = true;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn pop(&amp;mut self) -&gt; Option&lt;usize&gt; {
</span><span class="boring">            let tmp = self.stack.pop()? as usize;
</span><span class="boring">            self.check[tmp] = false;
</span><span class="boring">            Some(tmp)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn contains(&amp;self, n: usize) -&gt; bool {
</span><span class="boring">            self.check[n]
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct Scc&lt;'g, T&gt; {
</span><span class="boring">        graph: &amp;'g Graph&lt;T&gt;,
</span><span class="boring">        scc_list: Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">        scc_ids: Vec&lt;usize&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;'g, T: 'g&gt; Scc&lt;'g, T&gt; {
</span><span class="boring">        pub(super) fn new(graph: &amp;'g Graph&lt;T&gt;) -&gt; Self {
</span><span class="boring">            let mut st = SccStack::new(graph.n);
</span><span class="boring">            let mut list = vec![];
</span><span class="boring">            let mut gid = 0;
</span><span class="boring">            let mut id = vec![graph.n; graph.n];
</span><span class="boring">            let mut low = vec![usize::MAX; graph.n];
</span><span class="boring">
</span><span class="boring">            for x in 0..graph.n {
</span><span class="boring">                if id[x] != graph.n {
</span><span class="boring">                    continue;
</span><span class="boring">                }
</span><span class="boring">                Self::dfs(graph, x, &amp;mut gid, &amp;mut id, &amp;mut low, &amp;mut st, &amp;mut list);
</span><span class="boring">            }
</span><span class="boring">            list.reverse();
</span><span class="boring">
</span><span class="boring">            let mut ids = vec![0; graph.n];
</span><span class="boring">            for (i, l) in list.iter().enumerate() {
</span><span class="boring">                for &amp;v in l.iter() {
</span><span class="boring">                    ids[v] = i;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            Self {
</span><span class="boring">                graph,
</span><span class="boring">                scc_list: list,
</span><span class="boring">                scc_ids: ids,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn dfs(
</span><span class="boring">            graph: &amp;Graph&lt;T&gt;,
</span><span class="boring">            curr: usize,
</span><span class="boring">            gid: &amp;mut usize,
</span><span class="boring">            id: &amp;mut Vec&lt;usize&gt;,
</span><span class="boring">            low: &amp;mut Vec&lt;usize&gt;,
</span><span class="boring">            st: &amp;mut SccStack,
</span><span class="boring">            list: &amp;mut Vec&lt;Vec&lt;usize&gt;&gt;,
</span><span class="boring">        ) {
</span><span class="boring">            st.push(curr);
</span><span class="boring">            id[curr] = *gid;
</span><span class="boring">            low[curr] = *gid;
</span><span class="boring">            *gid += 1;
</span><span class="boring">
</span><span class="boring">            for (next, _) in graph.neighbor(curr) {
</span><span class="boring">                if id[next] == graph.n {
</span><span class="boring">                    Self::dfs(graph, next, gid, id, low, st, list);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            for (next, _) in graph.neighbor(curr) {
</span><span class="boring">                if st.contains(next) {
</span><span class="boring">                    low[curr] = low[curr].min(low[next]);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            if id[curr] == low[curr] {
</span><span class="boring">                let mut newlist = vec![];
</span><span class="boring">                while let Some(popped) = st.pop() {
</span><span class="boring">                    if popped == curr {
</span><span class="boring">                        break;
</span><span class="boring">                    }
</span><span class="boring">                    newlist.push(popped);
</span><span class="boring">                }
</span><span class="boring">                newlist.push(curr);
</span><span class="boring">                list.push(newlist);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns list of SCCs. Each vector in the list is a single SCC. The order of SCCs are
</span><span class="boring">        /// sorted in topological order. That is,, if u and v are in different SCCs, and there is
</span><span class="boring">        /// an edge from u to v, then the SCC containing u appears earlier than the SCC containing
</span><span class="boring">        /// v in the list. The order of vertices in each SCC is unspecified.
</span><span class="boring">        pub fn get_scc_list(&amp;self) -&gt; &amp;Vec&lt;Vec&lt;usize&gt;&gt; {
</span><span class="boring">            &amp;self.scc_list
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Returns SCC ids. If u is in scc_list[i], then scc_id[u] = i.
</span><span class="boring">        pub fn get_scc_ids(&amp;self) -&gt; &amp;Vec&lt;usize&gt; {
</span><span class="boring">            &amp;self.scc_ids
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod twosat {
</span><span class="boring">    use super::{scc::*, *};
</span><span class="boring">
</span><span class="boring">    pub struct TwoSat {
</span><span class="boring">        n: usize,
</span><span class="boring">        graph: Graph&lt;()&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl TwoSat {
</span><span class="boring">        pub fn new(n: usize, clause_num: usize) -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                n,
</span><span class="boring">                graph: Graph::new(n &lt;&lt; 1, clause_num &lt;&lt; 1),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn judge(f: bool, a: usize, b: usize) -&gt; usize {
</span><span class="boring">            if f {
</span><span class="boring">                a
</span><span class="boring">            } else {
</span><span class="boring">                b
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Adds a clause (&quot;not&quot; if !f)i or (&quot;not&quot; if !g)j.
</span><span class="boring">        pub fn add_clause(&amp;mut self, i: usize, f: bool, j: usize, g: bool) {
</span><span class="boring">            self.graph.add_edge(
</span><span class="boring">                (i &lt;&lt; 1) + Self::judge(f, 0, 1),
</span><span class="boring">                (j &lt;&lt; 1) + Self::judge(g, 1, 0),
</span><span class="boring">                (),
</span><span class="boring">            );
</span><span class="boring">            self.graph.add_edge(
</span><span class="boring">                (j &lt;&lt; 1) + Self::judge(g, 0, 1),
</span><span class="boring">                (i &lt;&lt; 1) + Self::judge(f, 1, 0),
</span><span class="boring">                (),
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub fn solve(self) -&gt; Option&lt;Vec&lt;bool&gt;&gt; {
</span><span class="boring">            let mut answer = vec![false; self.n];
</span><span class="boring">
</span><span class="boring">            let scc = Scc::new(&amp;self.graph);
</span><span class="boring">            let ids = scc.get_scc_ids();
</span><span class="boring">
</span><span class="boring">            for i in 0..self.n {
</span><span class="boring">                if ids[i &lt;&lt; 1] == ids[(i &lt;&lt; 1) + 1] {
</span><span class="boring">                    return None;
</span><span class="boring">                }
</span><span class="boring">                answer[i] = ids[i &lt;&lt; 1] &lt; ids[(i &lt;&lt; 1) + 1];
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            Some(answer)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-18"><a class="header" href="#code-18">Code</a></h2>
<pre><code class="language-rust noplayground">mod twosat {
    use super::{scc::*, *};

    pub struct TwoSat {
        n: usize,
        graph: Graph&lt;()&gt;,
    }

    impl TwoSat {
        pub fn new(n: usize, clause_num: usize) -&gt; Self {
            Self {
                n,
                graph: Graph::new(n &lt;&lt; 1, clause_num &lt;&lt; 1),
            }
        }

        fn judge(f: bool, a: usize, b: usize) -&gt; usize {
            if f {
                a
            } else {
                b
            }
        }

        /// Adds a clause (&quot;not&quot; if !f)i or (&quot;not&quot; if !g)j.
        pub fn add_clause(&amp;mut self, i: usize, f: bool, j: usize, g: bool) {
            self.graph.add_edge(
                (i &lt;&lt; 1) + Self::judge(f, 0, 1),
                (j &lt;&lt; 1) + Self::judge(g, 1, 0),
                (),
            );
            self.graph.add_edge(
                (j &lt;&lt; 1) + Self::judge(g, 0, 1),
                (i &lt;&lt; 1) + Self::judge(f, 1, 0),
                (),
            );
        }

        pub fn solve(self) -&gt; Option&lt;Vec&lt;bool&gt;&gt; {
            let mut answer = vec![false; self.n];

            let scc = Scc::new(&amp;self.graph);
            let ids = scc.get_scc_ids();

            for i in 0..self.n {
                if ids[i &lt;&lt; 1] == ids[(i &lt;&lt; 1) + 1] {
                    return None;
                }
                answer[i] = ids[i &lt;&lt; 1] &lt; ids[(i &lt;&lt; 1) + 1];
            }

            Some(answer)
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<p>Given an array \(P\), <code>KMPNeedle::new(P)</code> returns a <code>KMPNeedle</code> instance for searching \(P\) in any array, using <code>KMPMatcher</code>.</p>
<p>Given a <code>KMPNeedle</code> instance <code>p</code> and an array target \(T\), <code>KMPMatcher::new(&amp;p, T)</code> returns an iterator yielding indicies where \(P\) appears within \(T\). Even if some ranges where \(P\) exists within \(T\) overlap with each other, they are still all yielded as shown in the second string from the example <code>&quot;ABCDABCDABCD&quot;</code>.</p>
<p><code>KMPNeedle::new(P)</code> runs in a time complexity of \(O(\left| P \right|)\) and <code>KMPMatcher::new(T)</code> takes a time complexity of \(O(\left| T \right|)\) to be consumed. <code>KMPMatcher</code> searches for a pattern lazily, so it only takes time of total searched length in \(T\).</p>
<p>A single <code>KMPNeedle</code> instance can be used to search \(P\) in multiple arrays as shown in the example.</p>
<h2 id="example-18"><a class="header" href="#example-18">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let pattern = &quot;ABCDABC&quot;;
let targets = vec![&quot;ABDABCDABCE&quot;, &quot;ABCDABCDABCD&quot;, &quot;ABBCCABCDABDABCDABC&quot;];

let needle = KMPNeedle::new(pattern.as_bytes());
for &amp;t in targets.iter() {
    let kmp = KMPMatcher::new(&amp;needle, t.as_bytes());
    for v in kmp {
        print!(&quot;{} &quot;, v);
    }
    println!();
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KMPNeedle&lt;'a, T: PartialEq&gt; {
</span><span class="boring">    p: &amp;'a [T],
</span><span class="boring">    c: Vec&lt;usize&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T: PartialEq&gt; KMPNeedle&lt;'a, T&gt; {
</span><span class="boring">    fn new(p: &amp;'a [T]) -&gt; Self {
</span><span class="boring">        let mut c: Vec&lt;usize&gt; = vec![0; p.len() + 1];
</span><span class="boring">
</span><span class="boring">        let mut l = 0;
</span><span class="boring">        for (r, v) in p.iter().enumerate().skip(1) {
</span><span class="boring">            while l &gt; 0 &amp;&amp; p[l] != *v {
</span><span class="boring">                l = c[l];
</span><span class="boring">            }
</span><span class="boring">            if p[l] == *v {
</span><span class="boring">                c[r + 1] = l + 1;
</span><span class="boring">                l += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Self { p, c }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KMPMatcher&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; {
</span><span class="boring">    needle: &amp;'c KMPNeedle&lt;'b, T&gt;,
</span><span class="boring">    t: &amp;'a [T],
</span><span class="boring">    i: usize,
</span><span class="boring">    j: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; KMPMatcher&lt;'a, 'b, 'c, T&gt; {
</span><span class="boring">    fn new(needle: &amp;'c KMPNeedle&lt;'b, T&gt;, t: &amp;'a [T]) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            needle,
</span><span class="boring">            t,
</span><span class="boring">            i: 0,
</span><span class="boring">            j: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b: 'a, 'c: 'b, T: PartialEq&gt; Iterator for KMPMatcher&lt;'a, 'b, 'c, T&gt; {
</span><span class="boring">    type Item = usize;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        while self.i &lt; self.t.len() {
</span><span class="boring">            while self.j &gt; 0 &amp;&amp; self.t[self.i] != self.needle.p[self.j] {
</span><span class="boring">                self.j = self.needle.c[self.j];
</span><span class="boring">            }
</span><span class="boring">            if self.t[self.i] == self.needle.p[self.j] {
</span><span class="boring">                if self.j == self.needle.p.len() - 1 {
</span><span class="boring">                    self.j = self.needle.c[self.j + 1];
</span><span class="boring">                    self.i += 1;
</span><span class="boring">                    return Some(self.i - self.needle.p.len());
</span><span class="boring">                } else {
</span><span class="boring">                    self.j += 1;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            self.i += 1;
</span><span class="boring">        }
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-19"><a class="header" href="#code-19">Code</a></h2>
<pre><code class="language-rust noplayground">struct KMPNeedle&lt;'n, T: PartialEq&gt; {
    p: &amp;'n [T],
    c: Vec&lt;usize&gt;,
}

impl&lt;'n, T: PartialEq&gt; KMPNeedle&lt;'n, T&gt; {
    fn new(p: &amp;'n [T]) -&gt; Self {
        let mut c: Vec&lt;usize&gt; = vec![0; p.len() + 1];

        let mut l = 0;
        for (r, v) in p.iter().enumerate().skip(1) {
            while l &gt; 0 &amp;&amp; p[l] != *v {
                l = c[l];
            }
            if p[l] == *v {
                c[r + 1] = l + 1;
                l += 1;
            }
        }

        Self { p, c }
    }
}

struct KMPMatcher&lt;'h, 'n: 'h, 'a: 'n, T: PartialEq&gt; {
    needle: &amp;'a KMPNeedle&lt;'n, T&gt;,
    haystack: &amp;'h [T],
    hp: usize,
    np: usize,
}

impl&lt;'h, 'n: 'h, 'a: 'n, T: PartialEq&gt; KMPMatcher&lt;'h, 'n, 'a, T&gt; {
    fn new(needle: &amp;'a KMPNeedle&lt;'n, T&gt;, haystack: &amp;'h [T]) -&gt; Self {
        Self {
            needle,
            haystack,
            hp: 0,
            np: 0,
        }
    }
}

impl&lt;'h, 'n: 'h, 'a: 'n, T: PartialEq&gt; Iterator for KMPMatcher&lt;'h, 'n, 'a, T&gt; {
    type Item = usize;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        while self.hp &lt; self.haystack.len() {
            while self.np &gt; 0 &amp;&amp; self.haystack[self.hp] != self.needle.p[self.np] {
                self.np = self.needle.c[self.np];
            }
            if self.haystack[self.hp] == self.needle.p[self.np] {
                if self.np == self.needle.p.len() - 1 {
                    self.np = self.needle.c[self.np + 1];
                    self.hp += 1;
                    return Some(self.hp - self.needle.p.len());
                } else {
                    self.np += 1;
                }
            }
            self.hp += 1;
        }
        None
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<p>For an array \(A\) of length \(n\), <code>manacher(A)</code> returns a vector \(M\) where, for every \(i \in \left[0, n\right)\), \(A_{i-j} = A_{i+j}\) holds for every \(j \in \left[0, M_i \right)\).</p>
<p>Additional modification should be added by a user to use this function for finding every palindromes among subsequences of a string.</p>
<h2 id="example-19"><a class="header" href="#example-19">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = &quot;abracadacabra&quot;.as_bytes();
let man = manacher(s);
println!(&quot;{:?}&quot;, man); // [1, 1, 1, 1, 2, 1, 4, 1, 2, 1, 1, 1, 1]

for i in 0..s.len() {
    println!(
        &quot;{}&quot;,
        std::str::from_utf8(&amp;s[i + 1 - man[i]..i + man[i]]).unwrap()
    );
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn manacher&lt;T: Eq&gt;(arr: &amp;[T]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    let n = arr.len();
</span><span class="boring">    let mut mana: Vec&lt;usize&gt; = vec![1; n];
</span><span class="boring">    let mut r: usize = 1;
</span><span class="boring">    let mut p: usize = 0;
</span><span class="boring">
</span><span class="boring">    for i in 1..arr.len() {
</span><span class="boring">        if i + 1 &gt;= r {
</span><span class="boring">            mana[i] = 1;
</span><span class="boring">        } else {
</span><span class="boring">            let j = 2 * p - i;
</span><span class="boring">            mana[i] = mana[j].min(r - i);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        while mana[i] &lt;= i &amp;&amp; i + mana[i] &lt; n {
</span><span class="boring">            if arr[(i - mana[i])] != arr[(i + mana[i])] {
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">            mana[i] += 1;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        if r &lt; mana[i] + i {
</span><span class="boring">            r = mana[i] + i;
</span><span class="boring">            p = i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    mana
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-20"><a class="header" href="#code-20">Code</a></h2>
<pre><code class="language-rust noplayground">fn manacher&lt;T: Eq&gt;(arr: &amp;[T]) -&gt; Vec&lt;usize&gt; {
    let n = arr.len();
    let mut mana: Vec&lt;usize&gt; = vec![1; n];
    let mut r: usize = 1;
    let mut p: usize = 0;

    for i in 1..arr.len() {
        if i + 1 &gt;= r {
            mana[i] = 1;
        } else {
            let j = 2 * p - i;
            mana[i] = mana[j].min(r - i);
        }

        while mana[i] &lt;= i &amp;&amp; i + mana[i] &lt; n {
            if arr[(i - mana[i])] != arr[(i + mana[i])] {
                break;
            }
            mana[i] += 1;
        }

        if r &lt; mana[i] + i {
            r = mana[i] + i;
            p = i;
        }
    }

    mana
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suffix-array-and-lcp-array"><a class="header" href="#suffix-array-and-lcp-array">Suffix Array and LCP Array</a></h1>
<p>For an array \(A\) of length \(n\), <code>sa_lcp(A)</code> returns two vectors \(SA\) and \(LCP\) where,</p>
<ul>
<li>\(A[SA[i] \dots]\) is the \(i\)-th suffix in lexicographical order for every \(i \in \left[0, n\right)\)</li>
</ul>
<p>and</p>
<ul>
<li>\(LCP[i]\) is the length of the longest common prefix between \(A[SA[i-1] \dots]\) and \(A[SA[i] \dots]\) for every \(i \in \left[1, n \right)\). Also, \(LCP[0] = 0\).</li>
</ul>
<p>\(SA\) and \(LCP\) are called &quot;suffix array&quot; and &quot;LCP array&quot; of \(A\) respectively.</p>
<p>For finding SA, Manber-Myers algorithm combined with counting sort is used, hence the time complexity is \(O(n\log{n})\). For LCP array, Kasai's algorithm is used, hence the time complexity is \(O(n)\). The total time complexity is \(O(n\log{n})\).</p>
<h2 id="example-20"><a class="header" href="#example-20">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = &quot;asdsdasd&quot;;
let (sa, lcp) = sa_lcp(s.as_bytes());
println!(&quot;{:?}&quot;, sa);  // [5, 0, 7, 4, 2, 6, 3, 1]
println!(&quot;{:?}&quot;, lcp); // [x, 3, 0, 1, 1, 0, 2, 2]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">// Suffix array and LCP array
</span><span class="boring">// Reference: http://www.secmem.org/blog/2021/07/18/suffix-array-and-lcp/
</span><span class="boring">
</span><span class="boring">fn suffix_array&lt;T: Ord&gt;(s: &amp;[T]) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    use std::collections::*;
</span><span class="boring">
</span><span class="boring">    if s.len() == 0 {
</span><span class="boring">        return vec![];
</span><span class="boring">    } else if s.len() == 1 {
</span><span class="boring">        return vec![0];
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let n = s.len();
</span><span class="boring">
</span><span class="boring">    let mut r: Vec&lt;usize&gt; = vec![0; n * 2];
</span><span class="boring">    let map: BTreeMap&lt;_, _&gt; = {
</span><span class="boring">        let mut sorted: Vec&lt;_&gt; = s.iter().collect();
</span><span class="boring">        sorted.sort_unstable();
</span><span class="boring">        sorted
</span><span class="boring">            .into_iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .map(|x| (x.1, x.0 + 1))
</span><span class="boring">            .collect()
</span><span class="boring">    };
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        r[i] = *map.get(&amp;s[i]).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let m = n.max(map.len()) + 1;
</span><span class="boring">    let mut sa: Vec&lt;usize&gt; = (0..n).collect();
</span><span class="boring">    let mut nr: Vec&lt;usize&gt; = vec![0; n * 2];
</span><span class="boring">    let mut cnt: Vec&lt;usize&gt; = vec![0; m];
</span><span class="boring">    let mut idx: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">
</span><span class="boring">    for d in (0..).map(|x| 1 &lt;&lt; x).take_while(|&amp;d| d &lt; n) {
</span><span class="boring">        macro_rules! key {
</span><span class="boring">            ($i:expr) =&gt; {
</span><span class="boring">                if $i + d &gt;= n {
</span><span class="boring">                    (r[$i], 0)
</span><span class="boring">                } else {
</span><span class="boring">                    (r[$i], r[$i + d])
</span><span class="boring">                }
</span><span class="boring">            };
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        (0..m).for_each(|i| cnt[i] = 0);
</span><span class="boring">        (0..n).for_each(|i| cnt[r[i + d]] += 1);
</span><span class="boring">        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
</span><span class="boring">        for i in (0..n).rev() {
</span><span class="boring">            cnt[r[i + d]] -= 1;
</span><span class="boring">            idx[cnt[r[i + d]]] = i;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        (0..m).for_each(|i| cnt[i] = 0);
</span><span class="boring">        (0..n).for_each(|i| cnt[r[i]] += 1);
</span><span class="boring">        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
</span><span class="boring">        for i in (0..n).rev() {
</span><span class="boring">            cnt[r[idx[i]]] -= 1;
</span><span class="boring">            sa[cnt[r[idx[i]]]] = idx[i];
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        nr[sa[0]] = 1;
</span><span class="boring">        for i in 1..n {
</span><span class="boring">            nr[sa[i]] = nr[sa[i - 1]] + if key!(sa[i - 1]) &lt; key!(sa[i]) { 1 } else { 0 };
</span><span class="boring">        }
</span><span class="boring">        std::mem::swap(&amp;mut r, &amp;mut nr);
</span><span class="boring">
</span><span class="boring">        if r[sa[n - 1]] == n {
</span><span class="boring">            break;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    sa
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn sa_lcp&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
</span><span class="boring">    let n = arr.len();
</span><span class="boring">    let sa = suffix_array(arr);
</span><span class="boring">    let mut lcp: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">    let mut isa: Vec&lt;usize&gt; = vec![0; n];
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        isa[sa[i]] = i;
</span><span class="boring">    }
</span><span class="boring">    let mut k = 0;
</span><span class="boring">    for i in 0..n {
</span><span class="boring">        if isa[i] != 0 {
</span><span class="boring">            let j = sa[isa[i] - 1];
</span><span class="boring">            while i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; arr[i + k] == arr[j + k] {
</span><span class="boring">                k += 1;
</span><span class="boring">            }
</span><span class="boring">            lcp[isa[i]] = if k != 0 {
</span><span class="boring">                k -= 1;
</span><span class="boring">                k + 1
</span><span class="boring">            } else {
</span><span class="boring">                0
</span><span class="boring">            };
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    (sa, lcp)
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-21"><a class="header" href="#code-21">Code</a></h2>
<pre><code class="language-rust noplayground">// Suffix array and LCP array
// Reference: http://www.secmem.org/blog/2021/07/18/suffix-array-and-lcp/

fn suffix_array&lt;T: Ord&gt;(s: &amp;[T]) -&gt; Vec&lt;usize&gt; {
    use std::collections::*;

    if s.len() == 0 {
        return vec![];
    } else if s.len() == 1 {
        return vec![0];
    }

    let n = s.len();

    let mut r: Vec&lt;usize&gt; = vec![0; n * 2];
    let map: BTreeMap&lt;_, _&gt; = {
        let mut sorted: Vec&lt;_&gt; = s.iter().collect();
        sorted.sort_unstable();
        sorted
            .into_iter()
            .enumerate()
            .map(|x| (x.1, x.0 + 1))
            .collect()
    };
    for i in 0..n {
        r[i] = *map.get(&amp;s[i]).unwrap();
    }

    let m = n.max(map.len()) + 1;
    let mut sa: Vec&lt;usize&gt; = (0..n).collect();
    let mut nr: Vec&lt;usize&gt; = vec![0; n * 2];
    let mut cnt: Vec&lt;usize&gt; = vec![0; m];
    let mut idx: Vec&lt;usize&gt; = vec![0; n];

    for d in (0..).map(|x| 1 &lt;&lt; x).take_while(|&amp;d| d &lt; n) {
        macro_rules! key {
            ($i:expr) =&gt; {
                if $i + d &gt;= n {
                    (r[$i], 0)
                } else {
                    (r[$i], r[$i + d])
                }
            };
        }

        (0..m).for_each(|i| cnt[i] = 0);
        (0..n).for_each(|i| cnt[r[i + d]] += 1);
        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
        for i in (0..n).rev() {
            cnt[r[i + d]] -= 1;
            idx[cnt[r[i + d]]] = i;
        }

        (0..m).for_each(|i| cnt[i] = 0);
        (0..n).for_each(|i| cnt[r[i]] += 1);
        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);
        for i in (0..n).rev() {
            cnt[r[idx[i]]] -= 1;
            sa[cnt[r[idx[i]]]] = idx[i];
        }

        nr[sa[0]] = 1;
        for i in 1..n {
            nr[sa[i]] = nr[sa[i - 1]] + if key!(sa[i - 1]) &lt; key!(sa[i]) { 1 } else { 0 };
        }
        std::mem::swap(&amp;mut r, &amp;mut nr);

        if r[sa[n - 1]] == n {
            break;
        }
    }

    sa
}

fn sa_lcp&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
    let n = arr.len();
    let sa = suffix_array(arr);
    let mut lcp: Vec&lt;usize&gt; = vec![0; n];
    let mut isa: Vec&lt;usize&gt; = vec![0; n];
    for i in 0..n {
        isa[sa[i]] = i;
    }
    let mut k = 0;
    for i in 0..n {
        if isa[i] != 0 {
            let j = sa[isa[i] - 1];
            while i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; arr[i + k] == arr[j + k] {
                k += 1;
            }
            lcp[isa[i]] = if k != 0 {
                k -= 1;
                k + 1
            } else {
                0
            };
        }
    }
    (sa, lcp)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convex-hull"><a class="header" href="#convex-hull">Convex Hull</a></h1>
<p><code>cvh(pts: &amp;[Point])</code> returns indices of points included in a convex hull of <code>pts</code>.
It's implemented based on monotone chain algorithm, a much intuitive and straightforward convex hull
algorithm compared to the well-known Graham scan.</p>
<p>The code below excludes the points on the sides of the hull, but by simply changing <code>&gt;=</code> from lines calling <code>ccw</code> to <code>&gt;</code>,
one can change its behavior to include such points.</p>
<p>If <code>pts</code> includes duplicates and those happen to be on the convex hull, then only one of them is included in the result.</p>
<h2 id="code-22"><a class="header" href="#code-22">Code</a></h2>
<pre><code class="language-rust noplayground">type Coord = i32;
type CCWOut = i64;
type Point = (Coord, Coord);

fn ccw(a: &amp;Point, b: &amp;Point, c: &amp;Point) -&gt; CCWOut {
    let ba = (b.0 as CCWOut - a.0 as CCWOut, b.1 as CCWOut - a.1 as CCWOut);
    let cb = (c.0 as CCWOut - b.0 as CCWOut, c.1 as CCWOut - b.1 as CCWOut);
    ba.0 * cb.1 - ba.1 * cb.0
}

fn cvh(pts: &amp;[Point]) -&gt; Vec&lt;usize&gt; {
    if pts.is_empty() {
        return vec![];
    } else if pts.len() == 1 {
        return vec![0];
    }

    let n = pts.len();

    let mut refs: Vec&lt;_&gt; = (0..n).collect();
    refs.sort_unstable_by_key(|&amp;i| pts[i]);
    refs.dedup_by_key(|i| pts[*i]);

    let mut upper = vec![refs[0]];
    for &amp;pt in refs.iter().skip(1) {
        while upper.len() &gt; 1 {
            let ul = upper.len();
            if ccw(&amp;pts[upper[ul - 2]], &amp;pts[upper[ul - 1]], &amp;pts[pt]) &gt; 0 {
                upper.pop();
            } else {
                break;
            }
        }
        upper.push(pt);
    }

    let mut lower = vec![*refs.last().unwrap()];
    for &amp;pt in refs.iter().rev().skip(1) {
        while lower.len() &gt; 1 {
            let ll = lower.len();
            if ccw(&amp;pts[lower[ll - 2]], &amp;pts[lower[ll - 1]], &amp;pts[pt]) &gt; 0 {
                lower.pop();
            } else {
                break;
            }
        }
        lower.push(pt);
    }

    lower.pop();
    upper.into_iter().chain(lower.into_iter().skip(1)).collect()
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-compression"><a class="header" href="#value-compression">Value Compression</a></h1>
<h2 id="example-21"><a class="header" href="#example-21">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let arr: Vec&lt;i32&gt; = vec![1, 2, 4, 7, 9, 7, 4, 2, 1];

let (compressor, reevaluator) = compress_value(&amp;arr);

let compr: Vec&lt;usize&gt; = arr.iter().map(|x| *compressor.get(x).unwrap()).collect();
println!(&quot;{:?}&quot;, compr);    // [0, 1, 2, 3, 4, 3, 2, 1, 0]

let original: Vec&lt;i32&gt; = compr.iter().map(|&amp;i| *reevaluator[i]).collect();
println!(&quot;{:?}&quot;, original); // [1, 2, 4, 7, 9, 7, 4, 2, 1]
<span class="boring">}
</span><span class="boring">
</span><span class="boring">/// compressor[original_value] = compressed_value
</span><span class="boring">/// reevaluator[compressed_value] = original_value
</span><span class="boring">fn compress_value&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (std::collections::BTreeMap&lt;&amp;T, usize&gt;, Vec&lt;&amp;T&gt;) {
</span><span class="boring">    use std::collections::*;
</span><span class="boring">    let compressor: BTreeMap&lt;&amp;T, usize&gt; = {
</span><span class="boring">        let mut sorted: Vec&lt;_&gt; = arr.iter().collect();
</span><span class="boring">        sorted.sort_unstable();
</span><span class="boring">        sorted.dedup();
</span><span class="boring">        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()
</span><span class="boring">    };
</span><span class="boring">    let reevaluator: Vec&lt;&amp;T&gt; = compressor.iter().map(|x| *x.0).collect();
</span><span class="boring">    (compressor, reevaluator)
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code-23"><a class="header" href="#code-23">Code</a></h2>
<pre><code class="language-rust noplayground">/// compressor[original_value] = compressed_value
/// reevaluator[compressed_value] = original_value
fn compress_value&lt;T: Ord&gt;(arr: &amp;[T]) -&gt; (std::collections::BTreeMap&lt;&amp;T, usize&gt;, Vec&lt;&amp;T&gt;) {
    use std::collections::*;
    let compressor: BTreeMap&lt;&amp;T, usize&gt; = {
        let mut sorted: Vec&lt;_&gt; = arr.iter().collect();
        sorted.sort_unstable();
        sorted.dedup();
        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()
    };
    let reevaluator: Vec&lt;&amp;T&gt; = compressor.iter().map(|x| *x.0).collect();
    (compressor, reevaluator)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-increasing-subsequence"><a class="header" href="#longest-increasing-subsequence">Longest Increasing Subsequence</a></h1>
<h2 id="length"><a class="header" href="#length">Length</a></h2>
<pre><code class="language-rust noplayground">fn lis_len(arr: &amp;[i64]) -&gt; usize {
    let mut table: Vec&lt;i64&gt; = vec![arr[0]];
    for &amp;v in arr[1..].iter() {
        let p = table.partition_point(|&amp;x| x &lt; v);
        if p == table.len() {
            table.push(v);
        } else {
            table[p] = v;
        }
    }
    table.len()
}</code></pre>
<h2 id="sequence"><a class="header" href="#sequence">Sequence</a></h2>
<pre><code class="language-rust noplayground">fn lis(arr: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
    let n = arr.len();
    let mut seq: Vec&lt;i64&gt; = Vec::with_capacity(n + 1);
    seq.push(i64::MIN);
    seq.extend(arr.iter().copied());

    let mut back = vec![0usize; n + 1];
    let mut table = vec![0usize];

    for (i, &amp;v) in seq.iter().enumerate().skip(1) {
        let p = table.partition_point(|&amp;x| seq[x] &lt; v);
        if p == table.len() {
            table.push(i);
        } else {
            table[p] = i;
        }
        back[i] = table[p - 1];
    }

    let mut ptr = *table.last().unwrap();
    let mut ans: Vec&lt;i64&gt; = Vec::with_capacity(table.len() - 1);
    while ptr != 0 {
        ans.push(seq[ptr]);
        ptr = back[ptr];
    }

    ans.reverse();
    ans
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mos"><a class="header" href="#mos">Mo's</a></h1>
<h2 id="mos-with-hilbert-curve-optimization"><a class="header" href="#mos-with-hilbert-curve-optimization">Mo's with Hilbert Curve Optimization</a></h2>
<p>Reference: <a href="https://codeforces.com/blog/entry/61203">https://codeforces.com/blog/entry/61203</a></p>
<pre><code class="language-rust noplayground">/// max_n: maximum number of l and r
/// queries: Vec&lt;(id, l, r)&gt;
fn mos_sort(max_n: u32, queries: &amp;[(u32, u32, u32)]) -&gt; Vec&lt;&amp;(u32, u32, u32)&gt; {
    let n_bit = ceil_pow_2(max_n + 1).trailing_zeros();
    let mut arr: Vec&lt;(u64, &amp;(u32, u32, u32))&gt; = queries.iter().map(|q| (0, q)).collect();
    for q in arr.iter_mut() {
        q.0 = hilbert_order(q.1 .1, q.1 .2, n_bit, 0);
    }
    arr.sort_unstable_by_key(|q| q.0);
    arr.into_iter().map(|x| x.1).collect()
}

#[inline(always)]
fn hilbert_order(x: u32, y: u32, pow: u32, rotate: u32) -&gt; u64 {
    if pow == 0 {
        return 0;
    }
    let hpow: u32 = 1 &lt;&lt; (pow - 1);
    let mut seg: u32 = if x &lt; hpow {
        if y &lt; hpow {
            0
        } else {
            3
        }
    } else {
        if y &lt; hpow {
            1
        } else {
            2
        }
    };
    seg = (seg + rotate) &amp; 3;

    let (nx, ny) = (x &amp; (x ^ hpow), y &amp; (y ^ hpow));
    let nrot = rotate + ROTATE_DELTA[seg as usize] &amp; 3;
    let sub_square_size = 1u64 &lt;&lt; (2 * pow - 2);
    let ans = seg as u64 * sub_square_size;
    let add = hilbert_order(nx, ny, pow - 1, nrot);
    if seg == 1 || seg == 2 {
        ans + add
    } else {
        ans + sub_square_size - add - 1
    }
}

const ROTATE_DELTA: [u32; 4] = [3, 0, 0, 1];

#[inline(always)]
fn ceil_pow_2(y: u32) -&gt; u32 {
    let mut x = y;
    while x != (x &amp; ((!x) + 1)) {
        x -= x &amp; ((!x) + 1);
    }
    if x == y {
        x
    } else {
        x &lt;&lt; 1
    }
}</code></pre>
<h2 id="standard-mos"><a class="header" href="#standard-mos">Standard Mo's</a></h2>
<pre><code class="language-rust noplayground">/// queries: Vec&lt;(id, l, r)&gt;
fn mos_sort(queries: &amp;mut [(u32, u32, u32)]) {
    let nsq = isqrt(queries.len() as u32);
    queries.sort_unstable_by(|&amp;(_, l1, r1), &amp;(_, l2, r2)| {
        if l1 / nsq == l2 / nsq {
            r1.cmp(&amp;r2)
        } else {
            (l1 / nsq).cmp(&amp;(l2 / nsq))
        }
    });
}

fn isqrt(s: u32) -&gt; u32 {
    let mut x0 = s / 2;
    if x0 != 0 {
        let mut x1 = (x0 + s / x0) / 2;
        while x1 &lt; x0 {
            x0 = x1;
            x1 = (x0 + s / x0) / 2;
        }
        x0
    } else {
        s
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arbitrary-precision-integer"><a class="header" href="#arbitrary-precision-integer">Arbitrary-Precision Integer</a></h1>
<h2 id="example-22"><a class="header" href="#example-22">Example</a></h2>
<pre><code class="language-rust noplayground">use bigint::*;

let _a = Int::from(0i8);
let b = Int::from(4i16);
let c = Int::from(11i32);

let mut x = Int::from(30i64);
x *= &amp;b;
println!(&quot;{}&quot;, x);

let mut y = Int::from_str(&quot;123456789123456789123456789123456789&quot;).unwrap();
let z = &amp;y * &amp;c;
println!(&quot;{}&quot;, y);</code></pre>
<h2 id="code-24"><a class="header" href="#code-24">Code</a></h2>
<pre><code class="language-rust noplayground">mod bigint {
    use core::{
        fmt::Display,
        num::ParseIntError,
        ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign},
        str::FromStr,
    };

    const CHUNK: usize = 5;
    const TENS: i64 = 100000;

    #[derive(Clone, Default, Debug, PartialEq, Eq)]
    pub struct Uint(Vec&lt;i64&gt;);

    macro_rules! flatten {
        ($uint:expr) =&gt; {
            let mut carry: i64 = 0;
            for i in 0..$uint.0.len() {
                $uint.0[i] += carry;
                carry = $uint.0[i].div_euclid(TENS);
                $uint.0[i] -= carry * TENS;
            }
            while carry != 0 {
                $uint.0.push(carry.rem_euclid(TENS));
                carry = carry.div_euclid(TENS);
            }
            while let Some(&amp;x) = $uint.0.last() {
                if x != 0 {
                    break;
                }
                $uint.0.pop();
            }
        };
    }

    macro_rules! impl_from_for_uint {
        ($($t:ty),*) =&gt; {
            $(
                impl From&lt;$t&gt; for Uint {
                    fn from(x: $t) -&gt; Self {
                        let mut x = Self(vec![x as i64]);
                        flatten!(x);
                        x
                    }
                }
            )*
        };
    }
    impl_from_for_uint!(u8, u16, u32, u64, u128, usize);

    impl FromStr for Uint {
        type Err = ParseIntError;
        fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
            let s = s.trim_start_matches(&quot;0&quot;);
            if s.is_empty() {
                return Ok(Self(vec![]));
            }
            let mut arr: Vec&lt;i64&gt; = Vec::with_capacity(s.len() / CHUNK + 2);
            let mut s = s;
            while s.len() &gt; CHUNK {
                let (l, r) = s.split_at(s.len() - CHUNK);
                arr.push(r.parse()?);
                s = l;
            }
            arr.push(s.parse()?);
            Ok(Self(arr))
        }
    }

    impl Display for Uint {
        fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
            write!(f, &quot;{}&quot;, *self.0.last().unwrap_or(&amp;0))?;
            for &amp;v in self.0.iter().rev().skip(1) {
                write!(f, &quot;{:0CHUNK$}&quot;, v)?;
            }
            Ok(())
        }
    }

    impl PartialOrd for Uint {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;core::cmp::Ordering&gt; {
            use core::cmp::Ordering;
            match self.0.len().cmp(&amp;other.0.len()) {
                Ordering::Equal =&gt; {
                    for i in (0..self.0.len()).rev() {
                        let x = self.0[i].cmp(&amp;other.0[i]);
                        if x != Ordering::Equal {
                            return Some(x);
                        }
                    }
                    Some(Ordering::Equal)
                }
                x =&gt; Some(x),
            }
        }
    }

    impl Ord for Uint {
        fn cmp(&amp;self, other: &amp;Self) -&gt; core::cmp::Ordering {
            use core::cmp::Ordering;
            match self.0.len().cmp(&amp;other.0.len()) {
                Ordering::Equal =&gt; {
                    for i in (0..self.0.len()).rev() {
                        let x = self.0[i].cmp(&amp;other.0[i]);
                        if x != Ordering::Equal {
                            return x;
                        }
                    }
                    Ordering::Equal
                }
                x =&gt; x,
            }
        }
    }

    impl AddAssign&lt;&amp;Uint&gt; for Uint {
        fn add_assign(&amp;mut self, rhs: &amp;Uint) {
            if self.0.len() &lt; rhs.0.len() {
                for i in 0..self.0.len() {
                    self.0[i] += rhs.0[i];
                }
                self.0.extend_from_slice(&amp;rhs.0[self.0.len()..]);
            } else {
                for i in 0..rhs.0.len() {
                    self.0[i] += rhs.0[i];
                }
            }

            flatten!(self);
        }
    }

    impl Add for &amp;Uint {
        type Output = Uint;
        fn add(self, rhs: Self) -&gt; Self::Output {
            let mut c = self.clone();
            c += rhs;
            c
        }
    }

    impl SubAssign&lt;&amp;Uint&gt; for Uint {
        fn sub_assign(&amp;mut self, rhs: &amp;Uint) {
            // Panics if self.len() &lt; rhs.len(): Think it as a underflow error
            for (i, &amp;v) in rhs.0.iter().enumerate() {
                self.0[i] -= v;
            }

            flatten!(self);
        }
    }

    impl Sub for &amp;Uint {
        type Output = Uint;
        fn sub(self, rhs: Self) -&gt; Self::Output {
            let mut c = self.clone();
            c -= rhs;
            c
        }
    }

    const NTT_THRES: usize = 5000;
    const KARAT_THRES: usize = 30;

    impl Mul for &amp;Uint {
        type Output = Uint;
        fn mul(self, rhs: Self) -&gt; Self::Output {
            let max_len = self.0.len().max(rhs.0.len());
            let max_2len = polymul::ceil_pow2(max_len);

            // For performance reasons regarding vector copying, we determine whether to use
            // NTT or not here.
            let mut ans = Uint(if max_2len &gt; NTT_THRES {
                polymul::convolute(&amp;self.0, &amp;rhs.0)
            } else {
                let f: Vec&lt;i64&gt; = self
                    .0
                    .iter()
                    .copied()
                    .chain(core::iter::repeat(0))
                    .take(max_2len)
                    .collect();

                let g: Vec&lt;i64&gt; = rhs
                    .0
                    .iter()
                    .copied()
                    .chain(core::iter::repeat(0))
                    .take(max_2len)
                    .collect();

                polymul::mult_2pow(&amp;f, &amp;g)
            });

            flatten!(ans);
            ans
        }
    }

    impl MulAssign&lt;&amp;Uint&gt; for Uint {
        fn mul_assign(&amp;mut self, rhs: &amp;Uint) {
            let x = &amp;*self * rhs;
            *self = x;
        }
    }

    mod polymul {
        pub fn ceil_pow2(n: usize) -&gt; usize {
            if n == 0 {
                return 0;
            }
            let mut m = n;
            while m != m &amp; (!m + 1) {
                m -= m &amp; (!m + 1);
            }
            if n == m {
                n
            } else {
                m * 2
            }
        }

        pub fn mult_2pow(f: &amp;[i64], g: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
            if f.len() &gt; super::KARAT_THRES {
                return karatsuba(f, g);
            }

            let mut ans = vec![0; 2 * f.len()];
            for (i, &amp;a) in f.iter().enumerate() {
                for (j, &amp;b) in g.iter().enumerate() {
                    ans[i + j] += a * b;
                }
            }

            ans
        }

        // Length of f = Length of g = 2n = 2^(k+1)
        fn karatsuba(f: &amp;[i64], g: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
            if f.len() == 1 {
                return vec![f[0] * g[0]];
            }
            let n = f.len() / 2;
            let k = n.trailing_zeros();
            debug_assert_eq!(n, 1 &lt;&lt; k);

            let (fl, fr) = (&amp;f[..n], &amp;f[n..]);
            let (gl, gr) = (&amp;g[..n], &amp;g[n..]);

            let flgl = mult_2pow(fl, gl);
            let frgr = mult_2pow(fr, gr);

            let fsum: Vec&lt;_&gt; = fl.iter().zip(fr.iter()).map(|(&amp;a, &amp;b)| (a + b)).collect();
            let gsum: Vec&lt;_&gt; = gl.iter().zip(gr.iter()).map(|(&amp;a, &amp;b)| (a + b)).collect();
            let fsgs = mult_2pow(&amp;fsum, &amp;gsum);

            let mut ans: Vec&lt;_&gt; = flgl.iter().copied().chain(frgr.iter().copied()).collect();
            for i in 0..fsgs.len() {
                ans[i + n] += fsgs[i];
            }
            for (i, v) in flgl
                .iter()
                .zip(frgr.iter())
                .map(|(&amp;a, &amp;b)| (a + b))
                .enumerate()
            {
                ans[i + n] -= v;
            }

            ans
        }

        const P2INV: i64 = 253522377;

        pub fn convolute(a: &amp;[i64], b: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
            let c1 = ntt1::convolute(a, b);
            let c2 = ntt2::convolute(a, b);

            c1.into_iter()
                .zip(c2.into_iter())
                .map(|(a1, a2)| {
                    let j = ((a1 + ntt1::NTT_P as i64 - a2) * P2INV) % ntt1::NTT_P as i64;
                    ntt2::NTT_P as i64 * j + a2
                })
                .collect()
        }

        // FFT_constname convention following https://algoshitpo.github.io/2020/05/20/fft-ntt/
        macro_rules! impl_ntt {
            ($modname:ident, $nttp:expr, $ntta:expr, $nttb:expr, $nttw:expr) =&gt; {
                mod $modname {
                    pub const NTT_P: u64 = $nttp;
                    const NTT_A: u64 = $ntta;
                    const NTT_B: u32 = $nttb;
                    const NTT_W: u64 = $nttw;

                    fn ceil_pow2(n: usize) -&gt; usize {
                        let mut x: usize = 0;
                        while (1 &lt;&lt; x) &lt; n {
                            x += 1;
                        }
                        x
                    }

                    pub fn convolute(a: &amp;[i64], b: &amp;[i64]) -&gt; Vec&lt;i64&gt; {
                        let nlen = 1 &lt;&lt; ceil_pow2(a.len() + b.len());
                        let mut arr = vec![0; nlen];
                        let mut brr = vec![0; nlen];
                        for (i, &amp;a) in a.iter().enumerate() {
                            arr[i] = a as u64;
                        }
                        for (i, &amp;b) in b.iter().enumerate() {
                            brr[i] = b as u64;
                        }

                        inplace_ntt(&amp;mut arr);
                        inplace_ntt(&amp;mut brr);
                        let mut crr: Vec&lt;_&gt; =
                            arr.iter().zip(brr.iter()).map(|(&amp;a, &amp;b)| a * b).collect();
                        inplace_intt(&amp;mut crr);
                        crr.iter().map(|&amp;x| x as i64).collect()
                    }

                    #[inline(always)]
                    fn rem_pow(mut base: u64, exp: u64) -&gt; u64 {
                        let mut result = 1u64;
                        for exp in core::iter::successors(Some(exp), |x| Some(x &gt;&gt; 1))
                            .take_while(|&amp;v| v != 0)
                        {
                            if exp &amp; 1 != 0 {
                                result *= base;
                                result %= NTT_P;
                            }
                            base *= base;
                            base %= NTT_P;
                        }
                        result
                    }

                    // unity(n, 1) ** (1&lt;&lt;n) = 1
                    fn unity(n: u32, k: u64) -&gt; u64 {
                        rem_pow(rem_pow(NTT_W, NTT_A), k &lt;&lt; (NTT_B - n))
                    }

                    fn recip(x: u64) -&gt; u64 {
                        rem_pow(x, NTT_P - 2)
                    }

                    // Reverses k trailing bits of n
                    fn reverse_trailing_bits(n: usize, k: u32) -&gt; usize {
                        let mut r: usize = 0;
                        for i in 0..k {
                            r |= ((n &gt;&gt; i) &amp; 1) &lt;&lt; (k - i - 1);
                        }
                        r
                    }

                    fn inplace_ntt(arr: &amp;mut [u64]) {
                        let n: usize = arr.len();
                        let k = n.trailing_zeros();
                        assert_eq!(n, 1 &lt;&lt; k);

                        for i in 0..n {
                            let j = reverse_trailing_bits(i, k);
                            if i &lt; j {
                                arr.swap(i, j);
                            }
                        }

                        for x in 0..k {
                            let base: u64 = unity(x + 1, 1);
                            let s = 1 &lt;&lt; x;
                            for i in (0..n).step_by(s &lt;&lt; 1) {
                                let mut mult: u64 = 1;
                                for j in 0..s {
                                    let tmp = (arr[i + j + s] * mult) % NTT_P;
                                    arr[i + j + s] = (arr[i + j] + NTT_P - tmp) % NTT_P;
                                    arr[i + j] = (arr[i + j] + tmp) % NTT_P;
                                    mult *= base;
                                    mult %= NTT_P;
                                }
                            }
                        }
                    }

                    fn inplace_intt(arr: &amp;mut [u64]) {
                        let n: usize = arr.len();
                        let k = n.trailing_zeros();
                        assert_eq!(n, 1 &lt;&lt; k);

                        for i in 0..n {
                            let j = reverse_trailing_bits(i, k);
                            if i &lt; j {
                                arr.swap(i, j);
                            }
                        }

                        for x in 0..k {
                            let base: u64 = recip(unity(x + 1, 1));
                            let s = 1 &lt;&lt; x;
                            for i in (0..n).step_by(s &lt;&lt; 1) {
                                let mut mult: u64 = 1;
                                for j in 0..s {
                                    let tmp = (arr[i + j + s] * mult) % NTT_P;
                                    arr[i + j + s] = (arr[i + j] + NTT_P - tmp) % NTT_P;
                                    arr[i + j] = (arr[i + j] + tmp) % NTT_P;
                                    mult *= base;
                                    mult %= NTT_P;
                                }
                            }
                        }

                        let r = recip(n as u64);
                        for f in arr.iter_mut() {
                            *f *= r;
                            *f %= NTT_P;
                        }
                    }
                }
            };
        }

        impl_ntt!(ntt1, 2281701377, 17, 27, 3);
        impl_ntt!(ntt2, 998244353, 119, 23, 3);
    }

    #[derive(Clone, Copy, PartialEq, Eq, Debug)]
    enum Sign {
        Neg,
        Pos, // Includes 0
    }
    use Sign::*;

    #[derive(Clone, Debug, PartialEq, Eq)]
    pub struct Int {
        sign: Sign,
        nat: Uint,
    }

    macro_rules! impl_from_for_int {
        ($($u:ty, $s:ty);*) =&gt; {
            $(
                impl From&lt;$u&gt; for Int {
                    fn from(x: $u) -&gt; Self {
                        Self { sign: Pos, nat: x.into() }
                    }
                }
                impl From&lt;$s&gt; for Int {
                    fn from(x: $s) -&gt; Self {
                        if x &lt; 0 {
                            Self { sign: Neg, nat: ((-x) as $u).into() }
                        } else {
                            Self { sign: Pos, nat: (x as $u).into() }
                        }
                    }
                }
            )*
        };
    }

    impl_from_for_int!(u8, i8; u16, i16; u32, i32; u64, i64; u128, i128; usize, isize);

    impl FromStr for Int {
        type Err = ParseIntError;
        fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
            if s.len() == 0 {
                panic!(&quot;Empty string - TODO: Add a proper error propagation&quot;);
            }
            let mut x = match s.strip_prefix(&quot;-&quot;) {
                Some(t) =&gt; Self {
                    sign: Neg,
                    nat: t.parse()?,
                },
                None =&gt; Self {
                    sign: Pos,
                    nat: s.parse()?,
                },
            };
            if x.sign == Neg &amp;&amp; x.nat.0.len() == 0 {
                x.sign = Pos;
            }
            Ok(x)
        }
    }

    impl Display for Int {
        fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
            if let Neg = self.sign {
                write!(f, &quot;-&quot;)?;
            }
            write!(f, &quot;{}&quot;, self.nat)
        }
    }

    impl PartialOrd for Int {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;core::cmp::Ordering&gt; {
            use core::cmp::Ordering;
            match (self.sign, other.sign) {
                (Neg, Neg) =&gt; other.nat.partial_cmp(&amp;self.nat),
                (Neg, Pos) =&gt; Some(Ordering::Less),
                (Pos, Neg) =&gt; Some(Ordering::Greater),
                (Pos, Pos) =&gt; self.nat.partial_cmp(&amp;other.nat),
            }
        }
    }

    impl Ord for Int {
        fn cmp(&amp;self, other: &amp;Self) -&gt; core::cmp::Ordering {
            use core::cmp::Ordering;
            match (self.sign, other.sign) {
                (Neg, Neg) =&gt; other.nat.cmp(&amp;self.nat),
                (Neg, Pos) =&gt; Ordering::Less,
                (Pos, Neg) =&gt; Ordering::Greater,
                (Pos, Pos) =&gt; self.nat.cmp(&amp;other.nat),
            }
        }
    }

    impl AddAssign&lt;&amp;Int&gt; for Int {
        fn add_assign(&amp;mut self, rhs: &amp;Int) {
            match (self.sign, rhs.sign) {
                (Neg, Neg) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
                (Neg, Pos) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Pos;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Neg) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Neg;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Pos) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
            }
        }
    }

    impl Add for &amp;Int {
        type Output = Int;
        fn add(self, rhs: Self) -&gt; Self::Output {
            let mut ans = self.clone();
            ans += rhs;
            ans
        }
    }

    impl SubAssign&lt;&amp;Int&gt; for Int {
        fn sub_assign(&amp;mut self, rhs: &amp;Int) {
            match (self.sign, rhs.sign) {
                (Neg, Pos) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
                (Neg, Neg) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Pos;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Pos) =&gt; {
                    if self.nat &gt;= rhs.nat {
                        self.nat -= &amp;rhs.nat;
                    } else {
                        let c = &amp;rhs.nat - &amp;self.nat;
                        self.nat = c;
                        self.sign = Neg;
                    }
                    if self.nat.0.len() == 0 {
                        self.sign = Pos;
                    }
                }
                (Pos, Neg) =&gt; {
                    self.nat += &amp;rhs.nat;
                }
            }
        }
    }

    impl Sub for &amp;Int {
        type Output = Int;
        fn sub(self, rhs: Self) -&gt; Self::Output {
            let mut ans = self.clone();
            ans -= &amp;rhs;
            ans
        }
    }

    impl Mul for &amp;Int {
        type Output = Int;
        fn mul(self, rhs: Self) -&gt; Self::Output {
            let x = &amp;self.nat * &amp;rhs.nat;
            if x.0.len() == 0 || self.sign == rhs.sign {
                Int { sign: Pos, nat: x }
            } else {
                Int { sign: Neg, nat: x }
            }
        }
    }

    impl MulAssign&lt;&amp;Int&gt; for Int {
        fn mul_assign(&amp;mut self, rhs: &amp;Int) {
            let x = &amp;self.nat * &amp;rhs.nat;
            self.nat = x;
            if self.nat.0.len() == 0 || self.sign == rhs.sign {
                self.sign = Pos;
            } else {
                self.sign = Neg;
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-io"><a class="header" href="#fast-io">Fast IO</a></h1>
<ul>
<li>
<p><code>get_input() -&gt; &amp;'static str</code> reads every input from stdin, leaks it and returns it as <code>&amp;'static str</code>.
The function leaks the string because it's easier to handle input in CP this way.</p>
</li>
<li>
<p><code>Tokenizer</code> tokenizes a string based on a function its fed when initialized.</p>
<ul>
<li>
<p>The default template initializes a tokenizer <code>sc</code> with <code>Tokenizer::new(input_str, |s| s.split_ascii_whitespace())</code>.
This means that <code>sc</code> tokenizes the input by ascii whitespace.
If you want to tokenize the input with non-ascii whitespace as well, then change <code>split_ascii_whitespace</code> to <code>split_whitespace</code>.
If you want a tokenizer which splits a string by lines, then change <code>split_ascii_whitespace</code> to <code>lines</code>.</p>
</li>
<li>
<p><code>Tokenizer::next(&amp;mut Self) -&gt; T</code> parses next token into <code>T</code> and returns it. If there's no tokens left or it fails to parse, the program panics.</p>
</li>
<li>
<p><code>Tokenizer::next_str(&amp;mut self) -&gt; &amp;str</code> returns next token.</p>
</li>
<li>
<p><code>Tokenizer::next_ok(&amp;mut self) -&gt; Result&lt;T, InputError&gt;</code> parses the next token into <code>T</code>. If there's no tokens left in the string, it returns <code>Err(InputExhaust)</code>.
If it fails to parse, it returns <code>Err(ParseError(token))</code>. Otherwise, it returns the parsed <code>T</code> value.</p>
</li>
<li>
<p><code>Tokenizer::next_str_ok(&amp;mut self) -&gt; Result&lt;T, InputError&gt;</code> returns next token if there's any. Otherwise, it returns <code>Err(InputExhaust)</code>.</p>
</li>
<li>
<p><code>Tokenizer::next_iter(&amp;mut self) -&gt; impl Iterator&lt;Item = T&gt;</code> returns an iterator repeatedly consumes and parses tokens into <code>T</code>.
If <code>Tokenizer</code> meets a token that can't be parsed into <code>T</code>, it just skips to the next token until it can parse it into <code>T</code>.
The iterator ends only when the entire tokens are consumed. This behavior can be used for reading up to EOF, or blocked by <code>take</code> method for reading given number of tokens.</p>
</li>
</ul>
</li>
</ul>
<h2 id="example-23"><a class="header" href="#example-23">Example</a></h2>
<pre><code class="language-rust noplayground">let n: usize = sc.next();
let arr: Vec&lt;u64&gt; = sc.next_iter().take(m).collect();
let (m, k): (u32, u64) = sc.next();
let text = sc.next_str();
outln!(&quot;{:?}&quot;, [m, k]);

while let Ok(n @ ..1) = sc.next_ok::&lt;u32&gt;() {
    println!(&quot;{}&quot;, n);
    if sc.next_str_ok().is_none() {
        outln!(&quot;EOF&quot;);
    }
}</code></pre>
<h2 id="code-25"><a class="header" href="#code-25">Code</a></h2>
<h3 id="for-recent-rust-versions-almost-every-ojs-except-atcoder"><a class="header" href="#for-recent-rust-versions-almost-every-ojs-except-atcoder">For Recent Rust versions (Almost every OJs except AtCoder)</a></h3>
<pre><code class="language-rust noplayground">#![no_main]

#[no_mangle]
fn main() -&gt; i32 {
    // FastIO
    use fastio::*;
    let input_str = get_input();
    let mut sc = Tokenizer::new(input_str, |s| s.split_ascii_whitespace());
    use std::io::{stdout, BufWriter, Write};
    let stdout = stdout();
    let wr = &amp;mut BufWriter::new(stdout.lock());

    // FastIO Macros
    macro_rules! out { ($($arg:tt)*) =&gt; { write!(wr, $($arg)*).ok(); }; }
    macro_rules! outln { ($($arg:tt)*) =&gt; { writeln!(wr, $($arg)*).ok(); }; }

    // Main

    wr.flush().unwrap();
    0
}

#[allow(unused)]
mod fastio {
    use std::{fmt, io, num::*, slice::*, str::*};

    #[link(name = &quot;c&quot;)]
    extern &quot;C&quot; {}

    pub fn get_input() -&gt; &amp;'static str {
        let buf = io::read_to_string(io::stdin()).unwrap();
        Box::leak(buf.into_boxed_str())
    }

    pub enum InputError&lt;'t&gt; {
        InputExhaust,
        ParseError(&amp;'t str),
    }
    use InputError::*;

    impl&lt;'t&gt; fmt::Debug for InputError&lt;'t&gt; {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            match self {
                InputExhaust =&gt; f.debug_struct(&quot;InputExhaust&quot;).finish(),
                ParseError(s) =&gt; f.debug_struct(&quot;ParseError&quot;).field(&quot;str&quot;, s).finish(),
            }
        }
    }

    pub trait Atom: Sized {
        fn parse_from(s: &amp;str) -&gt; Result&lt;Self, InputError&gt;;
    }

    pub trait IterParse: Sized {
        fn parse_from&lt;'s, 't: 's, It&gt;(it: &amp;'s mut It) -&gt; Result&lt;Self, InputError&lt;'t&gt;&gt;
        where
            It: Iterator&lt;Item = &amp;'t str&gt;;
    }

    macro_rules! impl_trait_for_fromstr {
        ($($t:ty) *) =&gt; { $(
            impl Atom for $t { fn parse_from(s: &amp;str) -&gt; Result&lt;Self, InputError&gt; { s.parse().map_err(|_| ParseError(s)) } }
            impl IterParse for $t {
                fn parse_from&lt;'s, 't: 's, It&gt;(it: &amp;'s mut It) -&gt; Result&lt;Self, InputError&lt;'t&gt;&gt; where It: Iterator&lt;Item = &amp;'t str&gt; {
                    it.next().map_or( Err(InputExhaust), &lt;Self as Atom&gt;::parse_from )
                }
            }
        )* };
    }

    impl_trait_for_fromstr!(bool char String);
    impl_trait_for_fromstr!(f32 f64 i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize);
    impl_trait_for_fromstr!(NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize);
    impl_trait_for_fromstr!(NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize);

    macro_rules! impl_iterparse_for_tuple {
        ($($t:ident) *) =&gt; {
            impl&lt;$($t),*&gt; IterParse for ($($t),*) where $($t: IterParse),* {
                fn parse_from&lt;'s, 't: 's, It&gt;(it: &amp;'s mut It) -&gt; Result&lt;Self, InputError&lt;'t&gt;&gt; where It: Iterator&lt;Item = &amp;'t str&gt; {
                    Ok(( $($t::parse_from(it)?),* ))
                }
            }
        };
    }

    impl_iterparse_for_tuple!();
    impl_iterparse_for_tuple!(A B);
    impl_iterparse_for_tuple!(A B C);
    impl_iterparse_for_tuple!(A B C D);
    impl_iterparse_for_tuple!(A B C D E);
    impl_iterparse_for_tuple!(A B C D E F);
    impl_iterparse_for_tuple!(A B C D E F G);
    impl_iterparse_for_tuple!(A B C D E F G H);
    impl_iterparse_for_tuple!(A B C D E F G H I);
    impl_iterparse_for_tuple!(A B C D E F G H I J);
    impl_iterparse_for_tuple!(A B C D E F G H I J K);
    impl_iterparse_for_tuple!(A B C D E F G H I J K L);
    impl_iterparse_for_tuple!(A B C D E F G H I J K L M);

    pub struct Tokenizer&lt;It&gt; {
        it: It,
    }

    impl&lt;'arg, 'str: 'arg, It&gt; Tokenizer&lt;It&gt; {
        pub fn new(s: &amp;'str str, split: impl FnOnce(&amp;'arg str) -&gt; It) -&gt; Self {
            Self { it: split(s) }
        }
    }

    impl&lt;'t, It&gt; Tokenizer&lt;It&gt;
    where
        It: Iterator&lt;Item = &amp;'t str&gt;,
    {
        pub fn next&lt;T: IterParse&gt;(&amp;mut self) -&gt; T {
            T::parse_from(&amp;mut self.it).unwrap()
        }
        pub fn next_str(&amp;mut self) -&gt; &amp;'t str {
            self.it.next().unwrap()
        }
        pub fn next_ok&lt;T: IterParse&gt;(&amp;mut self) -&gt; Result&lt;T, InputError&lt;'t&gt;&gt; {
            T::parse_from(&amp;mut self.it)
        }
        pub fn next_str_ok(&amp;mut self) -&gt; Option&lt;&amp;'t str&gt; {
            self.it.next()
        }
        pub fn next_iter&lt;T: IterParse&gt;(&amp;mut self) -&gt; impl Iterator&lt;Item = T&gt; + '_ {
            std::iter::repeat_with(move || self.next_ok().ok()).map_while(|x| x)
        }
    }
}</code></pre>
<h3 id="for-older-versions-of-rust-atcoder"><a class="header" href="#for-older-versions-of-rust-atcoder">For Older Versions of Rust (AtCoder)</a></h3>
<pre><code class="language-rust noplayground">#![no_main]

#[no_mangle]
fn main() -&gt; i32 {
    // FastIO
    use fastio::*;
    let input_str = get_input();
    let mut sc = Tokenizer::new(input_str, |s| s.split_ascii_whitespace());
    use std::io::{stdout, BufWriter, Write};
    let stdout = stdout();
    let wr = &amp;mut BufWriter::new(stdout.lock());

    // FastIO Macros
    macro_rules! out { ($($arg:tt)*) =&gt; { write!(wr, $($arg)*).ok(); }; }
    macro_rules! outln { ($($arg:tt)*) =&gt; { writeln!(wr, $($arg)*).ok(); }; }

    // Main

    wr.flush().unwrap();
    0
}

#[allow(unused)]
mod fastio {
    use std::{fmt, io, num::*, slice::*, str::*};

    #[link(name = &quot;c&quot;)]
    extern &quot;C&quot; {}

    pub fn get_input() -&gt; &amp;'static str {
        use io::Read;
        let mut buf = String::new();
        io::stdin().read_to_string(&amp;mut buf);
        Box::leak(buf.into_boxed_str())
    }

    pub enum InputError&lt;'t&gt; {
        InputExhaust,
        ParseError(&amp;'t str),
    }
    use InputError::*;

    impl&lt;'t&gt; fmt::Debug for InputError&lt;'t&gt; {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            match self {
                InputExhaust =&gt; f.debug_struct(&quot;InputExhaust&quot;).finish(),
                ParseError(s) =&gt; f.debug_struct(&quot;ParseError&quot;).field(&quot;str&quot;, s).finish(),
            }
        }
    }

    pub trait Atom: Sized {
        fn parse_from(s: &amp;str) -&gt; Result&lt;Self, InputError&gt;;
    }

    pub trait IterParse: Sized {
        fn parse_from&lt;'s, 't: 's, It&gt;(it: &amp;'s mut It) -&gt; Result&lt;Self, InputError&lt;'t&gt;&gt;
        where
            It: Iterator&lt;Item = &amp;'t str&gt;;
    }

    macro_rules! impl_trait_for_fromstr {
        ($($t:ty) *) =&gt; { $(
            impl Atom for $t { fn parse_from(s: &amp;str) -&gt; Result&lt;Self, InputError&gt; { s.parse().map_err(|_| ParseError(s)) } }
            impl IterParse for $t {
                fn parse_from&lt;'s, 't: 's, It&gt;(it: &amp;'s mut It) -&gt; Result&lt;Self, InputError&lt;'t&gt;&gt; where It: Iterator&lt;Item = &amp;'t str&gt; {
                    it.next().map_or( Err(InputExhaust), &lt;Self as Atom&gt;::parse_from )
                }
            }
        )* };
    }

    impl_trait_for_fromstr!(bool char String);
    impl_trait_for_fromstr!(f32 f64 i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize);
    impl_trait_for_fromstr!(NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize);
    impl_trait_for_fromstr!(NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize);

    macro_rules! impl_iterparse_for_tuple {
        ($($t:ident) *) =&gt; {
            impl&lt;$($t),*&gt; IterParse for ($($t),*) where $($t: IterParse),* {
                fn parse_from&lt;'s, 't: 's, It&gt;(it: &amp;'s mut It) -&gt; Result&lt;Self, InputError&lt;'t&gt;&gt; where It: Iterator&lt;Item = &amp;'t str&gt; {
                    Ok(( $($t::parse_from(it)?),* ))
                }
            }
        };
    }

    impl_iterparse_for_tuple!();
    impl_iterparse_for_tuple!(A B);
    impl_iterparse_for_tuple!(A B C);
    impl_iterparse_for_tuple!(A B C D);
    impl_iterparse_for_tuple!(A B C D E);
    impl_iterparse_for_tuple!(A B C D E F);
    impl_iterparse_for_tuple!(A B C D E F G);
    impl_iterparse_for_tuple!(A B C D E F G H);
    impl_iterparse_for_tuple!(A B C D E F G H I);
    impl_iterparse_for_tuple!(A B C D E F G H I J);
    impl_iterparse_for_tuple!(A B C D E F G H I J K);
    impl_iterparse_for_tuple!(A B C D E F G H I J K L);
    impl_iterparse_for_tuple!(A B C D E F G H I J K L M);

    pub struct Tokenizer&lt;It&gt; {
        it: It,
    }

    impl&lt;'arg, 'str: 'arg, It&gt; Tokenizer&lt;It&gt; {
        pub fn new(s: &amp;'str str, split: impl FnOnce(&amp;'arg str) -&gt; It) -&gt; Self {
            Self { it: split(s) }
        }
    }

    impl&lt;'t, It&gt; Tokenizer&lt;It&gt;
    where
        It: Iterator&lt;Item = &amp;'t str&gt;,
    {
        pub fn next&lt;T: IterParse&gt;(&amp;mut self) -&gt; T {
            T::parse_from(&amp;mut self.it).unwrap()
        }
        pub fn next_str(&amp;mut self) -&gt; &amp;'t str {
            self.it.next().unwrap()
        }
        pub fn next_ok&lt;T: IterParse&gt;(&amp;mut self) -&gt; Result&lt;T, InputError&lt;'t&gt;&gt; {
            T::parse_from(&amp;mut self.it)
        }
        pub fn next_str_ok(&amp;mut self) -&gt; Option&lt;&amp;'t str&gt; {
            self.it.next()
        }
        pub fn next_iter&lt;'s, T: IterParse&gt;(&amp;'s mut self) -&gt; impl Iterator&lt;Item = T&gt; + '_
        where
            't: 's,
        {
            std::iter::repeat_with(move || self.next_ok())
                .take_while(|x| x.is_ok())
                .flatten()
        }
    }
}</code></pre>
<h3 id="with-faster-print-old"><a class="header" href="#with-faster-print-old">With faster print (Old)</a></h3>
<pre><code class="language-rust noplayground">fn main() {
    // FastIO
    use fastio::*;
    let input_str = get_input();
    let mut sc: Scanner&lt;_&gt; = Scanner::tokenize(input_str);
    let mut out = Flusher::with_capacity(1 &lt;&lt; 18);

    // FastIO Macros
    macro_rules! next {
        () =&gt; { sc.next() };
        (str) =&gt; { sc.next_str() };
        ($($t:ty) +) =&gt; { ($(sc.next::&lt;$t&gt;()),+) };
    }
    macro_rules! out { ($($arg:tt),*) =&gt; {$( $arg.push_num(&amp;mut out); out.buf.push(b' '); )*}; }
    macro_rules! outln { ($($arg:tt),*) =&gt; { out!($($arg),*); out.buf.push(b'\n'); } }

    // Main
    let n: usize = next!();
    outln!(n);
}

mod fastio {
    use std::io::{stdout, Write};

    extern &quot;C&quot; {
        fn mmap(addr: usize, len: usize, p: i32, f: i32, fd: i32, o: i64) -&gt; *mut u8;
        fn fstat(fd: i32, stat: *mut usize) -&gt; i32;
    }

    pub fn get_input() -&gt; &amp;'static str {
        let mut stat = [0; 20];
        unsafe { fstat(0, (&amp;mut stat).as_mut_ptr()) };
        let buffer = unsafe { mmap(0, stat[6], 1, 2, 0, 0) };
        unsafe { std::str::from_utf8_unchecked(std::slice::from_raw_parts(buffer, stat[6])) }
    }

    pub struct Scanner&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; {
        it: I,
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::SplitAsciiWhitespace&lt;'a&gt;&gt; {
        pub fn tokenize(s: &amp;'a str) -&gt; Self {
            Self {
                it: s.split_ascii_whitespace(),
            }
        }
    }

    impl&lt;'a&gt; Scanner&lt;'a, std::str::Lines&lt;'a&gt;&gt; {
        pub fn lines(s: &amp;'a str) -&gt; Self {
            Self { it: s.lines() }
        }
    }

    impl&lt;'a, I: Iterator&lt;Item = &amp;'a str&gt;&gt; Scanner&lt;'a, I&gt; {
        #[inline(always)]
        pub fn next&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; T {
            self.it.next().unwrap().parse().ok().unwrap()
        }
        #[inline(always)]
        pub fn next_str(&amp;mut self) -&gt; &amp;'a str {
            self.it.next().unwrap()
        }
        #[inline(always)]
        pub fn next_option&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; Option&lt;T&gt; {
            self.it.next().and_then(|s| s.parse().ok())
        }
        #[inline(always)]
        pub fn next_str_option(&amp;mut self) -&gt; Option&lt;&amp;'a str&gt; {
            self.it.next()
        }
    }

    pub struct Flusher {
        pub buf: Vec&lt;u8&gt;,
    }

    impl Flusher {
        pub fn with_capacity(cap: usize) -&gt; Self {
            Self {
                buf: Vec::with_capacity(cap),
            }
        }
    }

    impl Drop for Flusher {
        fn drop(&amp;mut self) {
            stdout().write_all(&amp;self.buf).ok();
        }
    }

    pub trait PushPrint {
        fn push_num(self, wr: &amp;mut Flusher);
    }

    impl PushPrint for &amp;str {
        fn push_num(self, wr: &amp;mut Flusher) {
            wr.buf.extend_from_slice(self.as_bytes());
        }
    }

    macro_rules! impl_pushprint {
        ($($i:ty;$u:ty) *) =&gt; {
            $(
                impl PushPrint for $i {
                    fn push_num(self, wr: &amp;mut Flusher) {
                        if self &lt; 0 {
                            wr.buf.push(b'-');
                            ((-self) as $u).push_num(wr);
                        } else {
                            (self as $u).push_num(wr);
                        }
                    }
                }

                impl PushPrint for $u {
                    fn push_num(self, wr: &amp;mut Flusher) {
                        if self &gt;= 10 {
                            (self / 10).push_num(wr);
                        }
                        wr.buf.push((self % 10) as u8 + b'0');
                    }
                }
            )*
        };
    }

    impl_pushprint!(i8;u8 i16;u16 i32;u32 i64;u64 i128;u128 isize;usize);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<pre><code class="language-rust noplayground">macro_rules! count_tts {
    () =&gt; { 0 };
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 };
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 };
}

// let map: HashMap&lt;i64, i64&gt; = hashmap![1,1; 2,2; 3,3];
macro_rules! hashmap {
    ($($k:expr,$v:expr);*) =&gt; {{
        let mut map = HashMap::with_capacity(count_tts![$($k )*]);
        $( map.insert($k, $v); )*
        map
    }}
}</code></pre>
<h2 id="conversion-between-enum-and-u32"><a class="header" href="#conversion-between-enum-and-u32">Conversion between Enum and <code>u32</code></a></h2>
<p>Macro from <a href="https://stackoverflow.com/questions/28028854/how-do-i-match-enum-values-with-an-integer">https://stackoverflow.com/questions/28028854/how-do-i-match-enum-values-with-an-integer</a>.</p>
<h3 id="example-24"><a class="header" href="#example-24">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::convert::{TryFrom, TryInto};
</span><span class="boring">macro_rules! back_to_enum {
</span><span class="boring">    {$(#[$meta:meta])* $vis:vis enum $name:ident {
</span><span class="boring">        $($(#[$vmeta:meta])* $vname:ident $(= $val:expr)?,)*
</span><span class="boring">    }} =&gt; {
</span><span class="boring">        $(#[$meta])*
</span><span class="boring">        $vis enum $name {
</span><span class="boring">            $($(#[$vmeta])* $vname $(= $val)?,)*
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl TryFrom&lt;u32&gt; for $name {
</span><span class="boring">            type Error = ();
</span><span class="boring">
</span><span class="boring">            fn try_from(v: u32) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">                match v {
</span><span class="boring">                    $(x if x == $name::$vname as u32 =&gt; Ok($name::$vname),)*
</span><span class="boring">                    _ =&gt; Err(()),
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>back_to_enum! {
    #[derive(Clone, Copy, Debug)]
    enum Number {
        Zero,
        One,
        Two,
    }
}

<span class="boring">fn main() {
</span>let i: u32 = 1;
let n: Number = i.try_into().unwrap();
println!(&quot;{:?}&quot;, n);  // One
let i = n as i32;
println!(&quot;{}&quot;, i);    // 1
<span class="boring">}</span></code></pre></pre>
<h3 id="code-26"><a class="header" href="#code-26">Code</a></h3>
<pre><code class="language-rust noplayground">use std::convert::{TryFrom, TryInto};
macro_rules! back_to_enum {
    {$(#[$meta:meta])* $vis:vis enum $name:ident {
        $($(#[$vmeta:meta])* $vname:ident $(= $val:expr)?,)*
    }} =&gt; {
        $(#[$meta])*
        $vis enum $name {
            $($(#[$vmeta])* $vname $(= $val)?,)*
        }
        impl TryFrom&lt;u32&gt; for $name {
            type Error = ();
            fn try_from(v: u32) -&gt; Result&lt;Self, Self::Error&gt; {
                match v {
                    $(x if x == $name::$vname as u32 =&gt; Ok($name::$vname),)*
                    _ =&gt; Err(()),
                }
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zeroone-trait-deprecated"><a class="header" href="#zeroone-trait-deprecated">Zero/One Trait (Deprecated)</a></h1>
<p>This trait was used for representing numeric values, but the author has learned that <code>Into</code> and <code>From</code> traits exist, hence this trait is now deprecated. Any other templates which includes or requires to include this trait will be fixed soon.</p>
<pre><code class="language-rust noplayground">pub trait ZeroOne: Sized + Copy {
    fn zero() -&gt; Self;
    fn one() -&gt; Self;
}

macro_rules! impl_zero_one {
    ($($ty:ty) *) =&gt; { $(
        impl ZeroOne for $ty {
            #[inline(always)]
            fn one() -&gt; Self {1}
            #[inline(always)]
            fn zero() -&gt; Self {0}
        }
    )+ };
}

impl_zero_one!(isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128);</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
