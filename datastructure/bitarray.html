<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js nord_light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bitset - Rust Snippets for Competitive Programming</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "nord_dark" : "nord_light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('nord_light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Algebra</li><li class="chapter-item expanded "><a href="../algebra/gcd.html"><strong aria-hidden="true">1.</strong> GCD, LCM</a></li><li class="chapter-item expanded "><a href="../algebra/extgcd.html"><strong aria-hidden="true">2.</strong> Extended Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="../algebra/crt.html"><strong aria-hidden="true">3.</strong> Chinese Remainder Theorem</a></li><li class="chapter-item expanded "><a href="../algebra/millerrabin.html"><strong aria-hidden="true">4.</strong> Deterministic Miller-Rabin Primality Test</a></li><li class="chapter-item expanded "><a href="../algebra/pollardrho.html"><strong aria-hidden="true">5.</strong> Pollard's Rho Algorithm</a></li><li class="chapter-item expanded "><a href="../algebra/ntt.html"><strong aria-hidden="true">6.</strong> Number Theoretic Transform</a></li><li class="chapter-item expanded affix "><li class="part-title">Numerical Algorithms</li><li class="chapter-item expanded "><a href="../numerical/isqrt.html"><strong aria-hidden="true">7.</strong> Integer Square Root</a></li><li class="chapter-item expanded "><a href="../numerical/sieve.html"><strong aria-hidden="true">8.</strong> Sieve</a></li><li class="chapter-item expanded "><a href="../numerical/linrec/intro.html"><strong aria-hidden="true">9.</strong> Linear Recurrence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../numerical/linrec/berlekamp.html"><strong aria-hidden="true">9.1.</strong> Berlekamp-Massey</a></li><li class="chapter-item expanded "><a href="../numerical/linrec/kitamasa.html"><strong aria-hidden="true">9.2.</strong> Kitamasa</a></li><li class="chapter-item expanded "><a href="../numerical/linrec/bostanmori.html"><strong aria-hidden="true">9.3.</strong> Bostan-Mori</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Data Structures</li><li class="chapter-item expanded "><a href="../datastructure/bitarray.html" class="active"><strong aria-hidden="true">10.</strong> Bitset</a></li><li class="chapter-item expanded "><a href="../datastructure/segtree/intro.html"><strong aria-hidden="true">11.</strong> Segment Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../datastructure/segtree/segtree.html"><strong aria-hidden="true">11.1.</strong> Segment Tree</a></li><li class="chapter-item expanded "><a href="../datastructure/segtree/fenwick.html"><strong aria-hidden="true">11.2.</strong> Fenwick Tree</a></li><li class="chapter-item expanded "><a href="../datastructure/segtree/lazyseg.html"><strong aria-hidden="true">11.3.</strong> Lazy Segment Tree</a></li></ol></li><li class="chapter-item expanded "><a href="../datastructure/rope.html"><strong aria-hidden="true">12.</strong> Rope</a></li><li class="chapter-item expanded affix "><li class="part-title">Graphs</li><li class="chapter-item expanded "><a href="../graphs/adjlist.html"><strong aria-hidden="true">13.</strong> Adjacency List Graph Representation</a></li><li class="chapter-item expanded "><a href="../graphs/dijkstra.html"><strong aria-hidden="true">14.</strong> Dijkstra</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../graphs/dial.html"><strong aria-hidden="true">14.1.</strong> Dial</a></li></ol></li><li class="chapter-item expanded "><a href="../graphs/dsu.html"><strong aria-hidden="true">15.</strong> Disjoint Set Union</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../graphs/wdsu.html"><strong aria-hidden="true">15.1.</strong> Weighted DSU</a></li></ol></li><li class="chapter-item expanded "><a href="../graphs/scc.html"><strong aria-hidden="true">16.</strong> Strongly Connected Components</a></li><li class="chapter-item expanded "><a href="../graphs/2sat.html"><strong aria-hidden="true">17.</strong> 2-SAT</a></li><li class="chapter-item expanded affix "><li class="part-title">Strings</li><li class="chapter-item expanded "><a href="../strings/kmp.html"><strong aria-hidden="true">18.</strong> KMP</a></li><li class="chapter-item expanded "><a href="../strings/manacher.html"><strong aria-hidden="true">19.</strong> Manacher</a></li><li class="chapter-item expanded "><a href="../strings/salcp.html"><strong aria-hidden="true">20.</strong> Suffix Array and LCP Array</a></li><li class="chapter-item expanded affix "><li class="part-title">Geometry</li><li class="chapter-item expanded "><a href="../geometry/convexhull.html"><strong aria-hidden="true">21.</strong> Convex Hull</a></li><li class="chapter-item expanded affix "><li class="part-title">Unclassified</li><li class="chapter-item expanded "><a href="../unclass/valcomp.html"><strong aria-hidden="true">22.</strong> Value Compression</a></li><li class="chapter-item expanded "><a href="../unclass/lis.html"><strong aria-hidden="true">23.</strong> Longest Increasing Subsequence</a></li><li class="chapter-item expanded "><a href="../unclass/mos.html"><strong aria-hidden="true">24.</strong> Mo's</a></li><li class="chapter-item expanded "><a href="../unclass/bigint.html"><strong aria-hidden="true">25.</strong> Arbitrary-Precision Integer</a></li><li class="chapter-item expanded affix "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="../misc/fastio.html"><strong aria-hidden="true">26.</strong> Fast IO</a></li><li class="chapter-item expanded "><a href="../misc/macro.html"><strong aria-hidden="true">27.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../misc/zero_one_trait.html"><strong aria-hidden="true">28.</strong> Zero/One Trait (Deprecated)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="nord_light">Nord Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="nord_dark">Nord Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Snippets for Competitive Programming</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BamgoeSN/rust-ps-md" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bitset"><a class="header" href="#bitset">Bitset</a></h1>
<p><code>BitSet</code> is equivalent to a fixed-size array of booleans. Each boolean value is packed as a bit of <code>u64</code>.</p>
<p>For auto-vectorization, each <code>u64</code> are packed as <code>[u64; 4]</code> so that it can act as a &quot;SIMD lane&quot;.</p>
<p>As this snippet is purely for PS and CP, it does not contain many necessary checks, such as checking if two bitset as an argument of a function has the same length.
For any other purpose, I highly recommend the <a href="https://docs.rs/bitset-core/latest/bitset_core/">bitset_core crate</a> which highly inspired this snippet.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>An array of <code>[u64; 4]</code> implements <code>BitSetOps</code> trait, therefore is recognized as a bitset. The number of booleans packed into the bitset can be found with <code>fn bit_len(&amp;self) -&gt; usize</code>.</p>
<p>Refer to the <a href="#apis">APIs</a> for further information.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use bitset::*;
<span class="boring">
</span><span class="boring">fn main() {
</span>const MAX_VAL: usize = 1000000;

let mut is_prime = [[0u64; 4]; (MAX_VAL + 256) / 256];
println!(&quot;{}&quot;, is_prime.bit_len()); // 1000192

is_prime.bit_init(true);
is_prime.bit_reset(0);
is_prime.bit_reset(1);

for i in (2..=MAX_VAL).take_while(|&amp;i| i * i &lt;= MAX_VAL) {
    if is_prime.bit_get(i) {
        for j in (i * i..=MAX_VAL).step_by(i) {
            is_prime.bit_reset(j);
        }
    }
}

println!(
    &quot;{}&quot;,
    is_prime.bit_count_ones() - (is_prime.bit_len() - (MAX_VAL + 1))
); // 78498
<span class="boring">}
</span><span class="boring">
</span><span class="boring">mod bitset {
</span><span class="boring">    /* Copyright (c) 2020 Casper &lt;CasualX@users.noreply.github.com&gt;
</span><span class="boring">     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
</span><span class="boring">     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
</span><span class="boring">     * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</span><span class="boring">     */
</span><span class="boring">
</span><span class="boring">    //! This module is purely for PS and CP. Thus it skips safety checks such as checking if
</span><span class="boring">    //! self.len() and rhs.len() are equal, and it may panic if shift overflow (for the whole
</span><span class="boring">    //! bitset) happens.
</span><span class="boring">
</span><span class="boring">    // DO NOT CHANGE THESE VALUES
</span><span class="boring">    // The full generalization for bitset is not done.
</span><span class="boring">    type ElemTy = u64;
</span><span class="boring">    const ELEM_BIT: usize = ElemTy::BITS as usize;
</span><span class="boring">    const ELEM_LEN: usize = 4;
</span><span class="boring">    const BITS_PER_WORD: usize = ELEM_BIT * ELEM_LEN;
</span><span class="boring">
</span><span class="boring">    pub type BitSet = [[ElemTy; ELEM_LEN]];
</span><span class="boring">
</span><span class="boring">    pub trait BitSetOps {
</span><span class="boring">        fn bit_len(&amp;self) -&gt; usize;
</span><span class="boring">        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_get(&amp;self, idx: usize) -&gt; bool;
</span><span class="boring">        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_all(&amp;self) -&gt; bool;
</span><span class="boring">        fn bit_any(&amp;self) -&gt; bool;
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_none(&amp;self) -&gt; bool {
</span><span class="boring">            !self.bit_any()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool;
</span><span class="boring">        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool;
</span><span class="boring">        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool;
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_superset(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            rhs.bit_subset(self)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_not(&amp;mut self) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self;
</span><span class="boring">        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self;
</span><span class="boring">
</span><span class="boring">        fn bit_count_ones(&amp;self) -&gt; usize;
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_count_zeros(&amp;self) -&gt; usize {
</span><span class="boring">            self.bit_len() - self.bit_count_ones()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_fmt(&amp;self) -&gt; &amp;BitFmt&lt;Self&gt; {
</span><span class="boring">            unsafe { &amp;*(self as *const _ as *const _) }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl BitSetOps for BitSet {
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_len(&amp;self) -&gt; usize {
</span><span class="boring">            self.len() * BITS_PER_WORD
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self {
</span><span class="boring">            let val = [ElemTy::wrapping_add(!(val as ElemTy), 1); ELEM_LEN];
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i] = val;
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_get(&amp;self, idx: usize) -&gt; bool {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] &amp; (1 &lt;&lt; bit) != 0
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] |= 1 &lt;&lt; bit;
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] &amp;= !(1 &lt;&lt; bit);
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            self[block][lane] ^= 1 &lt;&lt; bit;
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self {
</span><span class="boring">            let block = idx / BITS_PER_WORD;
</span><span class="boring">            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
</span><span class="boring">            let bit = idx % ELEM_BIT;
</span><span class="boring">            let mask = 1 &lt;&lt; bit;
</span><span class="boring">            self[block][lane] =
</span><span class="boring">                (self[block][lane] &amp; !mask) | (ElemTy::wrapping_add(!(val as ElemTy), 1) &amp; mask);
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_all(&amp;self) -&gt; bool {
</span><span class="boring">            self.iter()
</span><span class="boring">                .all(|block| block[0] == !0 &amp;&amp; block[1] == !0 &amp;&amp; block[2] == !0 &amp;&amp; block[3] == !0)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_any(&amp;self) -&gt; bool {
</span><span class="boring">            self.iter()
</span><span class="boring">                .all(|block| block[0] == 0 &amp;&amp; block[1] == 0 &amp;&amp; block[2] == 0 &amp;&amp; block[3] == 0)
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
</span><span class="boring">                lblk[0] == rblk[0] &amp;&amp; lblk[1] == rblk[1] &amp;&amp; lblk[2] == rblk[2] &amp;&amp; lblk[3] == rblk[3]
</span><span class="boring">            })
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
</span><span class="boring">                lblk[0] &amp; rblk[0] == 0
</span><span class="boring">                    &amp;&amp; lblk[1] &amp; rblk[1] == 0
</span><span class="boring">                    &amp;&amp; lblk[2] &amp; rblk[2] == 0
</span><span class="boring">                    &amp;&amp; lblk[3] &amp; rblk[3] == 0
</span><span class="boring">            })
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool {
</span><span class="boring">            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
</span><span class="boring">                rblk[0] == rblk[0] | lblk[0]
</span><span class="boring">                    &amp;&amp; rblk[1] == rblk[1] | lblk[1]
</span><span class="boring">                    &amp;&amp; rblk[2] == rblk[2] | lblk[2]
</span><span class="boring">                    &amp;&amp; rblk[3] == rblk[3] | lblk[3]
</span><span class="boring">            })
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] |= rhs[i][0];
</span><span class="boring">                self[i][1] |= rhs[i][1];
</span><span class="boring">                self[i][2] |= rhs[i][2];
</span><span class="boring">                self[i][3] |= rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] &amp;= rhs[i][0];
</span><span class="boring">                self[i][1] &amp;= rhs[i][1];
</span><span class="boring">                self[i][2] &amp;= rhs[i][2];
</span><span class="boring">                self[i][3] &amp;= rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] &amp;= !rhs[i][0];
</span><span class="boring">                self[i][1] &amp;= !rhs[i][1];
</span><span class="boring">                self[i][2] &amp;= !rhs[i][2];
</span><span class="boring">                self[i][3] &amp;= !rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] ^= rhs[i][0];
</span><span class="boring">                self[i][1] ^= rhs[i][1];
</span><span class="boring">                self[i][2] ^= rhs[i][2];
</span><span class="boring">                self[i][3] ^= rhs[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_not(&amp;mut self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] = !self[i][0];
</span><span class="boring">                self[i][1] = !self[i][1];
</span><span class="boring">                self[i][2] = !self[i][2];
</span><span class="boring">                self[i][3] = !self[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self {
</span><span class="boring">            for i in 0..self.len() {
</span><span class="boring">                self[i][0] = self[i][0] &amp; !mask[i][0] | rhs[i][0] &amp; mask[i][0];
</span><span class="boring">                self[i][1] = self[i][1] &amp; !mask[i][1] | rhs[i][1] &amp; mask[i][1];
</span><span class="boring">                self[i][2] = self[i][2] &amp; !mask[i][2] | rhs[i][2] &amp; mask[i][2];
</span><span class="boring">                self[i][3] = self[i][3] &amp; !mask[i][3] | rhs[i][3] &amp; mask[i][3];
</span><span class="boring">            }
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let elem_move = by / ELEM_BIT;
</span><span class="boring">            let bit_move = by % ELEM_BIT;
</span><span class="boring">
</span><span class="boring">            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
</span><span class="boring">            slice.copy_within(..slice.len() - elem_move, elem_move);
</span><span class="boring">            slice[..elem_move].fill(0);
</span><span class="boring">
</span><span class="boring">            if bit_move != 0 {
</span><span class="boring">                let mut carry: ElemTy = 0;
</span><span class="boring">                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
</span><span class="boring">                for i in 0..self.len() {
</span><span class="boring">                    tmp[0] = self[i][0] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[1] = self[i][1] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[2] = self[i][2] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[3] = self[i][3] &gt;&gt; (ELEM_BIT - bit_move);
</span><span class="boring">                    self[i][0] &lt;&lt;= bit_move;
</span><span class="boring">                    self[i][1] &lt;&lt;= bit_move;
</span><span class="boring">                    self[i][2] &lt;&lt;= bit_move;
</span><span class="boring">                    self[i][3] &lt;&lt;= bit_move;
</span><span class="boring">                    let tmpc = tmp[ELEM_LEN - 1];
</span><span class="boring">                    tmp.copy_within(..ELEM_LEN - 1, 1);
</span><span class="boring">                    tmp[0] = carry;
</span><span class="boring">                    self[i][0] |= tmp[0];
</span><span class="boring">                    self[i][1] |= tmp[1];
</span><span class="boring">                    self[i][2] |= tmp[2];
</span><span class="boring">                    self[i][3] |= tmp[3];
</span><span class="boring">                    carry = tmpc;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self {
</span><span class="boring">            let elem_move = by / ELEM_BIT;
</span><span class="boring">            let bit_move = by % ELEM_BIT;
</span><span class="boring">
</span><span class="boring">            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
</span><span class="boring">            slice.copy_within(elem_move.., 0);
</span><span class="boring">            let sl = slice.len();
</span><span class="boring">            slice[sl - elem_move..].fill(0);
</span><span class="boring">
</span><span class="boring">            if bit_move != 0 {
</span><span class="boring">                let mut carry: ElemTy = 0;
</span><span class="boring">                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
</span><span class="boring">                for i in 0..self.len() {
</span><span class="boring">                    tmp[0] = self[i][0] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[1] = self[i][1] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[2] = self[i][2] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    tmp[3] = self[i][3] &lt;&lt; (ELEM_BIT - bit_move);
</span><span class="boring">                    self[i][0] &gt;&gt;= bit_move;
</span><span class="boring">                    self[i][1] &gt;&gt;= bit_move;
</span><span class="boring">                    self[i][2] &gt;&gt;= bit_move;
</span><span class="boring">                    self[i][3] &gt;&gt;= bit_move;
</span><span class="boring">                    let tmpc = tmp[0];
</span><span class="boring">                    tmp.copy_within(1.., 0);
</span><span class="boring">                    tmp[ELEM_LEN - 1] = carry;
</span><span class="boring">                    carry = tmpc;
</span><span class="boring">                    self[i][0] |= tmp[0];
</span><span class="boring">                    self[i][1] |= tmp[1];
</span><span class="boring">                    self[i][2] |= tmp[2];
</span><span class="boring">                    self[i][3] |= tmp[3];
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            self
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[inline]
</span><span class="boring">        fn bit_count_ones(&amp;self) -&gt; usize {
</span><span class="boring">            self.iter()
</span><span class="boring">                .map(|chunk| {
</span><span class="boring">                    chunk[0].count_ones() as usize
</span><span class="boring">                        + chunk[1].count_ones() as usize
</span><span class="boring">                        + chunk[2].count_ones() as usize
</span><span class="boring">                        + chunk[3].count_ones() as usize
</span><span class="boring">                })
</span><span class="boring">                .sum()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    mod fmt {
</span><span class="boring">        use super::BitSetOps as BitSet;
</span><span class="boring">        use std::fmt;
</span><span class="boring">
</span><span class="boring">        #[repr(transparent)]
</span><span class="boring">        pub struct BitFmt&lt;T: ?Sized&gt;(T);
</span><span class="boring">
</span><span class="boring">        fn bitstring&lt;T: ?Sized + BitSet&gt;(this: &amp;T, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">            const ALPHABET: [u8; 2] = [b'0', b'1'];
</span><span class="boring">            let mut buf = [0u8; 9];
</span><span class="boring">            let mut first = true;
</span><span class="boring">            buf[0] = b'_';
</span><span class="boring">            let mut i = 0;
</span><span class="boring">            while i &lt; this.bit_len() {
</span><span class="boring">                buf[1] = ALPHABET[this.bit_get(i + 0) as usize];
</span><span class="boring">                buf[2] = ALPHABET[this.bit_get(i + 1) as usize];
</span><span class="boring">                buf[3] = ALPHABET[this.bit_get(i + 2) as usize];
</span><span class="boring">                buf[4] = ALPHABET[this.bit_get(i + 3) as usize];
</span><span class="boring">                buf[5] = ALPHABET[this.bit_get(i + 4) as usize];
</span><span class="boring">                buf[6] = ALPHABET[this.bit_get(i + 5) as usize];
</span><span class="boring">                buf[7] = ALPHABET[this.bit_get(i + 6) as usize];
</span><span class="boring">                buf[8] = ALPHABET[this.bit_get(i + 7) as usize];
</span><span class="boring">                let s = unsafe { &amp;*((&amp;buf[first as usize..]) as *const _ as *const str) };
</span><span class="boring">                f.write_str(s)?;
</span><span class="boring">                i += 8;
</span><span class="boring">                first = false;
</span><span class="boring">            }
</span><span class="boring">            Ok(())
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl&lt;T: ?Sized + BitSet&gt; fmt::Display for BitFmt&lt;T&gt; {
</span><span class="boring">            fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">                bitstring(&amp;self.0, f)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub use self::fmt::BitFmt;
</span><span class="boring">}</span></code></pre></pre>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-rust noplayground">mod bitset {
    /* Copyright (c) 2020 Casper &lt;CasualX@users.noreply.github.com&gt;
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */

    //! This module is purely for PS and CP. Thus it skips safety checks such as checking if
    //! self.len() and rhs.len() are equal, and it may panic if shift overflow (for the whole
    //! bitset) happens.

    // DO NOT CHANGE THESE VALUES
    // The full generalization for bitset is not done.
    type ElemTy = u64;
    const ELEM_BIT: usize = ElemTy::BITS as usize;
    const ELEM_LEN: usize = 4;
    const BITS_PER_WORD: usize = ELEM_BIT * ELEM_LEN;

    pub type BitSet = [[ElemTy; ELEM_LEN]];

    pub trait BitSetOps {
        fn bit_len(&amp;self) -&gt; usize;
        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self;

        fn bit_get(&amp;self, idx: usize) -&gt; bool;
        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self;
        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self;

        fn bit_all(&amp;self) -&gt; bool;
        fn bit_any(&amp;self) -&gt; bool;
        #[inline]
        fn bit_none(&amp;self) -&gt; bool {
            !self.bit_any()
        }

        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool;
        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool;
        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool;
        #[inline]
        fn bit_superset(&amp;self, rhs: &amp;Self) -&gt; bool {
            rhs.bit_subset(self)
        }

        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self;
        fn bit_not(&amp;mut self) -&gt; &amp;mut Self;
        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self;

        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self;
        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self;

        fn bit_count_ones(&amp;self) -&gt; usize;
        #[inline]
        fn bit_count_zeros(&amp;self) -&gt; usize {
            self.bit_len() - self.bit_count_ones()
        }

        #[inline]
        fn bit_fmt(&amp;self) -&gt; &amp;BitFmt&lt;Self&gt; {
            unsafe { &amp;*(self as *const _ as *const _) }
        }
    }

    impl BitSetOps for BitSet {
        #[inline]
        fn bit_len(&amp;self) -&gt; usize {
            self.len() * BITS_PER_WORD
        }

        #[inline]
        fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self {
            let val = [ElemTy::wrapping_add(!(val as ElemTy), 1); ELEM_LEN];
            for i in 0..self.len() {
                self[i] = val;
            }
            self
        }

        #[inline]
        fn bit_get(&amp;self, idx: usize) -&gt; bool {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] &amp; (1 &lt;&lt; bit) != 0
        }

        #[inline]
        fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] |= 1 &lt;&lt; bit;
            self
        }

        #[inline]
        fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] &amp;= !(1 &lt;&lt; bit);
            self
        }

        #[inline]
        fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            self[block][lane] ^= 1 &lt;&lt; bit;
            self
        }

        #[inline]
        fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self {
            let block = idx / BITS_PER_WORD;
            let lane = (idx % BITS_PER_WORD) / ELEM_BIT;
            let bit = idx % ELEM_BIT;
            let mask = 1 &lt;&lt; bit;
            self[block][lane] =
                (self[block][lane] &amp; !mask) | (ElemTy::wrapping_add(!(val as ElemTy), 1) &amp; mask);
            self
        }

        #[inline]
        fn bit_all(&amp;self) -&gt; bool {
            self.iter()
                .all(|block| block[0] == !0 &amp;&amp; block[1] == !0 &amp;&amp; block[2] == !0 &amp;&amp; block[3] == !0)
        }

        #[inline]
        fn bit_any(&amp;self) -&gt; bool {
            self.iter()
                .all(|block| block[0] == 0 &amp;&amp; block[1] == 0 &amp;&amp; block[2] == 0 &amp;&amp; block[3] == 0)
        }

        #[inline]
        fn bit_eq(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
                lblk[0] == rblk[0] &amp;&amp; lblk[1] == rblk[1] &amp;&amp; lblk[2] == rblk[2] &amp;&amp; lblk[3] == rblk[3]
            })
        }

        #[inline]
        fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
                lblk[0] &amp; rblk[0] == 0
                    &amp;&amp; lblk[1] &amp; rblk[1] == 0
                    &amp;&amp; lblk[2] &amp; rblk[2] == 0
                    &amp;&amp; lblk[3] &amp; rblk[3] == 0
            })
        }

        /// Returns if self is a subset of rhs
        #[inline]
        fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.iter().zip(rhs.iter()).all(|(&amp;lblk, &amp;rblk)| {
                rblk[0] == rblk[0] | lblk[0]
                    &amp;&amp; rblk[1] == rblk[1] | lblk[1]
                    &amp;&amp; rblk[2] == rblk[2] | lblk[2]
                    &amp;&amp; rblk[3] == rblk[3] | lblk[3]
            })
        }

        #[inline]
        fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] |= rhs[i][0];
                self[i][1] |= rhs[i][1];
                self[i][2] |= rhs[i][2];
                self[i][3] |= rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] &amp;= rhs[i][0];
                self[i][1] &amp;= rhs[i][1];
                self[i][2] &amp;= rhs[i][2];
                self[i][3] &amp;= rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] &amp;= !rhs[i][0];
                self[i][1] &amp;= !rhs[i][1];
                self[i][2] &amp;= !rhs[i][2];
                self[i][3] &amp;= !rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] ^= rhs[i][0];
                self[i][1] ^= rhs[i][1];
                self[i][2] ^= rhs[i][2];
                self[i][3] ^= rhs[i][3];
            }
            self
        }

        #[inline]
        fn bit_not(&amp;mut self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] = !self[i][0];
                self[i][1] = !self[i][1];
                self[i][2] = !self[i][2];
                self[i][3] = !self[i][3];
            }
            self
        }

        #[inline]
        fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self {
            for i in 0..self.len() {
                self[i][0] = self[i][0] &amp; !mask[i][0] | rhs[i][0] &amp; mask[i][0];
                self[i][1] = self[i][1] &amp; !mask[i][1] | rhs[i][1] &amp; mask[i][1];
                self[i][2] = self[i][2] &amp; !mask[i][2] | rhs[i][2] &amp; mask[i][2];
                self[i][3] = self[i][3] &amp; !mask[i][3] | rhs[i][3] &amp; mask[i][3];
            }
            self
        }

        #[inline]
        fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self {
            let elem_move = by / ELEM_BIT;
            let bit_move = by % ELEM_BIT;

            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
            slice.copy_within(..slice.len() - elem_move, elem_move);
            slice[..elem_move].fill(0);

            if bit_move != 0 {
                let mut carry: ElemTy = 0;
                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
                for i in 0..self.len() {
                    tmp[0] = self[i][0] &gt;&gt; (ELEM_BIT - bit_move);
                    tmp[1] = self[i][1] &gt;&gt; (ELEM_BIT - bit_move);
                    tmp[2] = self[i][2] &gt;&gt; (ELEM_BIT - bit_move);
                    tmp[3] = self[i][3] &gt;&gt; (ELEM_BIT - bit_move);
                    self[i][0] &lt;&lt;= bit_move;
                    self[i][1] &lt;&lt;= bit_move;
                    self[i][2] &lt;&lt;= bit_move;
                    self[i][3] &lt;&lt;= bit_move;
                    let tmpc = tmp[ELEM_LEN - 1];
                    tmp.copy_within(..ELEM_LEN - 1, 1);
                    tmp[0] = carry;
                    self[i][0] |= tmp[0];
                    self[i][1] |= tmp[1];
                    self[i][2] |= tmp[2];
                    self[i][3] |= tmp[3];
                    carry = tmpc;
                }
            }

            self
        }

        #[inline]
        fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self {
            let elem_move = by / ELEM_BIT;
            let bit_move = by % ELEM_BIT;

            let (_, slice, _): (_, &amp;mut [ElemTy], _) = unsafe { self.align_to_mut() };
            slice.copy_within(elem_move.., 0);
            let sl = slice.len();
            slice[sl - elem_move..].fill(0);

            if bit_move != 0 {
                let mut carry: ElemTy = 0;
                let mut tmp: [ElemTy; ELEM_LEN] = [0; ELEM_LEN];
                for i in 0..self.len() {
                    tmp[0] = self[i][0] &lt;&lt; (ELEM_BIT - bit_move);
                    tmp[1] = self[i][1] &lt;&lt; (ELEM_BIT - bit_move);
                    tmp[2] = self[i][2] &lt;&lt; (ELEM_BIT - bit_move);
                    tmp[3] = self[i][3] &lt;&lt; (ELEM_BIT - bit_move);
                    self[i][0] &gt;&gt;= bit_move;
                    self[i][1] &gt;&gt;= bit_move;
                    self[i][2] &gt;&gt;= bit_move;
                    self[i][3] &gt;&gt;= bit_move;
                    let tmpc = tmp[0];
                    tmp.copy_within(1.., 0);
                    tmp[ELEM_LEN - 1] = carry;
                    carry = tmpc;
                    self[i][0] |= tmp[0];
                    self[i][1] |= tmp[1];
                    self[i][2] |= tmp[2];
                    self[i][3] |= tmp[3];
                }
            }

            self
        }

        #[inline]
        fn bit_count_ones(&amp;self) -&gt; usize {
            self.iter()
                .map(|chunk| {
                    chunk[0].count_ones() as usize
                        + chunk[1].count_ones() as usize
                        + chunk[2].count_ones() as usize
                        + chunk[3].count_ones() as usize
                })
                .sum()
        }
    }

    mod fmt {
        use super::BitSetOps as BitSet;
        use std::fmt;

        #[repr(transparent)]
        pub struct BitFmt&lt;T: ?Sized&gt;(T);

        fn bitstring&lt;T: ?Sized + BitSet&gt;(this: &amp;T, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            const ALPHABET: [u8; 2] = [b'0', b'1'];
            let mut buf = [0u8; 9];
            let mut first = true;
            buf[0] = b'_';
            let mut i = 0;
            while i &lt; this.bit_len() {
                buf[1] = ALPHABET[this.bit_get(i + 0) as usize];
                buf[2] = ALPHABET[this.bit_get(i + 1) as usize];
                buf[3] = ALPHABET[this.bit_get(i + 2) as usize];
                buf[4] = ALPHABET[this.bit_get(i + 3) as usize];
                buf[5] = ALPHABET[this.bit_get(i + 4) as usize];
                buf[6] = ALPHABET[this.bit_get(i + 5) as usize];
                buf[7] = ALPHABET[this.bit_get(i + 6) as usize];
                buf[8] = ALPHABET[this.bit_get(i + 7) as usize];
                let s = unsafe { &amp;*((&amp;buf[first as usize..]) as *const _ as *const str) };
                f.write_str(s)?;
                i += 8;
                first = false;
            }
            Ok(())
        }

        impl&lt;T: ?Sized + BitSet&gt; fmt::Display for BitFmt&lt;T&gt; {
            fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
                bitstring(&amp;self.0, f)
            }
        }
    }
    pub use self::fmt::BitFmt;
}</code></pre>
<h2 id="simd-auto-vectorization-and-rustc-optimization-level"><a class="header" href="#simd-auto-vectorization-and-rustc-optimization-level">SIMD, Auto-vectorization and <code>rustc</code> Optimization Level</a></h2>
<p>To fully enable the power of aggressive SIMD optimization, the <code>opt-level</code> for compilation should be 3.
When the level is 2, despite many of vectorizations still happen, the occurence noticably decreases.</p>
<p>As most of the OJs compile Rust codes with <code>opt-level</code> of 2, to fully enable the power of SIMD, you need to hardcode the machine code into Rust.
As this is virtually impossible to do manually in actual PS/CP, using third-party tools like <a href="https://github.com/kiwiyou/basm-rs">basm-rs</a> is highly recommended.</p>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<p>The behavior of APIs having multiple bitsets as arguments, when their length are not equal to each other, is unspecified.</p>
<ul>
<li>
<p><code>pub type BitSet</code></p>
<p><code>[u64; 4]</code> is defined as a <code>type BitSet</code>.
As this is a dynamically sized type, when declaring a bitset you cannot use <code>BitSet</code> in its type declaration.
Instead, you need to do like the below example.</p>
<pre><code class="language-rust noplayground">let mut bitset</code></pre>
</li>
<li>
<p><code>fn bit_len(&amp;self) -&gt; usize</code></p>
<p>Returns the number of boolean values included in the set.</p>
</li>
<li>
<p><code>fn bit_init(&amp;mut self, val: bool) -&gt; &amp;mut Self</code></p>
<p>Initializes every boolean value of <code>self</code> as <code>val</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_get(&amp;self, idx: usize) -&gt; bool</code></p>
<p>Returns the <code>idx</code>th boolean value of <code>self</code>.</p>
</li>
<li>
<p><code>fn bit_set(&amp;mut self, idx: usize) -&gt; &amp;mut Self</code></p>
<p>Sets the <code>idx</code>th boolean value to <code>true</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_reset(&amp;mut self, idx: usize) -&gt; &amp;mut Self</code></p>
<p>Sets the <code>idx</code>th boolean value to <code>false</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_flip(&amp;mut self, idx: usize) -&gt; &amp;mut Self</code></p>
<p>Flips the <code>idx</code>th boolean value, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_manip(&amp;mut self, idx: usize, val: bool) -&gt; &amp;mut Self</code></p>
<p>Sets the <code>idx</code>th boolean value to <code>val</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_all(&amp;self) -&gt; bool</code></p>
<p>Returns <code>true</code> if every boolean value of <code>self</code> is <code>true</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_none(&amp;self) -&gt; bool</code></p>
<p>Returns <code>true</code> if every boolean value of <code>self</code> is <code>false</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_disjoint(&amp;self, rhs: &amp;Self) -&gt; bool</code></p>
<p>Returns <code>true</code> if every bit of <code>self</code> turned on is not in <code>rhs</code>, and vice versa. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_subset(&amp;self, rhs: &amp;Self) -&gt; bool</code></p>
<p>Returns <code>true</code> if <code>self</code> is a subset of <code>rhs</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_superset(&amp;self, rhs: &amp;Self) -&gt; bool</code></p>
<p>Returns <code>true</code> if <code>self</code> is a superset of <code>rhs</code>. Otherwise, returns <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_or(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self | rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_and(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self &amp; rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_nand(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self &amp; !rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_xor(&amp;mut self, rhs: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>self ^ rhs</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_not(&amp;mut self) -&gt; &amp;mut Self</code></p>
<p>Reverses every bits of <code>self</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_mask(&amp;mut self, rhs: &amp;Self, mask: &amp;Self) -&gt; &amp;mut Self</code></p>
<p>Sets <code>self</code> as <code>(self &amp; !mask) | (rhs &amp; mask)</code>, and returns <code>&amp;mut self</code> back.</p>
</li>
<li>
<p><code>fn bit_shr(&amp;mut self, by: usize) -&gt; &amp;mut Self</code></p>
<p>Shifts <code>self</code> right by <code>by</code>. The direction of shifting is to the lower index.
The empty bits are filled with <code>0</code>, and the overflowed bits disappear.</p>
</li>
<li>
<p><code>fn bit_shl(&amp;mut self, by: usize) -&gt; &amp;mut Self</code></p>
<p>Shifts <code>self</code> left by <code>by</code>. The direction of shifting is to the lower index.
The empty bits are filled with <code>0</code>, and the overflowed bits disappear.</p>
</li>
<li>
<p><code>fn bit_count_ones(&amp;self) -&gt; usize</code></p>
<p>Returns the number of boolean values that is <code>true</code>.</p>
</li>
<li>
<p><code>fn bit_count_zeros(&amp;self) -&gt; usize</code></p>
<p>Returns the number of boolean values that is <code>false</code>.</p>
</li>
<li>
<p><code>fn bit_fmt(&amp;self) -&gt; &amp;BitFmt&lt;Self&gt;</code></p>
<p>Used for printing out the bitset.</p>
<pre><code class="language-rust noplayground">println!(&quot;{}&quot;, bitset.bit_fmt());</code></pre>
</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This code is protected under MIT license, holded by 
Casper <a href="mailto:CasualX@users.noreply.github.com">CasualX@users.noreply.github.com</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../numerical/linrec/bostanmori.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../datastructure/segtree/intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../numerical/linrec/bostanmori.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../datastructure/segtree/intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
